# Утечки памяти в JavaScript

## Краткий ответ для собеседования

**Утечка памяти** — когда объекты остаются в памяти, хотя больше не нужны, и сборщик мусора не может их удалить. Причины: глобальные переменные, забытые таймеры/обработчики событий, замыкания с большими данными, циклические ссылки (в старых браузерах), DOM-ссылки на удалённые элементы. Решения: очищать таймеры, удалять обработчики событий, избегать хранения больших данных в замыканиях, использовать WeakMap/WeakSet.

---

## Что такое утечка памяти

**Утечка памяти (Memory Leak)** — это ситуация, когда **объекты остаются в памяти**, хотя они больше не нужны программе, и **сборщик мусора не может их удалить**.

**Последствия:**
- Рост потребления памяти
- Замедление приложения
- Зависание, крах (если память закончится)

---

## Как работает сборщик мусора

JavaScript использует **автоматическую сборку мусора** (Garbage Collection).

**Алгоритм:** Mark-and-Sweep (помечает достижимые объекты, удаляет недостижимые).

**Достижимый объект** — доступен из корней (глобальные переменные, текущий стек вызовов).

**Пример:**

```js
let user = { name: 'John' };
user = null; // объект больше не достижим → будет удалён GC
```

**Утечка:**  
Если объект **всё ещё достижим**, но больше не нужен → утечка памяти.

---

## Основные причины утечек памяти

### 1. Глобальные переменные

**Проблема:**  
Глобальные переменные **всегда достижимы** → никогда не удаляются.

```js
function createUser() {
  user = { name: 'John', data: new Array(1000000) }; // без let/const → глобальная
}

createUser();
// user остаётся в памяти навсегда
```

**Решение:**
- Использовать `'use strict'` — запретит создание глобальных переменных случайно
- Всегда объявлять переменные через `let`, `const`, `var`

---

### 2. Забытые таймеры и интервалы

**Проблема:**  
`setTimeout`/`setInterval` держат ссылки на объекты в колбэках.

```js
function Component() {
  const data = new Array(1000000);
  
  setInterval(() => {
    console.log(data.length); // data остаётся в памяти
  }, 1000);
}

Component();
// data никогда не удалится, хотя компонент уже не нужен
```

**Решение:**  
Очищать таймеры:

```js
const intervalId = setInterval(() => {
  console.log(data.length);
}, 1000);

// При размонтировании компонента
clearInterval(intervalId);
```

**В React:**

```jsx
useEffect(() => {
  const id = setInterval(() => {
    console.log('tick');
  }, 1000);
  
  return () => clearInterval(id); // очистка
}, []);
```

---

### 3. Забытые обработчики событий

**Проблема:**  
Обработчики событий держат ссылки на объекты.

```js
function Component() {
  const data = new Array(1000000);
  
  const handleClick = () => {
    console.log(data.length);
  };
  
  document.addEventListener('click', handleClick);
}

Component();
// data остаётся в памяти через замыкание handleClick
```

**Решение:**  
Удалять обработчики:

```js
document.removeEventListener('click', handleClick);
```

**В React:**

```jsx
useEffect(() => {
  const handleClick = () => console.log('click');
  
  document.addEventListener('click', handleClick);
  
  return () => document.removeEventListener('click', handleClick); // очистка
}, []);
```

---

### 4. Замыкания с большими данными

**Проблема:**  
Замыкание сохраняет все переменные из внешней области видимости, даже если они не используются.

```js
function createClosure() {
  const bigData = new Array(1000000).fill('data');
  
  return function() {
    console.log('Hello'); // не использует bigData
  };
}

const fn = createClosure();
// bigData остаётся в памяти, хотя не используется
```

**Решение:**  
Не хранить большие данные в замыканиях, если они не нужны:

```js
function createClosure() {
  const bigData = new Array(1000000).fill('data');
  
  // Обработать данные здесь
  const result = bigData.length;
  
  return function() {
    console.log(result); // только result в замыкании, не весь bigData
  };
}
```

---

### 5. DOM-ссылки на удалённые элементы

**Проблема:**  
Если хранить ссылку на DOM-элемент, он не удалится из памяти, даже если удалён из DOM.

```js
const elements = [];

function addElement() {
  const div = document.createElement('div');
  document.body.appendChild(div);
  elements.push(div); // сохранили ссылку
}

function removeElement() {
  const div = elements[0];
  document.body.removeChild(div);
  // div удалён из DOM, но ссылка в elements → не удалится из памяти
}
```

**Решение:**  
Удалять ссылки:

```js
function removeElement() {
  const div = elements.shift(); // удалили из массива
  document.body.removeChild(div);
}
```

**Или использовать WeakMap:**

```js
const elements = new WeakMap();

function addElement() {
  const div = document.createElement('div');
  elements.set(div, { data: '...' });
  // Когда div удалится из DOM и больше нет ссылок → автоматически удалится из WeakMap
}
```

---

### 6. Циклические ссылки (редко в современных браузерах)

**Проблема (старые браузеры):**  
Два объекта ссылаются друг на друга → не удаляются.

```js
function createCycle() {
  const obj1 = {};
  const obj2 = {};
  
  obj1.ref = obj2;
  obj2.ref = obj1;
}

createCycle();
// В старых браузерах obj1 и obj2 могли остаться в памяти
```

**Решение (современные браузеры):**  
Современные сборщики мусора (Mark-and-Sweep) справляются с циклическими ссылками — проверяют достижимость от корней.

---

### 7. Кэши без ограничений

**Проблема:**  
Бесконечно растущий кэш.

```js
const cache = {};

function getData(key) {
  if (!cache[key]) {
    cache[key] = fetchData(key); // кэш растёт бесконечно
  }
  return cache[key];
}
```

**Решение:**
- Ограничить размер кэша (LRU cache)
- Использовать `WeakMap` (автоматическое удаление)
- Очищать старые записи

---

## Утечки в замыканиях (подробнее)

**Замыкание** сохраняет все переменные из внешней области видимости, даже если они не используются.

**Пример утечки:**

```js
function outer() {
  const bigData = new Array(1000000).fill('x');
  const smallData = 42;
  
  return function inner() {
    console.log(smallData); // использует только smallData
  };
}

const fn = outer();
// Но bigData тоже остаётся в памяти (замыкание сохранило всю область видимости)
```

**Почему:**  
V8 и другие движки оптимизируют замыкания, но не всегда идеально — могут сохранить всю область видимости.

**Решение:**
- Не хранить большие данные в переменных, если они не нужны замыканию
- Обнулять переменные после использования:

```js
function outer() {
  let bigData = new Array(1000000).fill('x');
  const result = bigData.length;
  bigData = null; // освободили bigData
  
  return function inner() {
    console.log(result); // только result в замыкании
  };
}
```

---

## Как обнаружить утечки памяти

### 1. Chrome DevTools — Memory Profiler

**Heap Snapshot:**
- Сделать снимок памяти (Heap Snapshot)
- Выполнить действия (открыть компонент, закрыть)
- Сделать ещё снимок
- Сравнить — если объекты не удалились, есть утечка

**Allocation Timeline:**
- Отслеживает выделение памяти в реальном времени
- Синяя линия вверх без падения → утечка

### 2. Performance Monitor

Отслеживать `JS Heap Size` — если растёт без падений → утечка.

### 3. Логирование

Добавить счётчики:

```js
let instanceCount = 0;

class MyComponent {
  constructor() {
    instanceCount++;
    console.log('Instances:', instanceCount);
  }
  
  destroy() {
    instanceCount--;
    console.log('Instances:', instanceCount);
  }
}
```

---

## Как исправить утечки

1. **Очищать таймеры и интервалы** — `clearTimeout`, `clearInterval`
2. **Удалять обработчики событий** — `removeEventListener`
3. **Использовать `useEffect` cleanup** в React
4. **Не хранить большие данные в замыканиях** без необходимости
5. **Использовать WeakMap/WeakSet** для кэшей и ссылок на объекты
6. **Удалять ссылки на DOM-элементы** после удаления из DOM
7. **Избегать глобальных переменных** — использовать `'use strict'`, `let`/`const`

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Что такое утечка памяти? | Объекты остаются в памяти, хотя не нужны, и GC не может их удалить |
| Какие причины утечек? | Глобальные переменные, забытые таймеры/обработчики, замыкания с большими данными, DOM-ссылки |
| Как таймеры вызывают утечки? | `setInterval` держит ссылки в колбэке; если не очистить — объекты не удалятся |
| Как обработчики событий вызывают утечки? | `addEventListener` держит ссылку на колбэк с замыканием; если не удалить — утечка |
| Как замыкания вызывают утечки? | Замыкание сохраняет все переменные из внешней области, даже неиспользуемые |
| Как исправить утечку в React? | Использовать cleanup в `useEffect`: `return () => { /* очистка */ }` |
| Что такое WeakMap/WeakSet? | Коллекции со слабыми ссылками — объекты автоматически удаляются GC |
| Как обнаружить утечку? | Chrome DevTools → Memory Profiler → Heap Snapshot → сравнить снимки |

---

## Кратко для ответа

Утечка памяти — объекты остаются в памяти, хотя не нужны, GC не удаляет. Причины: глобальные переменные, забытые таймеры (`setInterval`) и обработчики (`addEventListener`), замыкания с большими данными, DOM-ссылки на удалённые элементы. Решения: очищать таймеры (`clearInterval`), удалять обработчики (`removeEventListener`), использовать cleanup в React (`useEffect`), не хранить большие данные в замыканиях, использовать WeakMap/WeakSet. Обнаружить: Chrome DevTools Memory Profiler.
