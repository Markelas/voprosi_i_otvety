# Функции-генераторы (Generators)

## Краткий ответ для собеседования

**Генератор** — функция, которая может **приостанавливаться** (`yield`) и **возобновляться**, возвращая последовательность значений. Объявляется через `function*`, вызов возвращает **итератор**. Методы: `next()` (продолжить), `return()` (завершить), `throw()` (выбросить ошибку). Используется для: ленивых вычислений, бесконечных последовательностей, асинхронных операций (async/await построен на генераторах), управления потоком.

---

## Что такое генератор

**Генератор (Generator)** — специальная функция, которая:
- Может **приостанавливать выполнение** (с помощью `yield`)
- **Возобновлять выполнение** (через вызов `next()`)
- **Возвращать последовательность значений** (по одному за раз)

**Синтаксис:**

```js
function* myGenerator() {
  yield 1;
  yield 2;
  yield 3;
}
```

**Вызов:**

```js
const gen = myGenerator(); // возвращает итератор

console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }
```

---

## Как работают генераторы

### 1. Объявление

```js
function* generator() {
  // тело генератора
}
```

**`function*`** — звёздочка указывает, что это генератор.

### 2. Вызов возвращает итератор

```js
const gen = generator(); // gen — это итератор
```

**Важно:**  
Вызов **не выполняет** функцию сразу, а возвращает **объект-итератор**.

### 3. `yield` — приостановка

```js
function* gen() {
  console.log('Start');
  yield 1; // приостановка, возврат 1
  console.log('Resume');
  yield 2; // приостановка, возврат 2
  console.log('End');
}
```

**`yield`** — возвращает значение и **приостанавливает** выполнение.

### 4. `next()` — возобновление

```js
const g = gen();

g.next(); // Start, { value: 1, done: false }
g.next(); // Resume, { value: 2, done: false }
g.next(); // End, { value: undefined, done: true }
```

**`next()`** — возобновляет выполнение до следующего `yield`.

---

## Методы итератора

### `next(value)`

Возобновляет выполнение, **передаёт значение** в генератор:

```js
function* gen() {
  const a = yield 1;
  console.log('Received:', a);
  const b = yield 2;
  console.log('Received:', b);
}

const g = gen();
g.next();      // { value: 1, done: false }
g.next(10);    // Received: 10, { value: 2, done: false }
g.next(20);    // Received: 20, { value: undefined, done: true }
```

### `return(value)`

**Завершает** генератор и возвращает значение:

```js
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

const g = gen();
g.next();        // { value: 1, done: false }
g.return(999);   // { value: 999, done: true }
g.next();        // { value: undefined, done: true }
```

### `throw(error)`

**Выбрасывает ошибку** внутри генератора:

```js
function* gen() {
  try {
    yield 1;
  } catch (e) {
    console.log('Caught:', e);
  }
}

const g = gen();
g.next();              // { value: 1, done: false }
g.throw(new Error('Oops')); // Caught: Error: Oops
```

---

## Применения генераторов

### 1. Ленивые вычисления

**Проблема:**  
Создать большой массив — дорого по памяти.

```js
function* range(start, end) {
  for (let i = start; i <= end; i++) {
    yield i; // генерирует по одному значению
  }
}

for (const num of range(1, 1000000)) {
  console.log(num); // значения генерируются по мере необходимости
  if (num > 10) break; // можем остановиться раньше
}
```

### 2. Бесконечные последовательности

```js
function* infiniteSequence() {
  let i = 0;
  while (true) {
    yield i++;
  }
}

const gen = infiniteSequence();
console.log(gen.next().value); // 0
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
```

### 3. Итерация по структурам данных

```js
function* traverse(tree) {
  yield tree.value;
  if (tree.left) yield* traverse(tree.left);
  if (tree.right) yield* traverse(tree.right);
}

for (const value of traverse(tree)) {
  console.log(value);
}
```

### 4. Асинхронные операции (до async/await)

```js
function* fetchData() {
  const user = yield fetch('/user');
  const posts = yield fetch(`/posts/${user.id}`);
  return posts;
}
```

**Важно:**  
`async/await` построен на генераторах под капотом.

### 5. Управление потоком (саги в Redux)

```js
function* watchLogin() {
  while (true) {
    const action = yield take('LOGIN');
    yield call(loginApi, action.payload);
  }
}
```

---

## `yield*` — делегирование

**`yield*`** — передаёт управление другому генератору или итерируемому объекту.

```js
function* gen1() {
  yield 1;
  yield 2;
}

function* gen2() {
  yield 'a';
  yield* gen1(); // делегирование
  yield 'b';
}

for (const val of gen2()) {
  console.log(val); // 'a', 1, 2, 'b'
}
```

---

## Генераторы vs Обычные функции

| Параметр | Обычная функция | Генератор |
|----------|-----------------|-----------|
| **Синтаксис** | `function foo()` | `function* foo()` |
| **Возврат** | Один раз (`return`) | Множество раз (`yield`) |
| **Выполнение** | Полностью до конца | Приостанавливается и возобновляется |
| **Результат вызова** | Результат выполнения | Итератор |
| **Состояние** | Не сохраняется между вызовами | Сохраняется между `next()` |

---

## Генераторы vs Итераторы

**Генератор** — это **упрощённый способ создания итераторов**.

**Без генератора (ручной итератор):**

```js
function range(start, end) {
  let current = start;
  return {
    next() {
      if (current <= end) {
        return { value: current++, done: false };
      }
      return { value: undefined, done: true };
    }
  };
}
```

**С генератором (проще):**

```js
function* range(start, end) {
  for (let i = start; i <= end; i++) {
    yield i;
  }
}
```

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Что такое генератор? | Функция, которая может приостанавливаться (`yield`) и возобновляться (`next()`) |
| Как объявить генератор? | `function* name() { yield ... }` |
| Что возвращает вызов генератора? | Итератор (объект с методом `next()`) |
| Что делает `yield`? | Приостанавливает выполнение и возвращает значение |
| Что делает `next()`? | Возобновляет выполнение до следующего `yield` |
| Можно ли передать значение в генератор? | Да, через `next(value)` |
| Зачем нужны генераторы? | Ленивые вычисления, бесконечные последовательности, асинхронность, управление потоком |
| Связь с async/await? | async/await построен на генераторах под капотом |
| Что такое `yield*`? | Делегирование другому генератору или итератору |

---

## Кратко для ответа

Генератор — функция (`function*`), которая может приостанавливаться (`yield`) и возобновляться (`next()`), возвращая последовательность значений. Вызов возвращает итератор. Используется для ленивых вычислений, бесконечных последовательностей, асинхронных операций, управления потоком. `yield` — возврат значения и приостановка, `next()` — возобновление, `next(value)` — передача значения внутрь, `yield*` — делегирование.
