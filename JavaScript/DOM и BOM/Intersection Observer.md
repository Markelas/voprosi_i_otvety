# Intersection Observer

## Краткий ответ для собеседования

**Intersection Observer** — браузерный API для наблюдения за пересечением элемента с **viewport** (или другим элементом-корнем). Вызывает колбэк, когда целевой элемент входит в зону видимости или выходит из неё. Используется для: **lazy loading** изображений, **бесконечного скролла**, **аналитики** (что видел пользователь), **анимаций при появлении**. Не нагружает главный поток, в отличие от прокрутки через `scroll` + проверки позиций.

---

## Что такое Intersection Observer

**Intersection Observer** — API, который асинхронно сообщает, **насколько элемент пересекается с viewport** (или с указанным корневым элементом).

**Идея:**  
Вместо постоянной проверки координат при каждом `scroll` вы один раз подписываетесь на «пересечения» — браузер сам вызывает колбэк, когда меняется видимость.

---

## Зачем нужен

### Проблема без Intersection Observer

Раньше делали так:
- Вешали обработчик на `scroll`
- В нём для каждого элемента считали `getBoundingClientRect()`, сравнивали с размерами окна
- При каждом скролле — десятки/сотни расчётов → тормоза, лишние reflow

### С Intersection Observer

- Браузер сам отслеживает пересечения
- Колбэк вызывается только при **изменении** видимости
- Расчёты вынесены из основного потока → плавный скролл

---

## Когда использовать

| Задача | Как помогает |
|--------|----------------|
| **Lazy loading изображений** | Загружать картинку только когда она попадает в viewport |
| **Бесконечный скролл** | Подгружать контент, когда пользователь дошёл до конца списка |
| **Анимации при появлении** | Запускать анимацию, когда блок стал видимым |
| **Аналитика** | Считать «просмотры» элементов (что реально было на экране) |
| **Реклама** | Учитывать показы по факту видимости |

---

## Основы работы

### 1. Создание observer

```js
const observer = new IntersectionObserver(callback, options);
```

- **callback** — функция, которую вызывают при изменении пересечения
- **options** — объект с настройками (корень, отступы, порог)

### 2. Наблюдение за элементом

```js
observer.observe(element);
```

### 3. Колбэк

Вызывается с двумя аргументами:
- **entries** — массив записей `IntersectionObserverEntry`
- **observer** — сам экземпляр `IntersectionObserver`

### 4. Остановка наблюдения

```js
observer.unobserve(element);
observer.disconnect(); // отписать все элементы
```

---

## IntersectionObserverEntry

Каждая запись в `entries` описывает видимость **одного** наблюдаемого элемента:

| Свойство | Описание |
|----------|----------|
| **`target`** | Наблюдаемый DOM-элемент |
| **`isIntersecting`** | `true` — элемент пересекается с корнем (виден) |
| **`intersectionRatio`** | Доля видимой площади (0–1) |
| **`boundingClientRect`** | Прямоугольник элемента |
| **`rootBounds`** | Прямоугольник корня (viewport или элемента) |
| **`intersectionRect`** | Прямоугольник зоны пересечения |

На практике чаще всего смотрят на **`isIntersecting`** и **`target`**.

---

## Опции (второй аргумент)

```js
const options = {
  root: null,           // null = viewport; или DOM-элемент
  rootMargin: '0px',    // «отступ» от корня: '10px 0px 100px 0px'
  threshold: 0          // при какой доле видимости вызывать: 0, 0.5, 1 или массив [0, 0.5, 1]
};

const observer = new IntersectionObserver(callback, options);
```

| Параметр | Описание |
|----------|----------|
| **root** | Элемент-контейнер, с которым считают пересечение. `null` — окно (viewport) |
| **rootMargin** | Отступы от корня (как в CSS `margin`). Увеличивают или уменьшают зону |
| **threshold** | Порог видимости: число от 0 до 1 или массив. Колбэк вызывается при достижении этих долей |

**Примеры threshold:**
- `0` — как только хотя бы 1 пиксель вошёл (или вышел)
- `1` — только когда элемент виден полностью
- `[0, 0.5, 1]` — колбэк при 0%, 50% и 100% видимости

---

## Пример: lazy loading изображений

```js
const lazyImages = document.querySelectorAll('img[data-src]');

const imageObserver = new IntersectionObserver((entries, observer) => {
  entries.forEach((entry) => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src || '';
      img.removeAttribute('data-src');
      observer.unobserve(img);
    }
  });
}, { rootMargin: '50px' });

lazyImages.forEach((img) => imageObserver.observe(img));
```

Смысл: пока картинка далеко от экрана, в `src` ничего не подставляем. Как только она попадает в зону (с учётом `rootMargin`), подставляем ссылку и перестаём за ней наблюдать.

---

## Пример: «подгрузка при скролле вниз»

```js
const sentinel = document.querySelector('#sentinel'); // элемент в конце списка

const observer = new IntersectionObserver((entries) => {
  if (entries[0].isIntersecting) {
    loadMoreContent();
  }
}, { threshold: 0 });

observer.observe(sentinel);
```

Когда нижний блок становится видимым, вызывается `loadMoreContent()`.

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Что такое Intersection Observer? | API для наблюдения за пересечением элемента с viewport (или корнем). Вызывает колбэк при изменении видимости |
| Зачем он нужен? | Чтобы не писать свой скролл с `getBoundingClientRect` на каждом scroll — меньше нагрузки, проще код |
| Типичные сценарии? | Lazy loading картинок, бесконечный скролл, анимации при появлении, аналитика просмотров |
| Что такое `isIntersecting`? | Свойство записи: `true`, если элемент пересекается с корнем (считается видимым) |
| Что такое `threshold`? | Порог видимости (0–1): при какой доле площади элемента вызывать колбэк |
| Что такое `rootMargin`? | Отступы от корня (как в CSS), расширяют или сужают зону срабатывания |
| Чем лучше scroll + getBoundingClientRect? | Observer не завязан на каждый scroll, меньше расчётов в главном потоке, асинхронность |

---

## Кратко для ответа

Intersection Observer — API для отслеживания видимости элемента в viewport (или в указанном корне). Подписываемся через `observe(element)`, в колбэке получаем `entries` с полями `isIntersecting` и `target`. Настройки: `root`, `rootMargin`, `threshold`. Используется для lazy loading, бесконечного скролла, анимаций при появлении, аналитики. Эффективнее, чем обработка scroll и ручной пересчёт позиций.
