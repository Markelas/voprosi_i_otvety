# CRP — Critical Rendering Path (Критический путь рендеринга)

## Краткий ответ для собеседования

**CRP (Critical Rendering Path)** — это последовательность шагов, которые браузер выполняет, чтобы превратить HTML, CSS и JavaScript в пиксели на экране. Основные этапы: **DOM** (из HTML), **CSSOM** (из CSS), **JavaScript** (если меняет DOM/CSSOM), **Render Tree** (DOM + CSSOM, только видимое), **Layout** (размеры и позиции), **Paint** (отрисовка пикселей), **Composite** (объединение слоёв и вывод на экран). CSS блокирует **рендер**, JS блокирует **парсер**. Reflow и repaint — дорогие операции; их оптимизируют, уменьшая узлы DOM, избегая анимаций свойств блочной модели и лишних слоёв. Оптимизация CRP: минимум критических ресурсов, async/defer для скриптов, прелоад критичного CSS/JS, минификация, CDN.

---

## Что такое CRP

**Critical Rendering Path (CRP)** — критический путь рендеринга: цепочка шагов, которые браузер должен пройти, чтобы из ответа сервера (HTML, CSS, JS) получить то, что пользователь видит на экране (пиксели).

Понимание CRP нужно, чтобы:
- объяснять, почему страница «висит» или долго не появляется;
- осознанно оптимизировать загрузку и отображение (меньше блокировок, меньше reflow/repaint);
- отвечать на собеседованиях про работу браузера и производительность.

Простыми словами: браузер не может сразу нарисовать страницу. Он по шагам: загружает и разбирает HTML → строит DOM, загружает и разбирает CSS → строит CSSOM, выполняет JS (если есть) → объединяет DOM и CSSOM в дерево рендера → считает позиции и размеры (layout) → рисует пиксели (paint) → собирает слои и выводит на экран (composite). Всё это и есть CRP.

---

## Основные этапы CRP (по порядку)

| № | Этап | Что делает |
|---|------|------------|
| 1 | **DOM** | Строит объектную модель документа из HTML |
| 2 | **CSSOM** | Строит объектную модель CSS из найденного в HTML |
| 3 | **JavaScript** | Выполняет JS, который может менять DOM и CSSOM |
| 4 | **Render Tree** | Объединяет DOM и CSSOM в дерево только видимых элементов |
| 5 | **Layout** | Считает размеры и позиции всех элементов (reflow) |
| 6 | **Paint** | Рисует пиксели (repaint) |
| 7 | **Composite** | Объединяет слои и выводит изображение на экран |

Только после всех шагов пользователь видит контент.

![[Screenshot at Jan 31 18-34-32.png]]

---

## 1. DOM — объектная модель документа

### Что происходит

Загрузка страницы начинается с запроса HTML. Как только браузер получает байты HTML, он сразу начинает **парсить** (читать сверху вниз) и строить **DOM-дерево** по мере поступления данных.

Последовательность:
1. **Байты → символы** (декодирование).
2. **Символы → токены** (разбор на теги и текст).
3. **Токены → узлы** (узлы DOM с атрибутами, текстом и т.д.).
4. **Узлы → дерево DOM** (иерархия: родитель — дети).

Узел начинается с **start tag** (открывающий тег) и заканчивается **end tag** (закрывающий). Вложенные теги дают вложенные узлы: например, `html` → `head` и `body`, `body` → `p`, `div` и т.д.

### Важно для запоминания

- Построение DOM **инкрементальное**: дерево строится по мере поступления HTML.
- **Чем больше узлов в DOM**, тем дольше строится дерево и тем тяжелее следующие этапы (layout, paint). Поэтому лишние обёртки и глубокие вложенности усложняют CRP.

---

## 2. CSSOM — объектная модель CSS

### Что происходит

Браузер находит все стили: тег `<style>` или `<link rel="stylesheet">`. Для каждого такого ресурса он:
- загружает CSS (если внешний файл);
- парсит правила;
- строит **CSSOM** — дерево стилей: какие правила к каким узлам применяются, включая наследование (дочерние узлы наследуют от родительских).

### Блокировка рендера

**CSS — блокирующий для рендера ресурс.** Браузер **не рисует контент**, пока не загрузит и не обработает все нужные для страницы CSS. Иначе мог бы сначала нарисовать «нестилизованную» страницу, а потом перерисовать — это дало бы мерцание и лишнюю работу.

При этом браузер может **параллельно** продолжать разбирать HTML и искать другую работу (например, начать загрузку скриптов). То есть CSS блокирует именно **рендер**, а не весь парсинг.

### CSSOM не инкрементальный

В отличие от DOM, **CSSOM нельзя строить по кускам** и сразу использовать для рендера: следующие правила могут переопределять предыдущие (например, `display: none` может спрятать уже добавленный узел). Поэтому браузер ждёт все CSS-правила, строит полный CSSOM и только потом переходит к построению дерева рендера.

### Оптимизация: специфичность селекторов

Чем **менее специфичный** селектор, тем быстрее браузер может применить правило. Например, один класс `.foo` обрабатывается быстрее, чем комбинация `.bar .foo`: в первом случае по сути одна операция «найти по классу», во втором — найти все `.foo`, потом подниматься по дереву в поисках родителя `.bar`. На собеседовании можно сказать: «Менее специфичные селекторы работают быстрее.»

---

## 3. JavaScript — блокировка парсера

### Что происходит

Когда парсер доходит до тега `<script>` (встроенного или внешнего), он **останавливает разбор HTML**:
- если скрипт внешний — запрашивает файл, ждёт, выполняет;
- если встроенный — сразу выполняет.

Только после выполнения скрипта парсер продолжает строить DOM. Причина: JS может менять DOM (например, `document.write`, добавление/удаление узлов), поэтому браузер не может «убежать вперёд» с парсингом.

### Отличие от CSS

| Ресурс | Что блокирует |
|--------|----------------|
| **CSS** | Рендер (рисование). Парсер HTML может продолжать работу. |
| **JavaScript** | Парсер HTML. Пока скрипт не выполнится, DOM дальше не строится. |

Кроме того, JS может обращаться к стилям (DOM и CSSOM), поэтому логично выполнять скрипты **после** того, как CSSOM готов. Обычно скрипты ставят в **конце `<body>`**, чтобы:
1. не блокировать парсинг основной разметки;
2. к моменту выполнения скрипта все нужные узлы DOM уже были в дереве;
3. CSSOM к этому моменту уже построен.

### Async и Defer

Скрипты, которые **не меняют DOM/CSSOM** при загрузке (аналитика, виджеты), лучше подключать **асинхронно**:
- **async** — скрипт качается параллельно, как загрузился — выполняется (парсер при этом останавливается на время выполнения).
- **defer** — скрипт качается параллельно, выполняется после разбора HTML, по порядку скриптов.

Так уменьшается блокировка парсера и укорачивается CRP.

---

## 4. Render Tree — дерево рендера

### Что происходит

Когда DOM и CSSOM готовы, браузер объединяет их в **Render Tree (дерево рендера)** — дерево только тех узлов, которые **реально отображаются** на странице.

- В **DOM** есть всё: и `<head>`, и скрытые элементы, и `display: none`.
- В **Render Tree** попадают только видимые узлы: без `<head>`, без элементов с `display: none` и без их потомков.

Таким образом, Render Tree — это «что и в каком виде рисовать», без лишних для отображения узлов.

---

## 5. Layout (компоновка, reflow)

### Что происходит

**Layout** — этап, на котором браузер для каждого элемента из Render Tree вычисляет:
- **размеры** (width, height, padding, border);
- **позицию** на странице (координаты, отступы от других элементов).

Учитываются свойства вроде width, height, margin, padding, border, position, top, left и т.д.

### Когда запускается заново (reflow)

Layout перезапускается (происходит **reflow**), когда меняется что-то, что влияет на размеры или позиции:
- изменение DOM (добавление/удаление узлов, текст);
- изменение стилей блочной модели (width, height, margin, padding, border и т.д.);
- изменение размеров окна браузера или ориентации устройства;
- обращение к «layout-свойствам» из JS (offsetWidth, scrollHeight и т.д.) может заставить браузер пересчитать layout синхронно.

### Влияние на производительность

- **Чем больше узлов в DOM**, тем дольше пересчёт позиций и размеров.
- Layout выполняется в **главном потоке**. Если он занимает много времени (особенно при скролле или анимации), кадры не успевают отрисоваться за ~16 ms → **подвисания, дёргания (jank)**.
- **Оптимизация:** меньше лишних узлов; по возможности не анимировать свойства, влияющие на layout (width, height, margin и т.д.); группировать чтение/запись DOM и стилей, чтобы не вызывать лишние reflow подряд.

---

## 6. Paint (отрисовка, repaint)

### Что происходит

После layout браузер знает, **где** и **какого размера** каждый элемент. На этапе **Paint** он рисует пиксели: цвет, фон, тени, границы и т.д.

Браузер старается перерисовывать только **изменившиеся области** (repaint), а не всю страницу — так экономится время.

### Что влияет на время отрисовки

- Каждое **CSS-свойство**, применяемое к узлу (цвет, тень, граница и т.д.), добавляет работу при отрисовке.
- Сама по себе отрисовка быстрая, но вместе с layout она должна укладываться в бюджет одного кадра (~16 ms при 60 FPS). **Reflow и repaint** — самые дорогие этапы CRP, особенно на слабых устройствах.

### Слои (layers)

Обычно отрисовка идёт в **одном потоке** (main thread). Но браузер может создавать отдельные **слои** (например, для элементов с `transform`, `opacity`, `will-change`, для видео, canvas, для `position: fixed` или определённых случаев с z-index). Каждый слой рисуется отдельно, потом объединяется. Это помогает:
- не перерисовывать всю страницу при анимации одного элемента;
- эффективнее использовать GPU.

**Минус:** много слоёв = больше потребление памяти. Слои стоит создавать только там, где это реально нужно (анимации, фиксированные блоки и т.д.).

---

## 7. Composite — объединение слоёв и вывод на экран

### Что происходит

Когда все нужные слои отрисованы, браузер:
1. **Объединяет их** в один кадр в правильном порядке (z-index, наложение).
2. Передаёт результат на **GPU**.
3. **GPU выводит** итоговое изображение на экран.

Этот этап называется **composite** (композитинг слоёв). Он завершает CRP для одного кадра.

---

## Бюджет кадра (60 FPS)

Большинство экранов обновляются **60 раз в секунду** (60 Hz). На один кадр отводится примерно **16 ms** (1000 / 60). Часть этого времени браузер тратит на свои задачи (JS, события и т.д.), на рендер обычно остаётся около **10 ms**.

Если layout + paint + composite занимают больше этого времени, кадр не успевает — **частота кадров падает**, на экране появляются **дёргания, подвисания (jank)**. Поэтому при оптимизации CRP цель — уложиться в бюджет кадра и по возможности реже вызывать reflow и repaint.

---

## Сводка: DOM vs CSSOM vs Render Tree

| Модель | Что содержит | Инкрементальная? |
|--------|----------------|------------------|
| **DOM** | Все узлы из HTML | Да, строится по мере поступления HTML |
| **CSSOM** | Все стили из CSS, наследование | Нет, ждёт все правила |
| **Render Tree** | Только видимые узлы (без display:none и т.п.) | — |

---

## Оптимизация CRP (кратко)

| Что делать | Зачем |
|------------|--------|
| Уменьшать количество критических ресурсов | Меньше блокировок, короче путь до первого кадра |
| Подключать скрипты с **async/defer** или в конце `<body>` | Не блокировать парсер HTML |
| Использовать **preload** для критичного CSS/JS | Раньше начать загрузку важных файлов |
| Минификация, конкатенация, сжатие (gzip/brotli) | Меньше объём и время загрузки |
| **CDN** для статики | Быстрее доставка до пользователя |
| Менее специфичные селекторы | Быстрее построение и применение стилей |
| Меньше узлов DOM, проще структура | Быстрее layout и paint |
| Не анимировать свойства блочной модели (width, margin и т.д.) | Меньше reflow; предпочтительно transform/opacity |
| Не злоупотреблять слоями (will-change, transform и т.д.) | Меньше потребление памяти |

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Что такое CRP? | Последовательность шагов браузера от HTML/CSS/JS до пикселей на экране: DOM → CSSOM → JS → Render Tree → Layout → Paint → Composite. |
| Какие этапы входят в CRP? | Построение DOM, построение CSSOM, выполнение JS, построение Render Tree, Layout (reflow), Paint (repaint), Composite. |
| Чем блокирует CSS и чем — JavaScript? | CSS блокирует **рендер** (рисование). JavaScript блокирует **парсер** HTML. |
| Почему CSSOM не инкрементальный? | Следующие правила могут переопределять предыдущие (например, скрыть элемент). Браузер ждёт все правила, чтобы построить корректное дерево для рендера. |
| В чём разница DOM и Render Tree? | DOM содержит все узлы из HTML. Render Tree — только видимые (без head, без display:none и их потомков). |
| Что такое reflow и repaint? | Reflow — пересчёт размеров и позиций (layout). Repaint — перерисовка пикселей. Обе операции дорогие, их минимизируют. |
| Как оптимизировать CRP? | Меньше критических ресурсов, async/defer для скриптов, preload критичного, минификация, CDN, меньше узлов DOM, не анимировать свойства блочной модели. |

---

## Кратко для ответа

**CRP** — путь от HTML/CSS/JS до картинки на экране: **DOM** (инкрементально) → **CSSOM** (блокирует рендер, не инкрементально) → **JS** (блокирует парсер) → **Render Tree** (только видимое) → **Layout** (reflow) → **Paint** (repaint) → **Composite**. CSS блокирует рендер, JS — парсер. Reflow и repaint дорогие; оптимизация: меньше узлов, меньше блокировок, async/defer, preload, минификация, CDN, не анимировать свойства блочной модели.
