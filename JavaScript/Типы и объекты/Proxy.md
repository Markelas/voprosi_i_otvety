# Proxy

## Что такое Proxy

**Proxy** (прокси-объект) — это объект-обёртка над другим объектом (целью). Он не хранит свои данные, а **перехватывает операции** над целевым объектом: чтение и запись свойств, вызов функций, проверку наличия ключа и т.д. Вместо стандартного поведения можно задать своё — через **ловушки (traps)**.

Идея: вы работаете с объектом как обычно (читаете и пишете свойства), но между вами и реальным объектом стоит прокси, который решает, что именно выполнить при каждой операции.

---

## Зачем нужен Proxy

- **Контроль доступа** — проверять или подменять значения при чтении/записи (валидация, логирование, значения по умолчанию).
- **Ленивые вычисления** — вычислять свойство только при первом обращении, а не при создании объекта.
- **Виртуальные свойства** — свойства, которых нет в объекте, но прокси их «придумывает» (например, по формуле или из другого источника).
- **Защита и инварианты** — запрещать удаление или изменение определённых полей, скрывать часть структуры.
- **Реактивность** — при изменении данных автоматически запускать обновление UI, кэша или подписчиков (как во Vue 3).

Без Proxy пришлось бы везде писать геттеры/сеттеры вручную или менять структуру данных; Proxy даёт единую точку перехвата для любого объекта.

---

## Ловушки (traps)

Прокси настраивается объектом-обработчиком (handler). В нём задаются функции-ловушки для разных операций:

| Операция | Ловушка | Когда вызывается |
|----------|---------|------------------|
| Чтение свойства | `get` | `obj.key` или `obj[key]` |
| Запись свойства | `set` | `obj.key = value` |
| Проверка ключа | `has` | `key in obj` |
| Удаление | `deleteProperty` | `delete obj.key` |
| Перечисление | `ownKeys` | `Object.keys(obj)` и т.п. |
| Вызов функции | `apply` | если цель — функция |

И другие: `getPrototypeOf`, `setPrototypeOf`, `getOwnPropertyDescriptor`, `defineProperty`, `construct` (для `new`) и т.д. Если ловушка не указана, выполняется стандартное действие над целевым объектом.

Суть: любое «общение» с объектом можно перехватить и обработать по-своему.

---

## Связь с Vue (реактивность)

Во **Vue 3** реактивность построена на **Proxy**. Раньше (Vue 2) использовался `Object.defineProperty` для перехвата доступа к полям — у него ограничения: нельзя перехватить добавление/удаление свойств и работу с массивами по индексу так же удобно. Proxy перехватывает любые обращения к объекту.

Как это используется во Vue:

- Объект данных компонента оборачивается в Proxy.
- При **чтении** свойства Vue запоминает, что этот эффект (например, рендер или `computed`) зависит от данного поля.
- При **записи** свойства Vue помечает зависимые эффекты как «грязные» и при необходимости заново их перезапускает (обновляет DOM, пересчитывает `computed` и т.д.).

То есть Proxy даёт возможность автоматически отслеживать, что изменилось, и реагировать на это — без явного вызова «обнови вид» или ручного списка подписчиков на каждое поле. Это и есть основа реактивности во Vue 3.

---

## Важные моменты

- **Прозрачность** — снаружи с прокси работают как с обычным объектом; код не обязан знать, что внутри Proxy.
- **Целевой объект** — реальные данные лежат в цели (target); прокси только перехватывает операции. Можно передавать цель дальше или хранить отдельно.
- **Один прокси на объект** — идентичность: если несколько раз оборачивать один и тот же объект, лучше использовать один и тот же прокси, иначе можно нарушить ожидания кэша или сравнений (как в Vue — один реактивный объект на данные).
- **Производительность** — перехват каждой операции имеет небольшую цену; для «горячих» путей с тысячами обращений это может учитываться, но в типичных приложениях и в реактивных фреймворках это не проблема.

---

## Кратко для собеседования

- **Proxy** — объект-обёртка, перехватывающая операции над другим объектом (чтение, запись, удаление и т.д.) через ловушки в handler.
- **Зачем** — контроль доступа, валидация, виртуальные/ленивые свойства, защита данных, **реактивность** (отслеживание изменений и автоматическая реакция).
- **Во Vue 3** реактивность реализована на Proxy: при чтении поля запоминаются зависимости, при записи — обновляются эффекты (рендер, `computed`), поэтому UI остаётся согласованным с данными без ручного обновления.
