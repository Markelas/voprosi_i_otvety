# Event Loop (цикл событий)

## Краткий ответ для собеседования

**Event Loop** — механизм, который управляет **порядком выполнения кода** в JavaScript. JS выполняется в **одном потоке**: в один момент времени выполняется только одна задача. Event Loop следит за **стеком вызовов (Call Stack)** и **очередями задач**: когда стек пуст, он берёт задачи из очередей и «подкладывает» их в стек. Есть **микротаски** (Promise.then, queueMicrotask, MutationObserver) и **макротаски** (setTimeout, setInterval, I/O, события DOM). Правило: **сначала выполняется весь синхронный код из стека, затем все накопленные микротаски, затем одна макротаска** — и цикл повторяется. Так однопоточный JS может обрабатывать асинхронность без блокировки. На собеседовании: что такое Event Loop, зачем он, как связаны стек и очереди, чем микротаски отличаются от макротасок, почему порядок важен.

---

## Почему вообще нужен Event Loop

JavaScript **однопоточный**: в один момент времени выполняется только **один кусок кода**. Нельзя «параллельно» выполнять две функции в одном потоке. При этом нам нужны асинхронные вещи: таймеры, запросы к серверу, клики по кнопкам. Браузер (или Node.js) даёт **Web API** (или API окружения): они выполняются вне потока JS (другой поток или подсистема ОС). Когда асинхронная операция готова, её **колбэк** нужно как-то вернуть в поток JS и выполнить. Для этого и нужен **Event Loop**: он смотрит, свободен ли стек, и по очереди подкладывает в него готовые колбэки из **очередей задач**. Так мы получаем асинхронное поведение при одном потоке выполнения.

**Запомнить:** один поток — только одна задача в стеке. Event Loop решает, **какую задачу выполнить следующей**, когда стек опустел.

---

## Основные части: стек и очереди

### Call Stack (стек вызовов)

**Стек вызовов** — это где **выполняется** синхронный код. Каждый вызов функции кладётся в стек (кадр выполнения); когда функция завершилась — кадр снимается. Принцип **LIFO**: последний зашёл — первый вышел. Пока в стеке что-то есть, движок это выполняет; Event Loop **не** подкладывает новые задачи в стек, пока он не опустеет.

Синхронный код (вызовы функций, циклы, выражения) выполняется сразу и заполняет стек. Асинхронный код **не выполняется** в момент вызова — он передаётся в **окружение** (браузер, Node.js), а колбэк потом попадает в **очередь задач**.

### Очереди задач (Task Queues)

Когда асинхронная операция готова (таймер сработал, пришёл ответ с сервера, пользователь кликнул), колбэк попадает в одну из **очередей**:

- **Очередь микротасок (Microtask Queue)** — высокий приоритет. Примеры: колбэки **Promise.then / catch / finally**, **queueMicrotask()**, **MutationObserver**, в Node.js — **process.nextTick** (ещё выше микротасок).
- **Очередь макротасок (Macrotask Queue)** — сюда попадают колбэки **setTimeout**, **setInterval**, **setImmediate** (Node), обработчики **событий DOM** (click, load), **I/O**, **fetch** (колбэк then у fetch — микротаска, но сам «запуск» запроса — макротаска/обработка в окружении).

**Важно:** микротаски и макротаски — это не «одна общая очередь». Event Loop обрабатывает их по разным правилам: **сначала все микротаски**, потом **одна макротаска**, потом снова все микротаски и т.д.

---

## Как работает один «тик» Event Loop (пошагово)

Упрощённо один цикл выглядит так:

1. **Выполнить весь синхронный код** из стека (то, что уже там лежит). Стек опустел.
2. **Выполнить все микротаски** из очереди микротасок, пока она не станет пустой. Если во время выполнения микротаски добавляются новые микротаски — они тоже выполняются в этом же «тике» (микротаски выполняются до конца).
3. **Выполнить одну макротаску** (например, один колбэк setTimeout или один обработчик события). После неё снова шаг 2 — все микротаски, затем следующая макротаска.
4. При необходимости **отрисовка** (render) браузера — может происходить между макротасками (зависит от реализации и частоты кадров).
5. Цикл повторяется: снова микротаски (если есть), затем одна макротаска, и т.д.

**Запомнить:** «Сначала стек, потом все микротаски, потом одна макротаска» — и так по кругу. Поэтому `Promise.then` выполнится раньше, чем колбэк `setTimeout` с нулевой задержкой, если оба были запланированы до этого тика.

---

## Микротаски vs макротаски (таблица)

| Критерий | Микротаски | Макротаски |
|----------|------------|------------|
| **Когда выполняются** | Сразу после текущего кода (и после каждой макротаски), **все подряд** до опустошения очереди | По **одной** за цикл Event Loop, после всех текущих микротасок |
| **Примеры** | Promise.then, Promise.catch, Promise.finally, queueMicrotask(), MutationObserver | setTimeout, setInterval, setImmediate (Node), события DOM (click, load), I/O, fetch (как задача) |
| **Приоритет** | Выше: выполняются до следующей макротаски | Ниже: ждут, пока отработают все микротаски |

**Почему это важно:** если в коде подряд вызвать `setTimeout(fn, 0)` и `promise.then(...)`, то сначала выполнится колбэк **Promise** (микротаска), а потом колбэк **setTimeout** (макротаска). Порядок «микротаски → макротаски» нужно помнить для разбора порядка вывода в консоль и для понимания, когда обновится DOM после промисов.

---

## Кто за что отвечает: движок и окружение

- **JavaScript-движок** (V8, SpiderMonkey и т.д.) — выполняет код: парсит, компилирует, **выполняет то, что в Call Stack**. Он не знает про таймеры и сеть — только про стек.
- **Окружение** (браузер или Node.js) — предоставляет **Web API / Node API**: setTimeout, fetch, DOM-события, файловая система и т.д. Когда ты вызываешь `setTimeout(callback, 1000)`, движок регистрирует вызов и передаёт управление окружению. Окружение ведёт таймер; через секунду оно **кладёт колбэк в очередь макротасок**. **Event Loop** — это часть **окружения**, а не движка: он смотрит на стек и очереди и решает, какую задачу «впустить» в стек следующей.

**Запомнить:** движок выполняет код в стеке; окружение даёт таймеры, сеть, события и **Event Loop**, который подкладывает готовые колбэки в стек.

---

## Блокировка Event Loop

Пока в **Call Stack** выполняется тяжёлый **синхронный код** (долгий цикл, тяжёлые вычисления), стек не пустеет. Event Loop не может начать выполнять задачи из очередей — он ждёт опустошения стека. В результате интерфейс «зависает», таймеры и ответы от сервера не обрабатываются вовремя. Это и есть **блокировка Event Loop**.

**Что делать:** выносить тяжёлую работу из основного потока: **Web Workers**, разбиение на части с **setTimeout** или **requestAnimationFrame**, асинхронные API. Тогда между кусками работы стек будет пустеть и Event Loop успеет обработать микро- и макротаски (и отрисовку).

---

## Важные нюансы для собеседования

- **Создание промиса и вызов resolve/reject** — синхронные. А колбэки из **.then()** попадают в очередь **микротасок** и выполняются после текущего синхронного кода.
- **setTimeout(fn, 0)** не выполняет колбэк «сразу» — он ставит макротаску в очередь; колбэк выполнится после опустошения стека и **всех микротасок**.
- **async/await** — синтаксический сахар над промисами. Код после `await` выполняется как колбэк промиса, то есть как **микротаска** (в следующем тике по микротаскам).
- В **Node.js** есть **process.nextTick** — ещё выше микротасок: выполняется перед остальными микротасками в том же цикле.

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Что такое Event Loop? | Механизм, который управляет порядком выполнения: когда Call Stack пуст, подкладывает в него задачи из очередей (сначала микротаски, потом макротаски). Так однопоточный JS обрабатывает асинхронность. |
| Зачем нужен Event Loop? | JS однопоточный; асинхронные колбэки (таймеры, сеть, события) выполняются в окружении и возвращаются в очередь. Event Loop решает, какую задачу выполнить следующей, когда стек пуст. |
| Что такое Call Stack? | Стек вызовов — там выполняется синхронный код. Одна задача за раз; пока стек не пуст, Event Loop не подкладывает новые задачи. |
| Чем микротаски отличаются от макротасок? | Микротаски (Promise.then, queueMicrotask) выполняются все подряд сразу после текущего кода и после каждой макротаски. Макротаски (setTimeout, события) — по одной за цикл, после микротасок. |
| В каком порядке выполняются setTimeout и Promise.then? | Сначала весь синхронный код, потом все микротаски (в т.ч. колбэк Promise.then), потом одна макротаска (колбэк setTimeout). Поэтому then раньше setTimeout при одинаковом «моменте» постановки в очередь. |
| Кто такой Event Loop — движок или окружение? | Часть **окружения** (браузер, Node.js). Движок только выполняет код в стеке; окружение даёт API и Event Loop, который передаёт задачи из очередей в стек. |
| Что значит «блокировка Event Loop»? | Долгий синхронный код в стеке не даёт ему опустеть; Event Loop не может обработать очереди — таймеры, сеть, UI «зависают». Решение: выносить тяжёлое в воркеры или разбивать на части. |

---

## Кратко запомнить

- **Event Loop** — часть окружения; решает, какую задачу выполнить следующей, когда **Call Stack** пуст.
- **Стек** — выполняется синхронный код; **очереди** — колбэки асинхронных операций (микро- и макротаски).
- **Порядок:** стек → **все микротаски** → **одна макротаска** → снова все микротаски → следующая макротаска → …
- **Микротаски** — Promise.then, queueMicrotask, MutationObserver; **макротаски** — setTimeout, setInterval, события DOM, I/O.
- Долгий синхронный код **блокирует** Event Loop — стек не пустеет, очереди не обрабатываются. Тяжёлое — в воркеры или разбивать на части.
