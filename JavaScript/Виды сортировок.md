# Основные виды сортировок

## Краткий ответ для собеседования

Основные сортировки: **Bubble Sort** (пузырьковая, O(n²), простая, неэффективная), **Selection Sort** (выбором, O(n²)), **Insertion Sort** (вставками, O(n²), хороша для почти отсортированных), **Merge Sort** (слиянием, O(n log n), стабильная), **Quick Sort** (быстрая, O(n log n) в среднем, O(n²) в худшем, нестабильная, используется в V8 для `.sort()`), **Heap Sort** (O(n log n), нестабильная). Для собеседования важны Quick Sort и Merge Sort.

---

## 1. Bubble Sort (Пузырьковая)

### Принцип

Сравниваем соседние элементы и **меняем местами**, если они в неправильном порядке. Проходим массив несколько раз, пока всё не отсортируется.

### Сложность

- **Лучший случай:** O(n) — если массив уже отсортирован
- **Средний и худший:** O(n²)

### Когда использовать

Почти никогда (очень медленная); только для обучения.

---

## 2. Selection Sort (Сортировка выбором)

### Принцип

На каждой итерации находим **минимальный элемент** в неотсортированной части и ставим его в начало.

### Сложность

- **Всегда:** O(n²)

### Когда использовать

Редко (медленная); проще реализовать, чем Bubble Sort.

---

## 3. Insertion Sort (Сортировка вставками)

### Принцип

Берём элемент и **вставляем его** в правильное место в отсортированной части массива.

### Сложность

- **Лучший случай:** O(n) — если массив уже отсортирован
- **Средний и худший:** O(n²)

### Когда использовать

- **Небольшие массивы** (быстрее Quick Sort на малых данных)
- **Почти отсортированные массивы** (очень эффективна)
- Используется в гибридных сортировках (Timsort, Introsort)

---

## 4. Merge Sort (Сортировка слиянием)

### Принцип

**Divide and Conquer** (разделяй и властвуй):
1. Делим массив пополам
2. Рекурсивно сортируем каждую половину
3. Сливаем две отсортированные половины

### Сложность

- **Всегда:** O(n log n)

### Особенности

- **Стабильная** — сохраняет порядок равных элементов
- **Требует дополнительную память** — O(n)

### Когда использовать

- Когда важна стабильность
- Когда нужна гарантированная O(n log n)
- Большие массивы

---

## 5. Quick Sort (Быстрая сортировка)

### Принцип

**Divide and Conquer:**
1. Выбираем **pivot** (опорный элемент)
2. Разделяем массив: элементы < pivot влево, > pivot вправо
3. Рекурсивно сортируем левую и правую части

### Сложность

- **Лучший и средний:** O(n log n)
- **Худший:** O(n²) — если pivot всегда минимальный/максимальный (плохо отсортированный массив)

### Особенности

- **Нестабильная**
- **In-place** — не требует дополнительной памяти (O(log n) для стека рекурсии)
- **Быстрая на практике**

### Когда использовать

- **Большие массивы**
- **Средние/случайные данные**
- Используется в V8 (JavaScript) для `Array.sort()` (Timsort, гибрид Quick Sort + Insertion Sort)

---

## 6. Heap Sort (Пирамидальная)

### Принцип

Используем структуру данных **heap** (куча):
1. Строим max-heap из массива
2. Извлекаем максимальный элемент (корень) и ставим в конец
3. Восстанавливаем heap, повторяем

### Сложность

- **Всегда:** O(n log n)

### Особенности

- **Нестабильная**
- **In-place** — O(1) дополнительной памяти

### Когда использовать

- Когда важна предсказуемая O(n log n) без дополнительной памяти

---

## 7. Counting Sort (Сортировка подсчётом)

### Принцип

Подсчитываем количество каждого элемента, затем восстанавливаем отсортированный массив.

### Сложность

- **O(n + k)**, где k — диапазон значений

### Когда использовать

- **Небольшой диапазон значений** (например, 0-100)
- Целые числа

---

## 8. Radix Sort (Поразрядная)

### Принцип

Сортируем числа **по разрядам** (от младшего к старшему).

### Сложность

- **O(n \* k)**, где k — количество разрядов

### Когда использовать

- Целые числа с фиксированным количеством разрядов

---

## Сравнение

| Сортировка | Лучший | Средний | Худший | Память | Стабильная | Использование |
|------------|--------|---------|--------|--------|------------|---------------|
| **Bubble** | O(n) | O(n²) | O(n²) | O(1) | ✅ | Обучение |
| **Selection** | O(n²) | O(n²) | O(n²) | O(1) | ❌ | Редко |
| **Insertion** | O(n) | O(n²) | O(n²) | O(1) | ✅ | Малые/почти отсортированные |
| **Merge** | O(n log n) | O(n log n) | O(n log n) | O(n) | ✅ | Стабильность важна |
| **Quick** | O(n log n) | O(n log n) | O(n²) | O(log n) | ❌ | Большие массивы |
| **Heap** | O(n log n) | O(n log n) | O(n log n) | O(1) | ❌ | Гарантированная O(n log n) |
| **Counting** | O(n+k) | O(n+k) | O(n+k) | O(k) | ✅ | Малый диапазон |
| **Radix** | O(n\*k) | O(n\*k) | O(n\*k) | O(n+k) | ✅ | Целые числа |

---

## Что используется в JavaScript

### `Array.sort()`

В V8 (Chrome, Node.js) используется **Timsort** — гибридная сортировка:
- Основа: **Merge Sort** (стабильная, O(n log n))
- Оптимизация: **Insertion Sort** для малых подмассивов
- Адаптивная: использует уже отсортированные участки

**Сложность:** O(n log n) гарантированно.

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Самая простая сортировка? | Bubble Sort (O(n²)), но медленная |
| Самая быстрая сортировка? | Quick Sort в среднем O(n log n), Merge Sort гарантированно O(n log n) |
| В чём разница Quick Sort и Merge Sort? | Quick in-place, нестабильная, O(n²) в худшем; Merge стабильная, O(n log n) всегда, требует памяти |
| Какая сортировка в JS? | Timsort (гибрид Merge + Insertion), O(n log n), стабильная |
| Когда использовать Insertion Sort? | Малые массивы, почти отсортированные данные |
| Что такое стабильная сортировка? | Сохраняет порядок равных элементов |

---

## Кратко для ответа

Основные: **Bubble** (O(n²), простая, медленная), **Insertion** (O(n²), хороша для малых/почти отсортированных), **Merge** (O(n log n), стабильная, требует память), **Quick** (O(n log n) в среднем, нестабильная, in-place, используется в практике), **Heap** (O(n log n), нестабильная, in-place). JavaScript использует **Timsort** (гибрид Merge + Insertion, стабильная, O(n log n)).
