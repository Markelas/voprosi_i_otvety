# Next.js

## Краткий ответ для собеседования

**Next.js** — фреймворк для React с встроенным SSR, SSG, ISR, роутингом, API routes. Главные отличия от обычного React: серверный рендеринг из коробки, файловый роутинг, автоматический code splitting, оптимизация изображений. Две среды исполнения: сервер (Node.js) и клиент (браузер). Кэширование: агрессивное по умолчанию, инвалидация через `revalidate`, `revalidatePath`, `revalidateTag`. SSR нужен для первой загрузки (SEO, FCP), дальше работает как SPA.

---

## Что такое Next.js

**Next.js** — React-фреймворк от Vercel для создания **Production-ready** приложений с:
- **SSR, SSG, ISR** — разные стратегии рендеринга
- **Роутинг** — файловый роутинг (file-based routing)
- **API Routes** — бэкенд на том же сервере
- **Оптимизации** — автоматический code splitting, оптимизация изображений, шрифтов
- **TypeScript** — поддержка из коробки

---

## Отличия от обычного React (CRA, Vite)

| Параметр | React (CRA/Vite) | Next.js |
|----------|------------------|---------|
| **Рендеринг** | Только CSR | SSR, SSG, ISR, CSR |
| **Роутинг** | Нужна библиотека (React Router) | Встроенный файловый роутинг |
| **SEO** | Плохое (пустой HTML) | Отличное (готовый HTML) |
| **Code Splitting** | Вручную (`React.lazy`) | Автоматически (по роутам) |
| **API** | Нужен отдельный бэкенд | API Routes (бэкенд в Next.js) |
| **Оптимизация** | Вручную | Автоматически (изображения, шрифты) |
| **Конфигурация** | Больше настроек | Convention over configuration |

---

## Две среды исполнения

Next.js работает в **двух средах**:

### 1. Серверная среда (Node.js)

**Где:**
- SSR — рендеринг на каждый запрос
- SSG/ISR — генерация HTML при сборке/регенерации
- API Routes — обработка запросов
- Middleware — обработка запросов до роутинга

**Что доступно:**
- Node.js API (`fs`, `path`, `http`)
- Переменные окружения сервера (секреты, ключи API)
- Базы данных, файловая система

**Что НЕ доступно:**
- `window`, `document` — нет браузерных API
- `localStorage`, `sessionStorage`

### 2. Клиентская среда (браузер)

**Где:**
- После гидрации — React работает как обычная SPA
- Client Components (с `'use client'`)
- Интерактивность, обработчики событий

**Что доступно:**
- Браузерные API (`window`, `document`, `localStorage`)
- Event handlers (`onClick`, `onChange`)

**Что НЕ доступно:**
- Node.js API
- Секретные переменные окружения

**Важно:**  
Код, написанный для сервера, **не попадёт** в клиентский бандл (и наоборот).

---

## Как работает Next.js

### 1. Первая загрузка (SSR)

1. **Пользователь заходит на `/about`**
2. **Next.js рендерит страницу на сервере** (SSR или SSG)
3. **Отправляет HTML** — пользователь видит контент сразу (FCP)
4. **Загружается JS** — браузер загружает React-код
5. **Гидрация** — React "оживляет" HTML, добавляет обработчики

**Результат:** быстрая первая загрузка + SEO.

### 2. Последующая навигация (CSR)

После гидрации Next.js работает как **SPA**:
- Переходы между страницами **без перезагрузки**
- Данные подгружаются через API (fetch)
- Плавная навигация, как в обычном React

**Вывод:**  
SSR нужен только для **первой загрузки**, дальше — обычная SPA.

---

## Роутинг в Next.js

### Файловый роутинг (File-based Routing)

**Структура папок = структура URL:**

```
app/
  page.tsx         → /
  about/
    page.tsx       → /about
  blog/
    [id]/
      page.tsx     → /blog/123 (динамический)
```

**Преимущества:**
- Не нужен React Router
- Автоматический code splitting по роутам
- Понятная структура

### Динамические роуты

```tsx
// app/blog/[id]/page.tsx
export default function BlogPost({ params }: { params: { id: string } }) {
  return <div>Post ID: {params.id}</div>;
}
```

URL `/blog/123` → `params.id = "123"`.

---

## Кэширование в Next.js

Next.js **агрессивно кэширует** данные для производительности.

### Типы кэшей

1. **Request Memoization** — дедупликация одинаковых fetch-запросов в одном рендере
2. **Data Cache** — кэш результатов fetch (бессрочно по умолчанию)
3. **Full Route Cache** — кэш отрендеренных страниц (для SSG/ISR)
4. **Router Cache** — кэш страниц на клиенте (в памяти браузера)

### Настройка кэширования fetch

```tsx
// Без кэша
fetch(url, { cache: 'no-store' });

// Кэш с revalidate (обновление через 60 сек)
fetch(url, { next: { revalidate: 60 } });

// Кэш навсегда (по умолчанию)
fetch(url); // или { cache: 'force-cache' }
```

---

## Инвалидация кэшей

### 1. Ручная инвалидация (On-demand Revalidation)

**По пути:**

```ts
import { revalidatePath } from 'next/cache';

// В Server Action или API Route
revalidatePath('/blog'); // сбросит кэш страницы /blog
```

**По тегу:**

```ts
// Пометить запрос тегом
fetch(url, { next: { tags: ['posts'] } });

// Сбросить все запросы с тегом
import { revalidateTag } from 'next/cache';
revalidateTag('posts');
```

### 2. Автоматическая инвалидация (Time-based)

```tsx
export const revalidate = 60; // страница обновляется каждые 60 сек (ISR)
```

### 3. Полный сброс кэша

- **Пересборка** — `npm run build` сбрасывает всё
- **Рестарт сервера** (в dev-режиме кэш не такой агрессивный)

---

## Как сбросить кэш (практика)

**Во время разработки:**
- Перезапустить dev-сервер
- Очистить `.next` папку: `rm -rf .next`

**В продакшене:**
- Вызвать `revalidatePath('/page')` через API Route
- Вызвать `revalidateTag('tag')` после обновления данных
- Пересобрать приложение (`npm run build`)

---

## SSR в Next.js: зачем и как работает

### Зачем нужен SSR

1. **SEO** — поисковики получают готовый HTML с контентом
2. **Быстрая первая загрузка (FCP)** — пользователь видит контент сразу
3. **Работа без JS** — контент виден, даже если JS не загрузился

### Как работает после первой загрузки

**SSR только для первой страницы**, дальше Next.js работает как **SPA**:
- Переходы между страницами — через client-side routing (без перезагрузки)
- Данные подгружаются через fetch/API
- React управляет DOM

**Пример:**
1. Пользователь заходит на `/` — **SSR**, получает HTML
2. Кликает на `/about` — **CSR**, данные загружаются через fetch, переход мгновенный

---

## App Router vs Pages Router

Next.js 13+ представил **App Router** (новый способ).

| Параметр | Pages Router (старый) | App Router (новый) |
|----------|-----------------------|--------------------|
| **Структура** | `pages/` | `app/` |
| **Компоненты** | Все клиентские | По умолчанию серверные |
| **Layouts** | Через HOC | Встроенные `layout.tsx` |
| **Data Fetching** | `getServerSideProps`, `getStaticProps` | `async` компоненты |
| **Streaming** | Нет | Да (React Suspense) |

**Рекомендация:** новые проекты на **App Router**.

---

## Server Components и Client Components

### Server Components (по умолчанию)

**Где выполняются:** только на сервере.

**Преимущества:**
- Нет в клиентском бандле → меньше JS
- Доступ к серверным API (БД, файловая система)
- Безопасность (секреты не утекают)

**Ограничения:**
- Нельзя использовать `useState`, `useEffect`, обработчики событий

### Client Components (`'use client'`)

**Где выполняются:** на сервере (SSR) + клиенте (CSR).

```tsx
'use client'; // директива вверху файла

import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
```

**Когда использовать:**
- Интерактивность (`useState`, `onClick`)
- Браузерные API (`localStorage`, `window`)
- Хуки React (`useEffect`, `useContext`)

---

## Оптимизации в Next.js

### 1. Автоматический Code Splitting

Каждая страница — отдельный chunk. Загружается только нужный код.

### 2. Оптимизация изображений

```tsx
import Image from 'next/image';

<Image src="/photo.jpg" width={500} height={300} alt="Photo" />
```

**Что делает:**
- Автоматический ресайз
- Ленивая загрузка
- Конвертация в WebP/AVIF
- Оптимизация размера

### 3. Оптимизация шрифтов

```tsx
import { Inter } from 'next/font/google';

const inter = Inter({ subsets: ['latin'] });

export default function Layout({ children }) {
  return <body className={inter.className}>{children}</body>;
}
```

**Что делает:**
- Загружает шрифты с CDN
- Устраняет мигание (FOIT/FOUT)
- Оптимизирует размер

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Что такое Next.js? | React-фреймворк с SSR, SSG, ISR, файловым роутингом, оптимизациями |
| В чём отличие от обычного React? | SSR из коробки, файловый роутинг, автоматический code splitting, API routes |
| Что такое две среды исполнения? | Сервер (Node.js) и клиент (браузер); код выполняется в разных окружениях |
| Как работает SSR в Next.js? | Первая загрузка — SSR (HTML с сервера), дальше — SPA (CSR) |
| Зачем SSR, если дальше SPA? | Для SEO и быстрой первой загрузки (FCP) |
| Что такое гидрация? | "Оживление" HTML в браузере — React добавляет обработчики событий |
| Как работает кэширование? | Агрессивное по умолчанию; fetch, страницы, роуты кэшируются |
| Как инвалидировать кэш? | `revalidatePath`, `revalidateTag`, `revalidate` в fetch, пересборка |
| Что такое Server Components? | Компоненты, которые выполняются только на сервере, не попадают в бандл |
| Что такое Client Components? | Компоненты с `'use client'`, выполняются на сервере (SSR) + клиенте (CSR) |

---

## Кратко для ответа

Next.js — React-фреймворк с SSR, SSG, ISR, файловым роутингом, API routes. Отличия от React: серверный рендеринг, автоматический code splitting, оптимизации. Две среды: сервер (Node.js) и клиент (браузер). Кэширование агрессивное, инвалидация через `revalidatePath`, `revalidateTag`. SSR для первой загрузки (SEO, FCP), дальше — SPA. Server Components выполняются только на сервере, Client Components (`'use client'`) — на сервере и клиенте.
