# Module Federation

## Краткий ответ для собеседования

**Module Federation** (Webpack 5) — технология для динамической загрузки модулей из разных приложений в runtime. Позволяет создавать микрофронтенды: каждое приложение — независимое, но может **экспортировать** модули (компоненты) и **импортировать** из других. Общие зависимости (React) переиспользуются. Преимущества: независимый деплой, технологическая свобода, переиспользование. Недостатки: привязка к Webpack, сложность настройки, версионирование зависимостей.

---

## Что такое Module Federation

**Module Federation** — plugin в Webpack 5, который позволяет **динамически загружать JavaScript-модули из других приложений** во время выполнения (runtime).

**Основная идея:**  
Вместо сборки всего кода в один бандл, разные приложения могут **делиться модулями** между собой через сеть.

---

## Ключевые концепции

### 1. Host (Хост)

**Приложение, которое загружает модули** из других приложений (Remote).

### 2. Remote (Удалённое приложение)

**Приложение, которое экспортирует модули** для использования другими приложениями.

### 3. Shared (Общие зависимости)

**Зависимости, переиспользуемые** между приложениями (например, React) — загружаются один раз, используются всеми.

---

## Как работает

### Пример: два приложения

**App1 (Host):**
- Основное приложение
- Импортирует компонент `Button` из App2

**App2 (Remote):**
- Экспортирует компонент `Button`

---

### Конфигурация App2 (Remote)

```js
// webpack.config.js (App2)
const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'app2',
      filename: 'remoteEntry.js',
      exposes: {
        './Button': './src/Button' // экспорт компонента
      },
      shared: ['react', 'react-dom'] // общие зависимости
    })
  ]
};
```

---

### Конфигурация App1 (Host)

```js
// webpack.config.js (App1)
const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'app1',
      remotes: {
        app2: 'app2@http://localhost:3002/remoteEntry.js' // подключение Remote
      },
      shared: ['react', 'react-dom']
    })
  ]
};
```

---

### Использование в App1

```jsx
import React from 'react';

// Динамический импорт из App2
const RemoteButton = React.lazy(() => import('app2/Button'));

function App() {
  return (
    <div>
      <h1>App1</h1>
      <React.Suspense fallback="Loading Button...">
        <RemoteButton />
      </React.Suspense>
    </div>
  );
}
```

---

## Преимущества

### 1. Независимый деплой

Каждое приложение деплоится отдельно — изменения в App2 не требуют пересборки App1.

### 2. Технологическая свобода

Разные приложения могут использовать разные версии библиотек (с осторожностью).

### 3. Переиспользование кода

Компоненты из одного приложения используются в других — нет дублирования.

### 4. Общие зависимости

React загружается один раз и переиспользуется — меньше бандл.

### 5. Ленивая загрузка

Модули загружаются по требованию — быстрее первая загрузка.

---

## Недостатки

### 1. Сложность настройки

Конфигурация Webpack может быть сложной, особенно с версионированием.

### 2. Привязка к Webpack

Module Federation работает только в Webpack 5 (есть экспериментальная поддержка в Vite, Rollup).

### 3. Версионирование зависимостей

Если App1 использует React 17, а App2 — React 18, могут быть конфликты.

**Решение:**  
Webpack пытается разрешить конфликты автоматически (загружает обе версии или выбирает совместимую).

### 4. Производительность

Дополнительные сетевые запросы для загрузки модулей → может быть медленнее монолита.

### 5. Отладка

Сложнее отлаживать — модули загружаются динамически, ошибки могут быть непонятными.

---

## Shared dependencies (Общие зависимости)

### Как работает

```js
shared: {
  react: {
    singleton: true, // только одна версия React
    requiredVersion: '^17.0.0' // требуемая версия
  }
}
```

**Webpack автоматически:**
- Проверяет версии React в App1 и App2
- Если совместимы — использует одну версию
- Если нет — загружает обе

---

## Bidirectional Hosts (Двунаправленные хосты)

**Приложения могут быть одновременно Host и Remote.**

**Пример:**
- App1 экспортирует `Header`, импортирует `Footer` из App2
- App2 экспортирует `Footer`, импортирует `Header` из App1

---

## Use Cases (Когда использовать)

### 1. Микрофронтенды

Разные команды работают над независимыми частями приложения.

### 2. Общие компоненты

UI-библиотека, доступная всем приложениям без дублирования.

### 3. Постепенная миграция

Старое приложение использует компоненты из нового (и наоборот).

### 4. A/B тестирование

Загрузка разных версий компонентов для экспериментов.

---

## Альтернативы

| Технология | Описание | Плюсы | Минусы |
|------------|----------|-------|--------|
| **Module Federation** | Webpack 5 | Мощный, общие зависимости | Только Webpack |
| **Single-SPA** | Фреймворк для микрофронтендов | Универсальный | Больше boilerplate |
| **iframe** | Изоляция через iframe | Простой | Плохая производительность, коммуникация |
| **Web Components** | Стандарт браузера | Нативный | Сложная интеграция с React |

---

## Пример полной настройки

### App1 (Host)

```js
new ModuleFederationPlugin({
  name: 'app1',
  remotes: {
    app2: 'app2@http://localhost:3002/remoteEntry.js'
  },
  shared: {
    react: { singleton: true, requiredVersion: '^17.0.0' },
    'react-dom': { singleton: true, requiredVersion: '^17.0.0' }
  }
})
```

### App2 (Remote)

```js
new ModuleFederationPlugin({
  name: 'app2',
  filename: 'remoteEntry.js',
  exposes: {
    './Button': './src/components/Button'
  },
  shared: {
    react: { singleton: true, requiredVersion: '^17.0.0' },
    'react-dom': { singleton: true, requiredVersion: '^17.0.0' }
  }
})
```

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Что такое Module Federation? | Webpack 5 технология для динамической загрузки модулей из разных приложений |
| Зачем нужен Module Federation? | Микрофронтенды, независимый деплой, переиспользование компонентов |
| Что такое Host и Remote? | Host — загружает модули, Remote — экспортирует модули |
| Как работают shared dependencies? | Общие зависимости (React) загружаются один раз, переиспользуются |
| Минусы Module Federation? | Привязка к Webpack, сложность настройки, версионирование |
| Альтернативы? | Single-SPA, iframe, Web Components |

---

## Кратко

Module Federation (Webpack 5) — динамическая загрузка модулей из разных приложений в runtime. Host импортирует модули из Remote, общие зависимости (React) переиспользуются. Преимущества: независимый деплой, переиспользование, технологическая свобода. Недостатки: только Webpack, сложность, версионирование.
