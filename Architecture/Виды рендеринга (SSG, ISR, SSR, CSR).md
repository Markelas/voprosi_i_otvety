# Виды рендеринга (SSG, ISR, SSR, CSR)

## Краткий ответ для собеседования

**CSR** (Client-Side Rendering) — рендеринг на клиенте (браузере), быстрая навигация, но медленная первая загрузка и плохое SEO. **SSR** (Server-Side Rendering) — рендеринг на сервере для каждого запроса, быстрая первая загрузка, хорошее SEO, но нагрузка на сервер. **SSG** (Static Site Generation) — генерация HTML на этапе сборки, моментальная загрузка, но данные статичны. **ISR** (Incremental Static Regeneration) — статика + регенерация по требованию или по времени, баланс между SSG и SSR. **Гидрация** — «оживление» уже отрисованного HTML на клиенте: React подключает обработчики событий к существующим узлам DOM. **RSC** (React Server Components) — компоненты, выполняющиеся только на сервере; их код не попадает в клиентский бандл, клиент получает готовый результат.

---

## CSR — Client-Side Rendering

### Что это

**Рендеринг на стороне клиента** — браузер получает пустой HTML + JavaScript, затем JavaScript строит DOM и рендерит страницу.

### Как работает

1. Сервер отдаёт минимальный HTML (почти пустой):

```html
<div id="root"></div>
<script src="bundle.js"></script>
```

2. Браузер загружает и выполняет JavaScript
3. JavaScript рендерит компоненты и вставляет в DOM
4. Пользователь видит страницу

### Преимущества

- **Быстрая навигация** — после загрузки JS переходы мгновенные (SPA)
- **Интерактивность** — всё на клиенте, богатый UX
- **Простая инфраструктура** — не нужен сервер рендеринга, статика на CDN

### Недостатки

- **Медленная первая загрузка (FCP)** — нужно загрузить и выполнить JS
- **Плохое SEO** — поисковики видят пустой HTML (хотя Google индексирует JS, но медленнее)
- **Проблемы на слабых устройствах** — тяжёлый JS долго выполняется

### Когда использовать

- **SPA (Single Page Applications)** — админки, дашборды, личные кабинеты
- **SEO не важен** — внутренние инструменты, приложения за авторизацией
- **Много интерактивности** — сложные интерфейсы, реал-тайм обновления

**Примеры:** Create React App (CRA), Vite (по умолчанию).

---

## SSR — Server-Side Rendering

### Что это

**Рендеринг на стороне сервера** — сервер рендерит HTML для каждого запроса, отправляет готовую страницу браузеру.

### Как работает

1. **Запрос приходит на сервер** — пользователь заходит на `/page`
2. **Сервер рендерит React** — выполняет `renderToString()`, получает HTML
3. **Сервер отдаёт HTML** — браузер сразу видит контент
4. **Гидрация (Hydration)** — JS загружается, React "оживляет" HTML (добавляет обработчики событий)

### Преимущества

- **Быстрая первая загрузка (FCP)** — пользователь сразу видит контент
- **Хорошее SEO** — поисковики видят готовый HTML
- **Работает без JS** — контент виден, даже если JS не загрузился

### Недостатки

- **Нагрузка на сервер** — сервер рендерит на каждый запрос
- **Медленнее статики** — рендеринг занимает время (100-500ms)
- **TTFB (Time To First Byte)** — может быть высоким (сервер обрабатывает запрос)

### Когда использовать

- **Динамический контент** — данные меняются часто (новости, профили пользователей)
- **SEO важен** — блоги, интернет-магазины, маркетинговые сайты
- **Персонализация** — контент зависит от пользователя (авторизация, геолокация)

**Примеры:** Next.js (getServerSideProps), Remix.

---

## SSG — Static Site Generation

### Что это

**Генерация статических страниц** — HTML генерируется **на этапе сборки** (build time), затем хранится на CDN.

### Как работает

1. **Во время сборки** (`npm run build`) — генерируются все HTML-страницы
2. **Деплой на CDN** — готовые HTML-файлы
3. **Запрос пользователя** — CDN моментально отдаёт HTML

### Преимущества

- **Моментальная загрузка** — HTML уже готов, CDN рядом с пользователем
- **Отличное SEO** — готовый HTML, индексируется мгновенно
- **Масштабируемость** — нет нагрузки на сервер, CDN справляется с любым трафиком
- **Безопасность** — нет сервера — нет атак на сервер

### Недостатки

- **Статичные данные** — если данные изменились, нужно пересобрать сайт
- **Долгий билд** — для тысяч страниц сборка может занять минуты/часы
- **Не подходит для динамики** — нельзя показать контент, зависящий от пользователя

### Когда использовать

- **Статичный контент** — документация, блоги, лендинги, портфолио
- **Редко меняющиеся данные** — контент обновляется раз в день/неделю
- **Максимальная производительность** — нужна молниеносная загрузка

**Примеры:** Next.js (getStaticProps), Gatsby, Astro.

---

## ISR — Incremental Static Regeneration

### Что это

**Инкрементальная статическая регенерация** — гибрид SSG и SSR. Страницы генерируются статически, но **автоматически обновляются** по расписанию или по требованию.

### Как работает (Next.js)

```js
export async function getStaticProps() {
  const data = await fetch('...');
  return {
    props: { data },
    revalidate: 60 // пересоздать страницу через 60 секунд
  };
}
```

**Процесс:**
1. **Первый запрос** — отдаётся старая статическая версия
2. **В фоне** — регенерируется новая версия (если прошло > 60 сек)
3. **Следующий запрос** — получает обновлённую версию

### Преимущества

- **Скорость SSG** + **свежесть SSR** — страницы быстрые, но данные обновляются
- **Масштабируемость** — нет нагрузки на каждый запрос (регенерация в фоне)
- **Гибкость** — можно настроить интервал обновления

### Недостатки

- **Задержка обновлений** — пользователь может видеть старые данные (stale-while-revalidate)
- **Сложность** — нужно понимать, когда и как обновлять

### Когда использовать

- **Частично динамический контент** — блоги с комментариями, каталоги товаров
- **Баланс между скоростью и свежестью** — данные обновляются, но не на каждый запрос
- **Большие сайты** — тысячи страниц, не хочется пересобирать всё при изменении одной

**Примеры:** Next.js (getStaticProps + revalidate).

---

## Гидрация (Hydration)

### Что это

**Гидрация** — это процесс, когда React на клиенте «подключается» к уже отрисованному на сервере HTML и делает его интерактивным: навешивает обработчики событий (клики, ввод), подключает состояние и эффекты. Страница уже видна (HTML пришёл с сервера или из статики), но кнопки и формы ещё не реагируют; после гидрации они начинают работать как в обычном SPA.

Простыми словами: сервер отдал «мёртвый» HTML, браузер его показал; затем загружается JS React, который «оживляет» этот HTML — без перерисовки всего экрана, без замены узлов, а за счёт привязки к существующим DOM-элементам.

### Когда происходит

Гидрация нужна там, где сначала отдаётся готовый HTML (SSR или SSG), а потом на клиенте подключается тот же React-приложение. Цепочка: запрос → сервер отдаёт HTML → браузер рисует контент (FCP) → загружается JS-бандл → React выполняется и делает гидрацию → страница становится интерактивной (TTI).

### Зачем нужна

Без гидрации после SSR/SSG у пользователя был бы только статичный HTML: ссылки вели бы на новые загрузки страницы, формы отправлялись бы классическим способом, без клиентской логики. Гидрация даёт единую модель: один раз отрисовали на сервере для быстрого первого экрана и SEO, затем на клиенте тот же интерфейс получает поведение SPA (переходы без перезагрузки, валидация, состояние).

### Что делает React при гидрации

React сопоставляет дерево компонентов с уже существующим DOM (по разметке и данным, которые были вшиты в HTML при SSR). Он не пересоздаёт узлы заново, а «привязывается» к ним: запоминает соответствие «компонент — DOM-узел», подписывает обработчики, восстанавливает состояние там, где это нужно. Если разметка на клиенте не совпадает с серверной (например, разное время или разные данные), возможны предупреждения о несовпадении и визуальные артефакты — поэтому при SSR важно, чтобы первый рендер на сервере и первый рендер на клиенте давали один и тот же результат.

### Кратко про гидрацию

Гидрация — это «оживление» уже отрисованного HTML на клиенте: React подключает обработчики событий и логику к существующим узлам DOM, не перерисовывая страницу заново. Нужна после SSR и SSG, чтобы страница стала интерактивной без потери преимуществ быстрого первого отображения.

---

## RSC — React Server Components

### Что это

**React Server Components (RSC)** — это компоненты, которые выполняются **только на сервере**. Они не попадают в клиентский JS-бандл: сервер рендерит их в специальном формате (поток данных, а не готовый HTML в классическом виде), отправляет результат клиенту, а клиентский React «встраивает» этот результат в дерево без загрузки кода самих серверных компонентов. Серверные компоненты могут обращаться к БД, файловой системе, секретам — всё это остаётся на сервере.

**Client Components** (с директивой «use client» или по умолчанию в части фреймворков) — обычные компоненты: их код грузится в браузер, они выполняются на клиенте, могут использовать useState, обработчики событий, браузерные API. RSC и Client Components могут соседствовать: страница может быть собрана из серверных кусков и клиентских «островов» интерактивности.

### Чем RSC отличается от классического SSR

В классическом SSR сервер рендерит React в **HTML** (строку разметки) и отдаёт её. Клиент получает этот HTML, показывает его, затем загружает **тот же самый** набор компонентов в JS и делает гидрацию — то есть код всех компонентов есть и на сервере, и в бандле клиента.

В RSC сервер рендерит **серверные** компоненты в специальный формат (не обязательно готовый HTML; в Next.js App Router это поток RSC payload). Код серверных компонентов **не отправляется** на клиент. Клиент получает уже готовый результат (разметку и данные) и встраивает его в дерево; гидрация нужна только для клиентских компонентов. В итоге бандл может быть меньше: тяжёлые библиотеки и логика остаются только на сервере.

### Плюсы RSC

- **Меньший клиентский бандл** — код серверных компонентов и их зависимостей не грузится в браузер.
- **Прямой доступ к серверным ресурсам** — БД, файлы, секреты, без отдельного API-слоя для этих компонентов.
- **Безопасность** — секреты и серверная логика не утекают в клиент.
- **Гибридная модель** — можно комбинировать серверные куски (данные, разметка) и клиентские (интерактивность) на одной странице.

### Ограничения

- Серверные компоненты не могут использовать состояние (useState), эффекты (useEffect), браузерные API и обработчики событий — для этого нужны Client Components.
- Нужна поддержка на уровне фреймворка (Next.js App Router, React Server Components в React 18+) и серверного рантайма.
- Модель «что на сервере, что на клиенте» нужно понимать и проектировать заранее.

### Когда говорить про RSC на собеседовании

RSC — это эволюция идеи «часть UI рендерится только на сервере и не грузится в клиент». Отличие от SSR — не просто «сервер отдаёт HTML», а «серверные компоненты вообще не попадают в бандл, клиент получает уже готовый результат». Гидрация в такой модели касается только клиентских компонентов.

---

## Сравнение

| Параметр | CSR | SSR | SSG | ISR |
|----------|-----|-----|-----|-----|
| **Рендеринг** | На клиенте | На сервере (каждый запрос) | При сборке | При сборке + регенерация |
| **FCP (First Contentful Paint)** | Медленно | Быстро | Очень быстро | Очень быстро |
| **SEO** | Плохое | Отличное | Отличное | Отличное |
| **Свежесть данных** | Актуальные | Актуальные | Статичные | Частично актуальные |
| **Нагрузка на сервер** | Нет | Высокая | Нет | Низкая (только регенерация) |
| **Масштабируемость** | Отлично | Средне | Отлично | Отлично |
| **Использование** | SPA, админки | Динамика, SEO | Статика, блоги | Полудинамика |

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Что такое CSR? | Рендеринг на клиенте, браузер строит DOM через JS |
| Что такое SSR? | Рендеринг на сервере для каждого запроса, отдаётся готовый HTML |
| Что такое SSG? | Генерация HTML при сборке, статические файлы на CDN |
| Что такое ISR? | SSG + автоматическое обновление страниц по расписанию или по требованию |
| В чём разница SSR и SSG? | SSR рендерит на каждый запрос, SSG — один раз при сборке |
| Когда использовать CSR? | SPA, админки, SEO не важен |
| Когда использовать SSR? | Динамический контент, SEO важен |
| Когда использовать SSG? | Статичный контент, блоги, максимальная скорость |
| Когда использовать ISR? | Баланс между скоростью и свежестью, полудинамический контент |
| Что такое гидрация? | «Оживление» уже отрисованного HTML на клиенте: React подключает обработчики событий к существующим узлам DOM, не перерисовывая страницу заново |
| Когда нужна гидрация? | После SSR и SSG: когда HTML пришёл с сервера или из статики, а интерактивность даёт клиентский JS |
| Что такое RSC? | React Server Components — компоненты, выполняющиеся только на сервере; их код не грузится в браузер, клиент получает готовый результат |
| Чем RSC отличается от SSR? | В SSR код компонентов есть и на сервере, и в клиентском бандле (гидрация всего). В RSC код серверных компонентов только на сервере, в бандл не попадает |
| Плюсы RSC? | Меньший клиентский бандл, прямой доступ к БД и секретам на сервере, безопасность |

---

## Кратко для ответа

**CSR** — рендеринг на клиенте, медленная первая загрузка, плохое SEO, подходит для SPA. **SSR** — рендеринг на сервере для каждого запроса, быстрая загрузка, хорошее SEO, нагрузка на сервер. **SSG** — генерация HTML при сборке, моментальная загрузка, отличное SEO, данные статичны. **ISR** — SSG + регенерация по расписанию, баланс между скоростью и свежестью. **Гидрация** — «оживление» HTML на клиенте: React подключает обработчики к существующим узлам DOM после SSR/SSG. **RSC** — серверные компоненты, код которых не грузится в браузер; клиент получает готовый результат, бандл меньше.
