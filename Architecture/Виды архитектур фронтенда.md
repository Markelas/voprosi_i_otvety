# Виды архитектур фронтенда

## Краткий ответ для собеседования

Основные архитектуры: **Монолит** (один проект, одна сборка, один деплой), **Микрофронтенд** (независимые приложения: **Shell** — оболочка, **Remote** — подключаемые части; сборка и деплой по отдельности, склейка в рантайме), **Модульный монолит** (модули в одном проекте), **Компонентная** (переиспользуемые компоненты). Микрофронтенды координируются через **bootstrap** (Shell): первое загружаемое приложение-оркестратор подгружает Remote по entry-URL и обеспечивает связь (состояние, события). Подходы: Module Federation, Single-SPA, qiankun, iframe, Web Components, server-side. Плюсы: независимость команд, технологическая свобода. Минусы: сложность, дубликаты, производительность.

---

## 1. Монолитная архитектура

### Что это

**Всё приложение — один проект**: один репозиторий, одна кодовая база, одна сборка, один деплой. Весь фронтенд (каталог, корзина, оплата, профиль) живёт в одном приложении — например, одном React-проекте.

### Как работает монолит (принцип работы)

- **Один вход** — пользователь заходит на один адрес (или один SPA), загружается один главный бандл (или разбитый на чанки, но из одного сборщика).
- **Всё связано на этапе сборки** — при сборке (build) все модули, страницы и фичи попадают в общий граф зависимостей. Сборщик (Webpack, Vite и т.д.) один раз обходит весь проект и производит артефакты (бандлы, ассеты). Нет «отдельных приложений», которые подгружаются с других URL.
- **Один рантайм** — в браузере выполняется один и тот же набор скриптов: одна версия фреймворка, общие зависимости, общее состояние (если используется глобальный store). Навигация между разделами — это смена маршрута внутри одного приложения, без загрузки нового «приложения».
- **Один деплой** — выкатывается одна версия фронтенда целиком. Изменили каталог — пересобрали всё приложение и задеплоили. Откат — тоже всего приложения.

Простыми словами: монолит — это «один проект от и до»: один билд, один деплой, одно приложение в браузере. Границы между каталогом, корзиной и профилем — только в коде (папки, модули), а не в отдельных сборках и деплоях.

### Преимущества

- **Простота** — один проект, одна кодовая база, один процесс сборки и деплоя.
- **Легче разрабатывать** — всё в одном месте, общие компоненты и утилиты без границ между «приложениями».
- **Единая сборка** — одна оптимизация, один tree-shaking, проще контролировать размер и зависимости.

### Недостатки

- **Сложность при масштабировании** — большая кодовая база, долгая сборка, любое изменение требует пересборки всего.
- **Зависимость команд** — изменения в одной части могут затронуть другую; все работают в одном репозитории и одной ветке релиза.
- **Сложно обновлять технологии** — всё приложение на одном стеке и одной версии фреймворка.

### Когда использовать

Небольшие и средние проекты, одна команда, быстрый старт. Когда не нужна независимость деплоя и технологий по частям.

---

## 2. Микрофронтенд (Micro Frontend)

### Что это

**Фронтенд разбит на несколько независимых приложений.** Каждая часть (фича, домен) — отдельное приложение со своей сборкой и своим деплоем. На экране пользователя они объединяются в один интерфейс: либо на клиенте (браузер загружает и «склеивает» части), либо на сервере (сервер собирает HTML из разных приложений и отдаёт одну страницу).

Пример: каталог — отдельное приложение (React, команда A), корзина — другое (Vue, команда B), профиль — третье (Angular, команда C). Три приложения, три сборки, три деплоя — но пользователь видит один сайт с навигацией между разделами.

### Роль Shell (хост, контейнер) и Remote (удалённые приложения)

В микрофронтендах обычно есть **одно главное приложение** и **несколько подключаемых**.

- **Shell (Host, контейнер)** — главное приложение, которое пользователь загружает первым. Оно отвечает за общую оболочку: шапка, меню, роутинг верхнего уровня, область, куда подставляются «куски» других приложений. Shell знает, какие есть удалённые приложения и по какому URL или маршруту что подгружать. Оно **не** содержит логику каталога, корзины или профиля — только «рамку» и правила подключения.
- **Remote (удалённое приложение, микрофронт)** — отдельное приложение (каталог, корзина, профиль). У него своя кодовая база, своя сборка, свой деплой. Оно **экспортирует** наружу модули или компоненты (страницу, виджет, роут). Remote не знает про другие микрофронты; он просто «предлагает» свои части по контракту (например, «страница каталога», «виджет корзины»).

**Как они связаны:** Shell при необходимости (по маршруту или действию пользователя) загружает Remote — по ссылке на его **entry** (точку входа). Entry — это специальный файл или скрипт удалённого приложения, в котором описано, что оно отдаёт наружу (какие компоненты, страницы). Shell загружает этот entry, получает доступ к экспортам и рендерит их у себя в отведённом месте. Пользователь воспринимает это как один сайт, хотя каталог может быть с другого домена или с другого CDN.

На собеседовании: **Shell** — главное приложение-оболочка, которое подгружает и отображает части удалённых приложений. **Remote** — отдельное приложение, которое экспортирует свои модули/страницы; загружается по требованию и встраивается в Shell.

### Bootstrap (контейнер) — через него общаются и подключаются микрофронтенды

**Bootstrap** в контексте микрофронтендов — это **первое приложение, которое загружается в браузере**. Оно не содержит бизнес-логику каталога или корзины, а выполняет роль **оркестратора**: инициализирует окружение, роутинг, общую оболочку (шапка, меню) и **решает, когда и какой Remote загрузить**. То есть микрофронтенды не общаются друг с другом напрямую — они подключаются и координируются **через bootstrap (Shell)**.

**Как это работает:**
- Пользователь открывает сайт → загружается **только bootstrap** (лёгкая оболочка).
- Bootstrap знает конфигурацию: какие есть микрофронты, по каким URL их entry, каким маршрутам они соответствуют.
- При переходе по маршруту (или по действию пользователя) bootstrap **загружает нужный Remote** по его entry-URL, получает экспорт (страницу, компонент) и **монтирует его в отведённое место** (слот, контейнер).
- Обмен данными между Shell и Remote (и косвенно между разными Remote) идёт через **общий слой**: глобальное состояние в bootstrap, события (custom events, message bus), URL/query или общий контекст. То есть «общение» микрофронтендов — это не прямой вызов друг друга, а **координация через bootstrap**: он загружает кого нужно и предоставляет канал для данных (store, events, URL).

**Запомнить:** bootstrap = первое приложение-оболочка (Shell/Host/Container); через него микрофронтенды **подключаются** (bootstrap их загружает) и **координируются** (общее состояние, события, роутинг). Без bootstrap не было бы единой точки входа и правил «когда что грузить».

### Технологии и фреймворки для микрофронтендов (bootstrap и аналоги)

Разные технологии по-своему реализуют идею «одно приложение загружается первым и подтягивает остальные». Ниже — основные варианты.

| Технология | Что это | Как устроен bootstrap / связь |
|------------|--------|-------------------------------|
| **Module Federation (Webpack 5)** | Плагин Webpack для динамической загрузки удалённых модулей в рантайме. | **Host** (аналог bootstrap) при сборке не включает код Remote, только знает имена и URL `remoteEntry.js`. В рантайме Host загружает entry нужного Remote и получает его экспорты. Связь — через общий shared (React и т.д.) и импорт модулей из Remote. |
| **Single-SPA** | Фреймворк-оркестратор для микрофронтендов. | Есть явный **root config** (bootstrap): одно приложение регистрирует «приложения» (microfrontends) с правилами активации (по URL) и жизненным циклом (bootstrap, mount, unmount). Single-SPA загружает скрипты приложений и вызывает у них lifecycle-хуки. Связь — через общие события, импорты или shared state. |
| **qiankun** (на базе single-spa) | Фреймворк от Alibaba для микрофронтендов. | **Главное приложение** — bootstrap: загружает «под-приложения» по правилам (активная ссылка, entry, контейнер). Под-приложение изолируется (JS/CSS в песочнице). Связь — через глобальное состояние, передаваемое главным приложением. |
| **Luigi** (SAP) | Фреймворк для корпоративных UI с микрофронтенд-подходом. | **Core (Luigi Core)** — оболочка: навигация, авторизация, контейнеры для микроприложений. Микрофронты подключаются как «узлы» навигации и рендерятся в iframe или в том же окне. Связь — через Luigi API (события, навигация, контекст пользователя). |
| **iframe** | Подход без фреймворка. | **Родительская страница** — bootstrap: в ней iframe с `src`, указывающим на другое приложение. При смене раздела меняется `src` или подключается другой iframe. Связь — только через `postMessage` и общий домен/политики. |
| **Web Components** | Стандарт браузера: Custom Elements. | **Страница-оболочка** загружается первой и вставляет теги вида `<catalog-app>`. Скрипт микрофронта регистрирует элемент и рендерит контент внутри. Bootstrap — по сути страница, которая знает, какие теги где вставить; связь — через атрибуты, события, общий DOM или слой состояния. |
| **Nx** (монорепа + Module Federation) | Инструмент для монорепозиториев и сборки. | Может генерировать и настраивать Host/Remote по схеме Module Federation. Bootstrap — Host-приложение в Nx; связь микрофронтов — как в Module Federation (загрузка по entry, shared-зависимости). |

**Общее:** во всех случаях есть **одна точка входа** (bootstrap/host/shell), которая загружается первой и решает, **когда** и **какой** микрофронт загрузить и **куда** его вмонтировать. Общение между микрофронтами идёт не «напрямую», а через эту оболочку (состояние, события, URL, общие модули).

### Как строят микрофронтенд

- **Разделение по доменам или фичам** — решают, какие части будут отдельными приложениями (каталог, корзина, личный кабинет и т.д.). У каждой части — своя команда (или зона ответственности), свой репозиторий или своя папка в монорепе, своя сборка.
- **Контракт между Shell и Remote** — договариваются, что именно Remote «отдаёт»: например, компонент страницы, имя маршрута, версию API. Shell знает только этот контракт и URL entry каждого Remote; внутренняя реализация Remote (React, Vue, версия) не важна.
- **Общая оболочка (Shell)** — делают одно приложение, которое вешает на себя роутинг и «слоты» для подключаемых частей. Shell при переходе по маршруту определяет, какой Remote нужен, загружает его entry и рендерит полученный модуль в нужном месте.
- **Изоляция или общие зависимости** — решают: либо каждое приложение тащит свои зависимости (полная изоляция, но дублирование React и т.д.), либо договариваются об общей версии и выносят её в «shared» (как в Module Federation), чтобы не грузить несколько копий одной библиотеки.

### Как собирают и деплоят

- **Сборка** — каждое приложение (Shell и каждый Remote) **собирается отдельно**. У Remote при сборке формируется специальный **entry-артефакт** (например, remoteEntry.js в Module Federation): в нём перечислены экспорты и откуда подгружать чанки. Shell при сборке не включает код Remote — только ссылки на их entry-URL. Итог: несколько независимых сборок, несколько артефактов.
- **Деплой** — Shell и каждый Remote деплоятся **независимо**. Обновили каталог — выкатили только приложение каталога; Shell и корзина не трогаются. Обычно у каждого Remote свой URL (свой путь или поддомен), по которому отдаётся его entry и чанки.
- **Сборка в рантайме (не при билде)** — «сборка» в один интерфейс происходит **в браузере** (или на сервере при server-side composition): Shell загружает нужный Remote по URL, получает модули и отображает их. Никто заранее не склеивает все приложения в один бандл — они соединяются в момент загрузки страницы и перехода по маршруту.

На собеседовании: каждый микрофронт **собирается и деплоится отдельно**; Shell знает только URL entry удалённых приложений; «склейка» в один UI происходит при загрузке и навигации (клиент или сервер).

### Принципы микрофронтенда

1. **Независимость команд** — каждая команда владеет своим приложением (Remote), свои репозиторий, свой цикл релизов.
2. **Технологическая свобода** — разные Remote могут быть на разных фреймворках и версиях, если контракт (что экспортируется) соблюдён.
3. **Независимый деплой** — обновление одной части не требует пересборки и редеплоя остальных.
4. **Изоляция** — падение или ошибка в одном Remote по идее не должны ронять Shell и другие Remote (зависит от реализации).

### Подходы к реализации (без кода)

#### 1. Module Federation (Webpack 5)

Shell и Remote собираются Webpack с плагином Module Federation. У каждого Remote есть **entry-файл** (remoteEntry.js), в котором описаны экспорты. Shell при сборке не включает код Remote, а только «знает» их имена и URL entry. В рантайме Shell динамически загружает entry нужного Remote и получает его модули (компоненты, страницы). Можно настроить общие зависимости (например, один React), чтобы не дублировать их в каждом Remote. Плюсы: загрузка по требованию, общий shared. Минусы: привязка к Webpack, настройка сложнее.

#### 2. Iframe

Каждый микрофронт загружается в отдельном iframe. Shell — страница с iframe; при смене маршрута меняется src iframe или подгружается другой iframe. Плюсы: полная изоляция стилей и JS. Минусы: тяжёлая модель (отдельный документ на каждую часть), сложная коммуникация (postMessage), проблемы с навигацией (URL, история, высота), производительность.

#### 3. Web Components

Каждое приложение оборачивается в Custom Element (Web Component) и экспортирует тег вида `<catalog-app>`. Shell просто вставляет такой тег на страницу; браузер загружает скрипт микрофронта, и тот рендерит себя внутри элемента. Изоляция стилей — через Shadow DOM. Плюсы: стандарт браузера, технологическая независимость. Минусы: интеграция с React/Vue не всегда удобна, старые браузеры.

#### 4. Server-Side Composition

Сервер при запросе страницы сам собирает HTML из нескольких приложений (каждое отдаёт фрагмент HTML) и отдаёт клиенту одну готовую страницу. Примеры технологий: SSI, ESI, фреймворки вроде Tailor или Podium. Плюсы: SEO, быстрая первая отрисовка. Минусы: нагрузка на сервер, сложнее синхронизация и версионирование частей.

---

### Преимущества микрофронтенда

- **Независимость команд** — разные команды работают параллельно
- **Технологическая свобода** — каждая команда выбирает стек
- **Постепенная миграция** — переписывать по частям, а не всё сразу
- **Изоляция ошибок** — ошибка в одном модуле не роняет всё
- **Быстрый деплой** — обновление одной части без пересборки всех

### Недостатки микрофронтенда

- **Сложность** — координация, деплой, мониторинг
- **Дубликаты зависимостей** — несколько копий React, lodash и т.д.
- **Производительность** — больше JavaScript, медленнее загрузка
- **Согласованность UI** — сложнее поддерживать единый стиль
- **Сложность коммуникации** — передача данных между модулями

### Когда использовать

- Большие приложения
- Несколько команд
- Разные технологии (миграция)
- Независимые релизы

---

## 3. Модульный монолит

### Что это

**Одно приложение, но разделённое на модули** — каждый модуль независим внутри одного проекта.

Структура проекта: внутри одного репозитория папки по модулям (например, catalog, cart, profile). Каждый модуль — законченная фича со своими компонентами, стилями и логикой, но всё собирается и деплоится одним приложением.

### Преимущества

- **Проще микрофронтенда** — один проект, один деплой
- **Модульность** — чёткие границы между фичами
- **Переиспользование** — общие компоненты

### Недостатки

- **Зависимость** — всё в одной кодовой базе
- **Единая технология** — нельзя миксовать React и Vue

### Когда использовать

- Средние и большие проекты
- Одна или несколько команд
- Нужна структура, но не микрофронтенд

---

## 4. Компонентная архитектура

### Что это

**Приложение состоит из переиспользуемых компонентов** — каждый компонент независим и самодостаточен.

**Примеры:**
- Atomic Design (атомы, молекулы, организмы)
- Component-Driven Development

**Инструменты:**
- Storybook — разработка компонентов в изоляции
- Bit — переиспользование компонентов между проектами

### Преимущества

- **Переиспользование** — компоненты в разных проектах
- **Изоляция** — легче тестировать
- **Согласованность** — единая UI-библиотека

### Недостатки

- **Overhead** — нужно продумывать API компонентов
- **Сложность** — для маленьких проектов избыточно

### Когда использовать

- Дизайн-системы
- Множество проектов с общим UI

---

## Сравнение

| Архитектура | Сложность | Масштабируемость | Команды | Технологии | Деплой |
|-------------|-----------|------------------|---------|------------|--------|
| **Монолит** | Низкая | Средняя | Одна | Одна | Один |
| **Микрофронтенд** | Высокая | Высокая | Много | Разные | Независимый |
| **Модульный монолит** | Средняя | Средняя | 1-3 | Одна | Один |
| **Компонентная** | Средняя | Высокая | Любые | Любые | Зависит |

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Что такое монолит на фронте? | Один проект, одна сборка, один деплой; всё приложение в одной кодовой базе и одном рантайме. |
| Как работает монолит? | Один вход, всё связано при сборке, один рантайм в браузере, один деплой всей системы. |
| Что такое микрофронтенд? | Разделение фронтенда на независимые приложения (Remote), которые объединяются в одном интерфейсе через Shell. |
| Что такое Shell и Remote? | Shell (host) — главное приложение-оболочка, подгружает и отображает части. Remote — отдельное приложение, экспортирует свои модули/страницы, загружается по требованию. |
| Как собирают микрофронтенд? | Каждое приложение (Shell и каждый Remote) собирается отдельно; у Remote формируется entry-артефакт с экспортами; Shell знает только URL entry. |
| Как «склеивают» микрофронты? | В рантайме: Shell по маршруту загружает entry нужного Remote, получает модули и рендерит их у себя. Не один общий бандл — соединение при загрузке. |
| Что такое bootstrap в микрофронтендах? | Первое приложение (Shell/Host), которое загружается; через него подключаются и координируются все Remote — оно загружает их по entry и даёт канал связи (состояние, события). |
| Как микрофронтенды «общаются» между собой? | Не напрямую, а через bootstrap (Shell): общее состояние, события (event bus), URL. Bootstrap решает, когда какой Remote загрузить и куда смонтировать. |
| Какие есть технологии для микрофронтендов? | Module Federation (Webpack), Single-SPA, qiankun, Luigi, iframe, Web Components, Nx с Module Federation. У каждой — свой способ bootstrap/host и связи с Remote. |
| Как реализовать микрофронтенд? | Module Federation (Webpack), Single-SPA, qiankun, iframe, Web Components, server-side composition. |
| В чём минусы микрофронтенда? | Сложность, дубликаты зависимостей, производительность, согласованность UI. |
| Когда НЕ нужен микрофронтенд? | Маленькие проекты, одна команда, нет нужды в независимых деплоях и разных стеках. |

---

## Кратко для ответа

**Монолит** — один проект, одна сборка, один деплой; всё связано при сборке, один рантайм. **Микрофронтенд** — несколько независимых приложений: **bootstrap (Shell)** — первое приложение-оркестратор, через него подключаются и координируются **Remote**; Shell подгружает Remote по entry-URL; «склейка» в один UI — в рантайме. Связь микрофронтов — через bootstrap (состояние, события, URL). Реализация: Module Federation, Single-SPA, qiankun, iframe, Web Components, server-side. Минусы: сложность, дубликаты, производительность.
