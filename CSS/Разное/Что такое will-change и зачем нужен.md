# will-change

## Краткий ответ для собеседования

**will-change** — CSS-свойство, которое **подсказывает браузеру**, что у элемента скоро изменится указанное свойство (например, `transform` или `opacity`). Браузер заранее выносит элемент на отдельный слой (compositor layer) и обрабатывает изменения на GPU — без пересчёта layout (reflow) и без полной перерисовки (repaint). Нужен для **плавных анимаций** и **оптимизации**: анимации `transform` и `opacity` становятся дешевле. Злоупотреблять нельзя: каждый слой занимает память; указывать только для элементов, которые реально будут анимироваться, и по возможности включать незадолго до анимации и снимать после.

---

## Что это и зачем нужен

**will-change** — это **подсказка браузеру**, а не прямое указание. Ты говоришь: «у этого элемента скоро изменится такое-то свойство». Браузер может заранее подготовить элемент к изменениям: вынести его на отдельный слой и отдавать отрисовку слоя GPU.

**Зачем это нужно:**

- **Плавные анимации** — если анимируешь `transform` или `opacity`, браузер не пересчитывает layout всей страницы (reflow) и не перерисовывает всё поддерево (repaint). Меняется только слой — быстрее и плавнее, особенно на слабых устройствах.
- **Меньше нагрузки на главный поток** — перерисовка слоя может идти на GPU, главный поток меньше занят. Это помогает держать 60 FPS при анимациях и скролле.

Простыми словами: «будет меняться transform» → браузер кладёт элемент на отдельный «лист» и двигает этот лист на видеокарте, не трогая остальную страницу. Так анимация дешевле.

---

## Что указывать в will-change

Указывают **то свойство (или свойства)**, которое действительно будет меняться: чаще всего `transform` и `opacity`. Можно несколько через запятую: `will-change: transform, opacity`.

Не стоит перечислять всё подряд: каждый объявленный слой — это память. Браузер и так создаёт слои для части элементов (например, с `transform: translateZ(0)` или для некоторых позиционированных). `will-change` — способ сказать «здесь точно будет анимация, подготовь слой заранее».

---

## Когда использовать

- Элемент **реально будет анимироваться** (движение, fade, масштаб) через `transform` или `opacity`.
- Нужна **плавность** без дёрганий (jank) и без лишних reflow/repaint.
- Анимация вот-вот начнётся — можно включить `will-change` незадолго до старта (например, по `hover` или перед добавлением класса с анимацией) и убрать после окончания, чтобы не держать слой лишнее время.

---

## Когда не использовать (осторожно)

- **Не вешать на много элементов** — много слоёв = много памяти. На слабых устройствах это может даже замедлить или вызвать глитчи.
- **Не указывать «на всякий случай»** — только для тех элементов, где запланирована анимация.
- **Не оставлять навсегда** — по возможности включать перед анимацией и снимать после (через класс или JS), иначе браузер будет держать слой и память всё время.

На собеседовании можно сказать: «will-change подсказывает браузеру создать слой для GPU-ускорения анимаций transform/opacity. Злоупотреблять не стоит — слои потребляют память; использовать только там, где реально анимируем.»

---

## Связь с reflow и repaint

Свойства вроде `width`, `height`, `left`, `margin` при анимации вызывают **reflow** и **repaint** — дорого. Свойства **transform** и **opacity** браузер может обрабатывать на отдельном слое (compositing) **без** reflow и без полного repaint. `will-change: transform, opacity` подсказывает: «создай слой заранее для этих свойств» — так анимация остаётся дешёвой.

Подробнее про оптимизацию: тема про Reflow и Repaint (в конспекте по DOM/производительности).

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Что такое will-change? | CSS-свойство: подсказка браузеру, что у элемента скоро изменится указанное свойство; браузер может заранее вынести элемент на отдельный слой (GPU). |
| Зачем нужен will-change? | Чтобы анимации transform и opacity были дешевле: слой обрабатывается на GPU, без reflow и полного repaint. |
| Какие свойства обычно указывают? | transform, opacity — те, что анимируют чаще всего и обрабатываются на слое. |
| Почему will-change нельзя применять везде? | Каждый слой занимает память; много слоёв — лишняя нагрузка, на слабых устройствах может замедлить. |
| Как правильно использовать will-change? | Только для элементов с реальной анимацией; по возможности включать перед анимацией и снимать после. |

---

## Кратко для ответа

**will-change** — подсказка браузеру: «у элемента скоро изменится это свойство». Браузер выносит элемент на отдельный слой, анимации `transform` и `opacity` идут дешевле (GPU, без reflow/repaint). Не злоупотреблять: слои потребляют память; использовать только там, где реально анимируем, и по возможности снимать после анимации.
