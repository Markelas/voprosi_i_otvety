# Разница между relative, absolute, fixed, sticky

## Кратко

· **static** — значение по умолчанию; элемент в нормальном потоке, `top/right/bottom/left` и `z-index` не применяются.

· <span class="blue">**relative**</span> — элемент смещается относительно своего обычного положения, при этом **занимает место** на странице (в потоке остаётся «дырка»).

· <span class="red">**absolute**</span> — элемент позиционируется относительно **ближайшего позиционированного предка** (position ≠ static), **вынимается из потока**, не занимает места.

· <span class="purple">**fixed**</span> — позиционируется относительно **окна браузера (viewport)**; при прокрутке остаётся на месте.

· <span class="green">**sticky**</span> — ведёт себя как `relative`, пока при прокрутке не «дотянется» до заданной границы (`top`, `left` и т.д.), после чего «прилипает» как fixed в пределах своего контейнера.

---

## Подробнее по каждому

### static (по умолчанию)

- Элемент в **нормальном потоке** документа.
- `top`, `right`, `bottom`, `left`, `z-index` **игнорируются**.
- Чтобы элемент мог стать «опорой» для `position: absolute`, у предка нужно поставить любое значение, кроме `static` (часто `position: relative` без смещения).

---

### <span class="blue">relative</span>

- **Исходное место в потоке сохраняется** — соседи не сдвигаются, под элементом остаётся пустое пространство.
- Смещение задаётся через `top/right/bottom/left` **от того места, где элемент был бы при static**.
- `top: 10px` — сдвиг вниз на 10px; `left: 10px` — вправо на 10px (положительные значения — вниз/вправо).
- Создаёт **новый контекст позиционирования**: потомки с `position: absolute` будут позиционироваться относительно этого элемента.
- Создаёт **stacking context** при `z-index` не `auto`.
- Часто используют именно чтобы сделать предка «опорой» для абсолютно позиционированных детей, не сдвигая сам блок.

---

### <span class="red">absolute</span>

- Элемент **вынимается из потока** — не занимает места, соседи ведут себя так, как будто его нет.
- Позиционируется относительно **containing block**:
  - если у предка `position` отличный от `static` (relative, absolute, fixed, sticky) — относительно этого предка;
  - иначе — относительно viewport (в классической модели — от `<html>`).
- `top/right/bottom/left` задают отступы от границ containing block. Можно задать только часть (например, `top` и `left`), остальное вычислится по ширине/высоте или по `width/height`.
- Если задать все четыре и не задать `width/height`, элемент растянется на всю область (удобно для оверлеев).
- Создаёт новый контекст позиционирования для своих потомков и stacking context при `z-index` не `auto`.

---

### <span class="purple">fixed</span>

- В классической модели — позиционируется относительно **viewport**; при прокрутке остаётся на экране (шапка, кнопка «Наверх», фиксированная панель).
- Элемент **вынимается из потока** (как absolute).
- В современных браузерах при `transform`, `filter`, `perspective` у предка **containing block для fixed меняется** — элемент позиционируется относительно такого предка, а не viewport. Это частый подводный камень.

---

### <span class="green">sticky</span>

- Гибрид: в обычном состоянии ведёт себя как **relative** (остаётся в потоке), при прокрутке — «прилипает» к указанной границе, пока контейнер не уедет с экрана.
- Граница задаётся одним из `top`, `right`, `bottom`, `left` (например, `top: 0` — прилипание к верху viewport при прокрутке вниз).
- **Контейнер прилипания** — ближайший прокручиваемый предок (с `overflow: auto/scroll/overlay` и т.п.) или viewport. Стики-элемент не выходит за пределы этого контейнера: когда контейнер уезжает, элемент прокручивается вместе с ним.
- Чтобы sticky работал, у контейнера не должно быть `overflow: hidden` на том предке, который «обрезает» область прилипания.
- Один из `top/right/bottom/left` обязательно задать, иначе поведение как у relative.

---

## Сводка: контекст позиционирования и поток

| Значение   | В потоке? | Относительно чего позиционируется      |
|-----------|-----------|----------------------------------------|
| static    | да        | —                                      |
| relative  | да (место остаётся) | своего прежнего положения     |
| absolute  | нет       | ближайшего позиционированного предка (или viewport) |
| fixed     | нет       | viewport (или предка с transform/filter) |
| sticky    | да, пока не «прилип» | своего контейнера + viewport при скролле |

---

## Каверзные вопросы на собеседовании

### 1. Почему у родителя с `position: relative` дочерний `position: absolute` «уехал» не туда?

Часто у родителя забывают задать `position: relative` (оставляют `static`). Тогда containing block для absolute — не этот блок, а следующий позиционированный предок или viewport. Ответ: у элемента-«опоры» должно быть `position`, отличное от `static` (обычно `relative` без смещения).

### 2. Элемент с `position: fixed` вдруг скроллится вместе со страницей. Почему?

У какого-то предка заданы `transform`, `filter`, `perspective` или `will-change` с такими значениями. В спецификации это создаёт новый containing block для fixed, поэтому элемент привязан к предку, а не к viewport. Решение: убрать/вынести transform с предков или не использовать fixed внутри таких блоков.

### 3. `position: sticky` не срабатывает. Что проверить?

- Задан ли один из `top` / `right` / `bottom` / `left`? Без них sticky не «прилипает».
- Нет ли у родителя (или предка по цепочке) `overflow: hidden`? Оно создаёт новый контейнер прокрутки и «ломает» прилипание к viewport.
- Высота контейнера: если контейнер выше контента и сам не скроллится, sticky может вести себя неочевидно — прилипание происходит внутри контейнера.

### 4. Чем отличается «занимает место» у relative от «не занимает» у absolute?

При **relative** блок в документе остаётся на своём месте по потоку — другие элементы не заполняют освободившееся пространство. При **absolute** (и fixed) элемент вынимается из потока, и следующие за ним элементы сдвигаются вверх (или в сторону), как будто этого элемента нет.

### 5. Можно ли задать `top` и `bottom` (или `left` и `right`) одновременно у absolute?

Да. Тогда высота (или ширина) задаётся не явно, а через отступы: блок растягивается между указанными границами. Если при этом не задать `width`/`height`, элемент заполняет всю область по этой оси — часто так делают оверлеи на весь блок.

### 6. Создаёт ли `position: relative` без `top/left` новый контекст позиционирования?

Да. Достаточно задать `position: relative` (и не трогать смещения) — элемент уже считается позиционированным и становится containing block для абсолютно позиционированных потомков. Визуально ничего не меняется, но контекст создаётся.

### 7. Что такое «containing block» и кто его задаёт?

Containing block — прямоугольник, относительно которого вычисляются проценты и позиция для `position: absolute/fixed`. Для absolute/fixed его задаёт ближайший предок с `position` не `static`; для fixed в обычных условиях — viewport, а при наличии у предка `transform/filter/perspective` — этот предок.

### 8. Почему у sticky при `top: 0` элемент не прилипает к самому верху экрана?

Обычно мешает один из факторов: у предка `overflow: hidden`; контейнер не скроллится (скролл на body/html); не задан `top`/`bottom`/`left`/`right`; или контейнер стики-элемента заканчивается раньше, чем срабатывает прилипание. Нужно проверить структуру и overflow по цепочке предков.

---

## Полезно запомнить

- **Relative** — «оставь место, сдвинь себя»; идеальная опора для absolute без визуального сдвига.
- **Absolute** — «вынь из потока, привяжи к предку с position ≠ static».
- **Fixed** — «привяжи к окну», но осторожно с transform/filter у предков.
- **Sticky** — «пока в потоке, потом прилипни»; нужен `top`/`bottom`/`left`/`right` и отсутствие «ломающего» overflow у предков.
