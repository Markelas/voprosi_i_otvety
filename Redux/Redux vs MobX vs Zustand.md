# Redux vs MobX vs Zustand

## Краткий ответ для собеседования

**Redux** — предсказуемый стейт через один store, действия (actions) и чистые редьюсеры; строгая архитектура, DevTools, много boilerplate. **MobX** — реактивный стейт: наблюдаемые объекты и автоматическое обновление UI при изменении данных; мало кода, но «магия» и менее явный поток. **Zustand** — минималистичный store: простой API, мало кода, без обязательных actions/reducers; удобен для средних проектов и быстрого старта. Выбор: Redux — большие команды и строгий контроль; MobX — быстрая разработка и реактивность; Zustand — баланс простоты и достаточной структуры.

---

## Redux

### Суть

Один глобальный store (дерево состояния). Изменения только через **actions** (объекты с типом) и **редьюсеры** (чистые функции: старый стейт + action → новый стейт). Подписка компонентов на части стейта; обновление только при изменении выбранных данных (селекторы).

### Плюсы

- Предсказуемость: все изменения проходят через один поток (dispatch → reducer).
- Время отладки: логирование, replay, time-travel в Redux DevTools.
- Тестирование: редьюсеры и экшены — чистые функции, легко тестировать.
- Экосистема: middleware (thunk, saga), RTK, RTK Query, типизация с TypeScript.
- Масштабирование: чёткие правила, удобно для больших команд и проектов.

### Минусы

- Много кода: actions, action creators, reducers, константы; даже с RTK есть шаблон.
- Крутая кривая обучения: концепции (store, dispatch, reducer, middleware) и паттерны.
- Простые сценарии выглядят тяжеловесно по сравнению с локальным стейтом или Zustand.

### Когда выбирать

Большие приложения, несколько команд, важны предсказуемость, отладка и единые правила работы со стейтом.

---

## MobX

### Суть

Стейт хранится в **наблюдаемых** объектах/массивах. Компоненты (или вычисляемые значения) подписываются на эти поля. При изменении поля автоматически пересчитываются зависимости и обновляется UI. Не нужно вручную вызывать setState или dispatch — реактивность «из коробки».

### Плюсы

- Мало boilerplate: нет явных actions и reducers, мутации выглядят как обычное присваивание.
- Удобно для быстрого прототипирования и форм: много мелких полей, связанных между собой.
- Проще для части команды: не нужно думать о dispatch и чистоте редьюсеров.

### Минусы

- «Магия»: неочевидно, когда и что обновит; отладка сложнее, чем в Redux.
- Меньше жёстких правил: легко размазать логику по компонентам и сторам.
- Меньше экосистемы и вакансий по сравнению с Redux.
- Реактивность может приводить к лишним обновлениям, если не контролировать зависимости.

### Когда выбирать

Нужна быстрая разработка, много реактивных связей между данными, команда готова к реактивной модели и инструментам MobX.

---

## Zustand

### Суть

Минималистичный store: создаётся хранилище с начальным состоянием и функциями обновления. Компоненты подписываются на части store (по селектору). Нет обязательных actions и reducers — обновление через вызов функций стора или set-методов. Под капотом — подписка на изменения и ререндер только при изменении выбранного среза состояния.

### Плюсы

- Очень мало кода: один store на модуль/фичу, без констант и отдельного слоя actions.
- Простой API: создать store, читать и менять из компонентов, подписаться на поля.
- Нет лишней абстракции для простых случаев; при этом можно ввести свои правила (типа actions).
- Маленький размер библиотеки и быстрый старт.
- Удобная работа с TypeScript и селекторами.

### Минусы

- Меньше «архитектуры из коробки» — дисциплину (как менять стейт, где хранить логику) задаёт команда.
- Нет встроенного time-travel и такого же уровня инструментов, как у Redux DevTools.
- Для очень больших приложений с жёсткими правилами аудита изменений Redux может быть предпочтительнее.

### Когда выбирать

Средние проекты, желание минимизировать boilerplate, при этом сохранить понятную модель стейта и подписок; миграция с Redux или дополнение к нему (например, локальный стейт фичи в Zustand).

---

## Сравнение

| Критерий | Redux | MobX | Zustand |
|----------|-------|------|---------|
| **Модель** | Один store, actions, редьюсеры | Наблюдаемые объекты, реакции | Store с полями и методами |
| **Изменение стейта** | Только через dispatch(action) | Прямая мутация наблюдаемых полей | Вызов методов стора / set |
| **Boilerplate** | Много (даже с RTK) | Мало | Мало |
| **Предсказуемость** | Высокая | Ниже (реактивная «магия») | Средняя (зависит от правил) |
| **DevTools / отладка** | Сильные (Redux DevTools) | Есть, но проще Redux | Проще Redux |
| **Кривая обучения** | Выше | Средняя | Ниже |
| **Размер / сложность** | Больше | Средняя | Мало |
| **Типизация** | Отлично (RTK, типы для actions) | Хорошо | Хорошо |
| **Когда уместен** | Большие команды, строгий контроль | Быстрая разработка, реактивность | Средние проекты, минимум кода |

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Чем Redux отличается от MobX? | Redux — явные actions и редьюсеры, один поток изменений; MobX — реактивные объекты, автоматическое обновление при изменении данных. |
| Чем Zustand отличается от Redux? | Zustand — минимальный API, нет обязательных actions/reducers, меньше кода; Redux — строгая архитектура и DevTools. |
| Когда выбрать Redux? | Большие приложения, важна предсказуемость, отладка и единые правила для команды. |
| Когда выбрать Zustand? | Нужен простой глобальный стейт с минимумом boilerplate, средний размер проекта. |
| Плюсы MobX? | Мало кода, реактивность из коробки, быстрая разработка форм и связанных данных. |
| Минусы MobX? | Меньше явного контроля, сложнее отладка, меньше экосистемы по сравнению с Redux. |

---

## Кратко для ответа

Redux — строгая архитектура (store, actions, reducers), предсказуемость и DevTools; много шаблонного кода. MobX — реактивный стейт, мало boilerplate, но менее явный поток данных. Zustand — простой store с минимумом API, мало кода, удобен для средних проектов. Выбор зависит от размера команды, требований к предсказуемости и желания минимизировать boilerplate.
