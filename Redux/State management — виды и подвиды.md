# State management — виды и подвиды

## Краткий ответ для собеседования

**State (состояние)** в приложении делят на два больших вида: **клиентское** и **серверное**. **Клиентское** — то, что живёт только во фронтенде (форма, тема, корзина). Оно бывает **локальным** (один компонент), **глобальным** (всё приложение) и **модульным** (часть приложения, фича/модуль). **Серверное** — данные с API; источник правды на бэкенде, фронт кэширует и синхронизирует. На собеседовании часто спрашивают: какие виды состояния бывают, чем локальный state отличается от глобального, что такое серверное состояние.

---

## Два главных вида состояния

| Вид | Где «живёт» правда | Примеры | Типичные инструменты |
|-----|---------------------|--------|----------------------|
| **Клиентское** | Только во фронтенде | Тема, открыт ли сайдбар, поля формы, корзина до отправки | useState, useReducer, Redux, Zustand, Jotai |
| **Серверное** | На сервере (бэкенд — источник правды) | Список пользователей, профиль, посты | TanStack Query, RTK Query, SWR, Apollo |

**Запомнить:** клиентское = «наше», создаём и меняем сами; серверное = «чужое», пришло с API, нужно кэшировать и синхронизировать.

---

## Клиентское состояние — подвиды

Клиентское состояние по **области видимости** делят на три подвида.

### 1. Локальное (local state)

**Где:** внутри одного компонента (или пары родитель–дети через props).

**Примеры:** значение инпута, открыта ли выпадашка, счётчик кликов в кнопке.

**Инструменты:** `useState`, `useReducer` в этом компоненте; данные можно пробрасывать вниз через props.

**Когда использовать:** данные нужны только этому компоненту (или его детям). Не тащи в глобальный store.

---

### 2. Глобальное (global state)

**Где:** доступно всему приложению — любой компонент может прочитать или изменить.

**Примеры:** тема (светлая/тёмная), текущий пользователь (логин/роль после авторизации), язык, открыта ли боковая панель в целом по приложению.

**Инструменты:** Redux, Zustand, Jotai, Context API (для простых случаев).

**Когда использовать:** данные нужны в разных частях дерева компонентов, далеко друг от друга, без prop drilling.

---

### 3. Модульное / фичевое (feature / module state)

**Где:** не всё приложение, а одна фича или модуль (страница, раздел, поток). Состояние изолировано в границах этой части приложения.

**Примеры:** состояние формы «Создать заказ» (шаги визарда, выбранные товары внутри страницы); фильтры и сортировка в списке на странице «Заказы»; состояние модалки и выбранная запись в разделе «Настройки».

**Инструменты:** отдельный слайс в Redux (по фичам), отдельный store в Zustand, Context с узким провайдером вокруг фичи, или даже локальный state страницы/контейнера.

**Когда использовать:** данные нужны нескольким компонентам внутри одной фичи, но не всему приложению. Так избегают «раздутого» глобального store.

---

## Сводка: клиентское состояние по подвидам

| Подвид | Область видимости | Примеры | Инструменты |
|--------|--------------------|--------|-------------|
| **Локальное** | Один компонент (и его дети через props) | Инпут, открыта ли выпадашка, счётчик | useState, useReducer |
| **Глобальное** | Всё приложение | Тема, пользователь, язык, общая боковая панель | Redux, Zustand, Jotai, Context |
| **Модульное (фичевое)** | Одна фича / страница / модуль | Форма заказа, фильтры списка, состояние раздела настроек | Слайс Redux по фиче, store/context в границах модуля |

---

## Серверное состояние — коротко

**Серверное состояние** — данные, источник которых бэкенд. Фронт их не «владеет», а запрашивает, кэширует и при необходимости обновляет.

**Особенности:**
- Асинхронное получение (загрузка, ошибка).
- Нужен кэш и синхронизация (чтобы не дергать API без нужды и не показывать устаревшее).
- Инвалидация после мутаций («создали пост — обнови список постов»).

**Инструменты:** TanStack Query, RTK Query, SWR, Apollo (для GraphQL). Для чистого клиентского state их обычно не используют — они заточены под серверные данные.

---

## Как выбрать вид и подвид (практика)

1. **Нужно только в одном компоненте** → локальный state (`useState` / `useReducer`).
2. **Нужно в разных ветках дерева по всему приложению** → глобальный state (Redux, Zustand, Context).
3. **Нужно в нескольких компонентах одной фичи/страницы** → модульный state (слайс по фиче, локальный store/context модуля).
4. **Данные с сервера (списки, профиль, посты)** → серверное состояние (TanStack Query, RTK Query и т.п.), а не «складывать» их в Redux как единственное хранилище.

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| На какие виды делится состояние в приложении? | Клиентское (живёт только на фронте) и серверное (данные с API, источник правды на бэкенде). |
| На какие подвиды делится клиентское состояние? | Локальное (один компонент), глобальное (всё приложение), модульное/фичевое (одна фича или раздел). |
| Чем локальный state отличается от глобального? | Локальный — внутри компонента, через useState/props. Глобальный — доступен везде, через Redux/Zustand/Context. |
| Что такое модульный (фичевой) state? | Состояние в границах одной фичи или модуля: не одно дерево компонента и не всё приложение, а, например, страница или раздел. |
| Что такое серверное состояние? | Данные с API; фронт кэширует и синхронизирует их. Управляют через TanStack Query, RTK Query, SWR и т.п. |
| Когда что использовать? | Один компонент — локальный; много частей приложения — глобальный; одна фича — модульный; данные с бэка — серверное состояние и библиотеки для кэша/запросов. |

---

## Что запомнить одной схемой

**Состояние:**
- **Клиентское** — локальное (компонент) / глобальное (всё приложение) / модульное (фича, раздел).
- **Серверное** — данные с API, кэш и синхронизация на фронте.

Сначала определить вид (клиент vs сервер), потом для клиентского — подвид (локальный / глобальный / модульный), и под это подобрать инструмент.
