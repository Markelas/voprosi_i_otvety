# TanStack Query и RTK Query — что это и чем отличаются

## Краткий ответ для собеседования

**TanStack Query** (раньше React Query) — библиотека **только для работы с серверным состоянием**: загрузка, кэш, обновление, повторные запросы. Не привязана к Redux; подходит для любого стека (React, Vue, и т.д.). Данные живут в кэше TanStack Query.

**RTK Query** — инструмент из экосистемы **Redux Toolkit** для запросов к API. Данные кладутся в **Redux store** и живут рядом с остальным состоянием. Удобен, когда проект уже на Redux и хочется один store для всего.

**Главное отличие:** TanStack Query — отдельная библиотека и свой кэш; RTK Query — часть Redux, данные в store. Обе решают одну задачу (кэширование запросов, загрузка, инвалидация), но по-разному интегрируются в приложение.

---

## Что такое TanStack Query

**TanStack Query** — библиотека для **серверного состояния**: «получить данные с бэкенда, закэшировать, показать загрузку и ошибку, при необходимости обновить».

### Основные идеи (чтобы запомнить)

- **Серверное состояние** — данные с API. Они не «твои», они на сервере; тебе нужны загрузка, кэш, синхронизация. TanStack Query как раз про это.
- **Клиентское состояние** — то, что живёт только в приложении (форма, UI-флаги, корзина). Обычно хранят в useState / Redux / Zustand.

TanStack Query даёт:

- **Кэш** по ключу запроса (например, `['users', userId])` — не дергаешь API лишний раз.
- **Статусы** `loading`, `error`, `success` — не пишешь вручную флаги.
- **Refetch** — обновление по фокусу окна, по интервалу, по клику.
- **Инвалидация** — «эти данные устарели, перезапроси». После мутации можно инвалидировать запрос и данные обновятся.

### Как выглядит в коде (запомнить формулу)

```js
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// Запрос данных
const { data, isLoading, isError, error, refetch } = useQuery({
  queryKey: ['user', userId],   // ключ кэша
  queryFn: () => fetchUser(userId),
});

// Мутация (POST/PUT/DELETE) + инвалидация
const queryClient = useQueryClient();
const mutation = useMutation({
  mutationFn: updateUser,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['user', userId] }); // «обнови данные»
  },
});
```

**На собеседовании можно сказать:** «TanStack Query забирает на себя кэширование запросов, индикаторы загрузки и ошибок, рефетч и инвалидацию. Я задаю queryKey и queryFn, остальное библиотека делает сама.»

---

## Что такое RTK Query

**RTK Query** — инструмент из **Redux Toolkit** для запросов к API. Это не отдельная библиотека, а часть RTK.

### Основные идеи

- Запросы описываются через **createApi** (эндпоинты и типы запросов).
- Результаты запросов попадают в **Redux store**. Любой компонент может читать их через `useSelector` или сгенерированные хуки.
- Кэш, загрузка, ошибки — тоже в store; можно комбинировать с другими слайсами и middleware.

### Как выглядит в коде (схема)

```js
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

const api = createApi({
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  endpoints: (builder) => ({
    getUser: builder.query({
      query: (userId) => `users/${userId}`,
    }),
    updateUser: builder.mutation({
      query: (body) => ({ url: `users/${body.id}`, method: 'PUT', body }),
    }),
  }),
});

// Сгенерированные хуки
const { useGetUserQuery, useUpdateUserMutation } = api;
```

В компоненте: `const { data, isLoading, error } = useGetUserQuery(userId);` — данные при этом лежат в Redux.

**На собеседовании:** «RTK Query — это слой для API внутри Redux. Все ответы и кэш хранятся в store, можно использовать селекторы и другие части Redux.»

---

## Отличия TanStack Query и RTK Query (таблица)

| Критерий | TanStack Query | RTK Query |
|----------|----------------|-----------|
| **Где живут данные** | В своём кэше (внутри библиотеки) | В Redux store |
| **Зависимость** | Не зависит от Redux, только React (или другой фреймворк) | Часть Redux Toolkit, нужен Redux |
| **Подход** | Отдельная библиотека для серверного состояния | «API-слой» в едином store |
| **Интеграция с Redux** | Можно использовать вместе с Redux (клиентское состояние в Redux, серверное в Query) | Уже внутри Redux |
| **DevTools** | Есть отдельные DevTools для Query | Используются Redux DevTools |
| **Размер/сложность** | Одна библиотека, не тащишь store, если он не нужен | Нужен store и настройка RTK |

---

## Отличия простыми словами

1. **TanStack Query** — «отдельный менеджер для данных с сервера». Не Redux, не глобальный store; только запросы, кэш и обновления. Запомнить: **свой кэш, без Redux**.

2. **RTK Query** — «запросы как часть Redux». Всё в одном store: и UI-состояние, и ответы API. Запомнить: **всё в Redux**.

3. **Когда что брать**
   - Уже есть Redux и хочется, чтобы и API-данные были в store (одни DevTools, одни селекторы) → **RTK Query**.
   - Redux нет или не хочется класть серверные данные в store → **TanStack Query**.
   - Нужна одна библиотека и для React, и для Vue/Solid — **TanStack Query** (есть адаптеры под разные фреймворки).

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Что такое TanStack Query? | Библиотека для серверного состояния: кэш запросов, загрузка, ошибки, рефетч, инвалидация. Не привязана к Redux. |
| Что такое RTK Query? | Инструмент Redux Toolkit для API. Запросы и кэш хранятся в Redux store. |
| В чём главное отличие? | TanStack Query — отдельная библиотека со своим кэшем; RTK Query — часть Redux, данные в store. |
| Когда выбрать TanStack Query? | Когда Redux нет или не нужен для серверных данных; когда нужна одна библиотека под несколько фреймворков. |
| Когда выбрать RTK Query? | Когда проект уже на Redux и хочется держать и клиентское, и серверное состояние в одном store. |
| Можно ли использовать TanStack Query вместе с Redux? | Да. Redux — для клиентского состояния, TanStack Query — для серверного; так часто и делают. |

---

## Что запомнить одной фразой

**TanStack Query** — отдельная библиотека для запросов к API со своим кэшем, без Redux. **RTK Query** — запросы к API внутри Redux, всё в store. Обе решают кэширование и работу с загрузкой/ошибками; разница в том, где хранятся данные (свой кэш vs Redux) и нужен ли тебе Redux вообще.
