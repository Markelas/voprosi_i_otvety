# TanStack Query — как работает и что запомнить

## Краткий ответ для собеседования

**TanStack Query** (раньше React Query) — библиотека для **серверного состояния**: загрузка данных с API, кэш по ключу, автоматическое обновление (refetch) и инвалидация («данные устарели — перезапроси»). Ты задаёшь **queryKey** (уникальный ключ запроса) и **queryFn** (функцию, которая реально ходит на сервер). Библиотека сама кэширует результат, даёт статусы загрузки и ошибки, при необходимости обновляет данные в фоне. Для изменений на сервере (POST/PUT/DELETE) используется **useMutation**; после успеха можно **инвалидировать** связанные запросы — и данные в UI обновятся. На собеседовании важно сказать: ключ + функция запроса, кэш, stale/fresh, refetch и invalidation.

---

## Основные термины (шпаргалка)

| Термин | Коротко |
|--------|--------|
| **useQuery** | Хук для получения данных (GET). Передаёшь queryKey + queryFn, получаешь data, isLoading, isError, refetch. Данные кэшируются по ключу. |
| **queryKey** | Уникальный ключ запроса (массив, напр. `['user', id]`). Один ключ = одна запись в кэше; один и тот же ключ в разных компонентах — общие данные. |
| **queryFn** | Функция, возвращающая Promise (запрос на сервер). Вызывается библиотекой, когда нужно загрузить или обновить данные. |
| **Stale / Fresh** | **Fresh** — данные считаются актуальными, refetch не запускается. **Stale** — устаревшие, при монтировании/фокусе окна и т.д. пойдёт refetch. Настраивается через `staleTime`. |
| **Refetch** | Повторный запрос на сервер. Срабатывает при монтировании (если данные stale), при возврате фокуса на вкладку, по интервалу, при ручном вызове `refetch()` или после `invalidateQueries`. |
| **useMutation** | Хук для изменений на сервере (POST/PUT/DELETE). Вызываешь `mutate(data)`; после успеха обычно вызываешь `invalidateQueries`, чтобы обновить связанные данные. |
| **invalidateQueries** | Пометить запросы по ключу как устаревшие (stale) и перезапросить их. Используют после мутации, чтобы UI показал актуальные данные. |
| **Prefetch** | Заранее выполнить запрос и положить результат в кэш (`queryClient.prefetchQuery`). При появлении useQuery с тем же ключом данные уже есть — быстрый переход. |
| **QueryClient** | Объект с кэшем и настройками. Создаётся один раз, передаётся в дерево через `QueryClientProvider`. Через `useQueryClient()` получаешь доступ к invalidate, prefetch и т.д. |

---

## Зачем вообще TanStack Query

Без библиотеки ты сам делаешь: `useState` для данных, `useState` для loading, `useState` для error, `useEffect` с fetch, проверку «уже загружали или нет», обновление при возврате на вкладку. Много шаблонного кода и легко забыть edge cases.

TanStack Query забирает это на себя: один хук `useQuery` даёт и данные, и загрузку, и ошибку, и кэш, и рефетч по правилам. Ты описываешь **что** запросить и **по какому ключу** кэшировать — **как** и **когда** запрашивать решает библиотека.

---

## Как устроен запрос: queryKey и queryFn

Каждый запрос в TanStack Query определяется двумя вещами:

1. **queryKey** — массив (реже строка), уникальный ключ запроса. По нему библиотека понимает: «это тот же запрос» или «другой». Одинаковый ключ у нескольких компонентов — данные запросятся один раз и будут общими в кэше.
2. **queryFn** — функция, которая возвращает Promise (обычно `fetch` или `axios`). Её вызывает библиотека, когда нужно получить или обновить данные.

**Пример:**

```js
useQuery({
  queryKey: ['user', userId],      // ключ: пользователь с id = userId
  queryFn: () => fetchUser(userId), // как получить данные
});
```

Если в двух компонентах вызвать `useQuery` с одним и тем же `queryKey`, запрос уйдёт один раз, результат попадёт в кэш и будет отдан обоим. Второй компонент не дергает API повторно — берёт из кэша.

**Запомнить:** разный `queryKey` — разный запрос и разная запись в кэше. `['user', 1]` и `['user', 2]` — два разных пользователя. `['posts']` и `['posts', { page: 1 }]` — список постов и список с фильтром.

---

## Кэш: где лежат данные

TanStack Query хранит результаты запросов во **внутреннем кэше** (в памяти). Запись в кэше привязана к **queryKey**. Пока данные есть в кэше и считаются актуальными (см. ниже), повторный запрос на сервер не уходит — компонент сразу получает кэшированные данные.

Кэш можно представить как объект: ключ — сериализованный queryKey, значение — данные + метаданные (когда загружено, статус и т.д.). При размонтировании компонента данные по умолчанию не удаляются — они остаются в кэше и при следующем монтировании компонента с тем же queryKey будут показаны сразу (с опциональным рефетчем в фоне).

---

## Stale и Fresh — «свежесть» данных

У каждой записи в кэше есть понятие **свежести**:

- **Fresh (свежие)** — данные считаются актуальными. Пока данные fresh, при монтировании компонента новый запрос на сервер не отправляется, показываются данные из кэша.
- **Stale (устаревшие)** — данные считаются устаревшими. При следующем «подходящем» моменте (монтирование компонента, возврат фокуса на окно и т.д.) TanStack Query сделает refetch в фоне и обновит кэш.

По умолчанию данные считаются **fresh** сразу после успешного запроса, а через **0 миллисекунд** (по умолчанию) переходят в **stale**. То есть по дефолту данные почти сразу считаются устаревшими — и при следующем монтировании или при возврате фокуса на вкладку библиотека сделает фоновое обновление. Так пользователь чаще видит актуальные данные.

Поведение можно настроить:

- **staleTime** — сколько миллисекунд данные остаются fresh. Пока не истекло — рефетча при монтировании не будет.
- **gcTime** (раньше cacheTime) — сколько времени данные остаются в кэше после того, как не осталось подписчиков (компонентов, использующих этот query). После истечения запись из кэша удаляется.

**Запомнить:** stale = «пора бы обновить», fresh = «пока считаем актуальными». Refetch по умолчанию срабатывает при монтировании и при возврате фокуса на окно — если данные уже stale.

---

## Когда TanStack Query делает refetch (обновление)

Библиотека может заново вызвать queryFn и обновить данные в таких случаях (поведение настраивается):

1. **Компонент смонтировался** и использует этот query — если данные stale, делается refetch.
2. **Окно снова в фокусе** (пользователь вернулся на вкладку) — при stale данных refetch (чтобы подтянуть возможные изменения).
3. **Сеть переподключилась** — опционально refetch.
4. **Интервал** — если задан `refetchInterval`, запрос будет повторяться по таймеру.
5. **Ручной вызов** — `refetch()` из возвращаемого объекта useQuery.
6. **Инвалидация** — явный вызов `queryClient.invalidateQueries({ queryKey: [...] })` помечает запросы как stale и запускает refetch для активных подписчиков.

**Запомнить:** refetch не значит «удалить данные» — сначала показываются старые из кэша, в фоне уходит запрос, после ответа кэш и UI обновляются.

---

## useQuery — что возвращает

Из `useQuery` ты получаешь объект с полями, которые нужны для UI и логики:

| Поле | Что значит |
|------|------------|
| **data** | Данные последнего успешного запроса (или undefined, пока запроса не было / идёт загрузка). |
| **isLoading** | true, когда запроса ещё не было и данные загружаются впервые (нет данных в кэше). |
| **isFetching** | true, когда идёт любой запрос — и первый, и фоновый refetch. |
| **isError** | true, если последний запрос завершился ошибкой. |
| **error** | Объект ошибки. |
| **refetch** | Функция: принудительно выполнить запрос заново. |
| **status** | `'pending' | 'error' | 'success'` |
| **fetchStatus** | `'fetching' | 'paused' | 'idle'` — идёт ли сейчас запрос. |

**Запомнить:** `isLoading` — «ещё ни разу не загружали» (нет кэша). `isFetching` — «сейчас что-то грузится» (включая фоновый refetch). Для индикатора «крутилки» часто используют `isLoading` для первого загрузочного состояния и при желании `isFetching` для фонового обновления.

---

## Мутации: useMutation

Запросы на изменение данных (POST, PUT, PATCH, DELETE) делаются через **useMutation**, а не useQuery. useQuery — для «получить данные», useMutation — для «отправить изменение».

**useMutation** возвращает объект с полями вроде `mutate`, `mutateAsync`, `isPending`, `isError`, `isSuccess` и т.д. Ты вызываешь `mutate(данные)` или `mutateAsync(данные)` — вызывается переданная `mutationFn`. После успешного ответа часто нужно обновить данные на экране: например, после создания поста — обновить список постов. Для этого после успеха мутации вызывают **invalidateQueries** по нужному queryKey — помечают запросы как stale и запускают refetch.

**Пример:**

```js
const queryClient = useQueryClient();

const mutation = useMutation({
  mutationFn: (newPost) => createPost(newPost),
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['posts'] });
  },
});

// в компоненте
mutation.mutate({ title: 'Заголовок', body: 'Текст' });
```

**Запомнить:** мутация = изменение на сервере; после успеха инвалидируем связанные запросы — список/детали перезапросятся и UI покажет актуальные данные.

---

## Инвалидация (invalidateQueries)

**Инвалидация** — сказать библиотеке: «эти данные устарели». Запросы с подходящим queryKey помечаются как **stale**. Для тех из них, на которые есть активные подписчики (смонтированные компоненты), сразу запускается refetch. Данные в кэше не удаляются — они остаются на экране до прихода нового ответа (или можно показывать индикатор через isFetching).

Типичное использование: после успешной мутации (создали/обновили/удалили запись) вызываешь:

```js
queryClient.invalidateQueries({ queryKey: ['posts'] });
```

Можно инвалидировать по точному ключу или по части ключа (например, все ключи, которые начинаются с `['posts']`). Тогда список постов (и при необходимости связанные запросы) обновятся.

**Запомнить:** invalidate = «считать данные устаревшими и при возможности перезапросить», а не «удалить из кэша».

---

## Prefetch — подгрузка заранее

**prefetchQuery** — заранее выполнить запрос и положить результат в кэш. Пока пользователь, например, наводит на ссылку или открывает список, можно подгрузить данные профиля или детали страницы. Когда пользователь перейдёт, useQuery с тем же queryKey возьмёт данные из кэша — экран отрисуется сразу, без ожидания.

**Запомнить:** prefetch = «загрузить в кэш заранее», чтобы при появлении useQuery с тем же ключом данные уже были.

---

## QueryClient и обёртка провайдером

TanStack Query хранит кэш и настройки в объекте **QueryClient**. В приложении создаётся один экземпляр и передаётся в дерево через **QueryClientProvider**:

```js
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient();

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <YourApp />
    </QueryClientProvider>
  );
}
```

Все useQuery и useMutation внутри провайдера используют этот общий кэш и настройки. Через хук **useQueryClient()** в компоненте можно получить доступ к тому же queryClient (для invalidateQueries, prefetch и т.д.).

---

## Как это всё работает вместе (коротко)

1. Компонент вызывает **useQuery** с queryKey и queryFn.
2. TanStack Query смотрит кэш по queryKey. Если есть свежие (fresh) данные — возвращает их, запрос не шлёт. Если данных нет или они stale — шлёт запрос (или сразу показывает старые и шлёт в фоне).
3. Ответ кладётся в кэш, компонент получает data / isLoading / isError и т.д.
4. Со временем или по правилам данные становятся stale; при следующем монтировании или возврате фокуса — refetch, кэш обновляется.
5. После мутации вызывается **invalidateQueries** — связанные запросы помечаются stale и перезапрашиваются, UI обновляется.

**Запомнить:** один queryKey — одна запись в кэше; ключ + queryFn задают «что запрашивать», библиотека решает «когда» и «как часто», даёт статусы и рефетч.

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Что такое TanStack Query? | Библиотека для серверного состояния: кэширование запросов по ключу, загрузка/ошибка, refetch и инвалидация. Задаёшь queryKey и queryFn. |
| Как он работает? | По queryKey хранит результат в кэше. При монтировании/фокусе/интервале/инвалидации при необходимости вызывает queryFn и обновляет кэш. Отдаёт data, isLoading, isError, refetch и т.д. |
| Что такое queryKey и queryFn? | queryKey — уникальный ключ запроса (массив), по нему кэш; queryFn — функция, возвращающая Promise, её вызывает библиотека для запроса на сервер. |
| Что такое stale и fresh? | Fresh — данные считаются актуальными, рефетча нет. Stale — устаревшие, при следующем подходящем моменте будет refetch. Настраивается через staleTime. |
| Когда делается refetch? | При монтировании компонента (если данные stale), при возврате фокуса на окно, по интервалу (refetchInterval), при ручном refetch(), при invalidateQueries. |
| Зачем invalidateQueries? | Пометить запросы как устаревшие и перезапросить их. Обычно вызывают после мутации (POST/PUT/DELETE), чтобы обновить списки и детали на экране. |
| Чем useQuery отличается от useMutation? | useQuery — получить данные (GET), кэш и автообновление. useMutation — отправить изменение (POST/PUT/DELETE), после успеха обычно вызывают invalidateQueries. |
| Что такое prefetch? | Заранее выполнить запрос и положить результат в кэш, чтобы при появлении useQuery с тем же ключом данные уже были — быстрый переход без ожидания. |

---

## Одной фразой для ответа

**TanStack Query** — библиотека для данных с API: ты задаёшь **queryKey** и **queryFn**, она кэширует ответ, даёт статусы загрузки и ошибки, сама обновляет данные (refetch при монтировании, фокусе, по интервалу или после **invalidateQueries**). Изменения на сервере делаются через **useMutation**, после успеха инвалидируешь связанные запросы — и UI показывает актуальные данные. Данные считаются **fresh**, потом **stale**; при stale срабатывает refetch по правилам. Всё это — чтобы не писать вручную кэш, loading и обновление.
