# Redux vs Context API

## Краткий ответ для собеседования

**Context API** — встроенный React-инструмент для передачи данных вглубь дерева без prop drilling; подходит для простого глобального состояния (тема, язык, пользователь). **Redux** — полноценная библиотека для управления состоянием с предсказуемостью, DevTools, middleware; подходит для сложного состояния, больших приложений. Redux избыточен для простых случаев, Context API не подходит для частых обновлений и сложной логики.

---

## Context API

### Что это

**Context API** — встроенный механизм React для передачи данных через дерево компонентов **без явной передачи props** на каждом уровне.

### Зачем нужен

- **Избежать prop drilling** — передача props через множество уровней компонентов
- **Глобальное состояние** — тема, язык, данные пользователя, настройки

### Как работает

1. Создаёшь контекст: `const ThemeContext = React.createContext()`
2. Оборачиваешь компоненты в `<ThemeContext.Provider value={theme}>`
3. Читаешь значение: `const theme = useContext(ThemeContext)`

**Простой пример:**

```jsx
const ThemeContext = React.createContext();

function App() {
  const [theme, setTheme] = useState('light');
  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      <Component />
    </ThemeContext.Provider>
  );
}

function Component() {
  const { theme, setTheme } = useContext(ThemeContext);
  return <button onClick={() => setTheme('dark')}>Сменить тему</button>;
}
```

---

### Когда использовать Context API

- **Простое глобальное состояние** — тема, язык, авторизация пользователя
- **Редко меняющиеся данные** — настройки, конфигурация
- **Небольшие приложения** — несколько глобальных значений
- **Нет сложной логики** — нет middleware, вычислений, side-эффектов

---

### Проблемы Context API

#### 1. **Производительность при частых обновлениях**

**Проблема:**  
При изменении значения контекста **все компоненты**, подписанные на контекст, **ререндерятся**, даже если им нужна только часть данных.

```jsx
const AppContext = React.createContext();

function App() {
  const [user, setUser] = useState({ name: 'John' });
  const [theme, setTheme] = useState('light');
  
  return (
    <AppContext.Provider value={{ user, theme, setUser, setTheme }}>
      <UserComponent />
      <ThemeComponent />
    </AppContext.Provider>
  );
}

function UserComponent() {
  const { user } = useContext(AppContext);
  return <div>{user.name}</div>; // ререндерится даже при изменении theme
}
```

**Решения:**
- Разделить на несколько контекстов (UserContext, ThemeContext)
- Использовать `useMemo`, `React.memo`
- Для частых обновлений — Redux или Zustand

#### 2. **Нет встроенных инструментов**

- Нет DevTools для отладки
- Нет middleware (логирование, асинхронность)
- Нет истории изменений (time-travel debugging)

#### 3. **Сложная логика**

Для сложных вычислений, нормализации данных, side-эффектов Context API недостаточно — нужна дополнительная библиотека (Redux, MobX).

---

## Redux

### Что это

**Redux** — библиотека для управления глобальным состоянием приложения с **предсказуемой архитектурой** (Flux-паттерн).

### Основные концепции

1. **Store** — единственный источник истины (single source of truth), хранит всё состояние
2. **Actions** — объекты, описывающие **что произошло** (`{ type: 'INCREMENT' }`)
3. **Reducers** — чистые функции, которые **как изменить** состояние на основе action
4. **Dispatch** — отправка action в store
5. **Selectors** — функции для чтения состояния

**Принципы:**
- **Single source of truth** — одно глобальное состояние
- **State is read-only** — нельзя изменить напрямую, только через dispatch
- **Changes via pure functions** — reducers всегда чистые

---

### Когда использовать Redux

- **Сложное состояние** — много взаимосвязанных данных, вычислений
- **Большие приложения** — десятки компонентов, сложная логика
- **Частые обновления** — оптимизирован для производительности
- **Нужны DevTools** — отладка, time-travel, логирование
- **Middleware** — логирование, асинхронность (redux-thunk, redux-saga), аналитика
- **Предсказуемость** — чёткая архитектура, легко тестировать

---

### Преимущества Redux

1. **Предсказуемость** — всегда понятно, как изменится состояние (чистые функции)
2. **DevTools** — Redux DevTools для отладки, просмотра истории, time-travel
3. **Middleware** — гибкая система для side-эффектов (thunk, saga, observable)
4. **Оптимизация** — только компоненты, зависящие от изменённых данных, ререндерятся (селекторы)
5. **Тестирование** — reducers и actions легко тестировать (чистые функции)
6. **Архитектура** — чёткая структура, легко масштабировать

---

### Недостатки Redux

1. **Boilerplate** — много кода (actions, reducers, constants)
   - Решение: **Redux Toolkit** (RTK) — официальный способ, сокращает код
2. **Сложность для новичков** — нужно понять концепции (actions, reducers, store)
3. **Избыточность для простых случаев** — если состояние простое, Context API достаточно

---

## Сравнение Redux и Context API

| Параметр | Context API | Redux |
|----------|-------------|-------|
| **Встроенность** | Встроен в React | Внешняя библиотека |
| **Простота** | Проще в использовании | Сложнее (больше концепций) |
| **Boilerplate** | Минимальный | Много (без RTK) |
| **Производительность** | Проблемы при частых обновлениях | Оптимизирован (селекторы) |
| **DevTools** | Нет | Redux DevTools |
| **Middleware** | Нет | Есть (thunk, saga) |
| **Тестирование** | Сложнее | Легко (чистые функции) |
| **Архитектура** | Гибкая (свободная) | Строгая (Flux-паттерн) |
| **Масштабируемость** | Для небольших приложений | Для больших приложений |
| **Time-travel** | Нет | Есть |
| **Использование** | Простое глобальное состояние | Сложное состояние, big apps |

---

## Когда использовать что

### Используй **Context API**, если:
- **Простое глобальное состояние** — тема, язык, пользователь
- **Редкие обновления** — данные меняются нечасто
- **Небольшое приложение** — несколько глобальных значений
- **Нет сложной логики** — нет middleware, side-эффектов
- **Быстрый старт** — не хочешь добавлять зависимости

### Используй **Redux**, если:
- **Сложное состояние** — много взаимосвязанных данных
- **Большое приложение** — десятки компонентов
- **Частые обновления** — данные меняются часто, нужна оптимизация
- **Нужны DevTools** — отладка, time-travel
- **Middleware** — асинхронность, логирование, аналитика
- **Команда** — нужна чёткая архитектура для совместной работы
- **Тестирование** — важна простота тестирования

---

## Гибридный подход

Можно комбинировать:
- **Redux** — для сложного состояния приложения (данные, бизнес-логика)
- **Context API** — для UI-состояния (тема, язык, модальные окна)

**Пример:**
- Redux: корзина, товары, пользователь, заказы
- Context: тема, язык, открытые модалки

---

## Альтернативы

Если Redux слишком сложен, а Context API недостаточно:
- **Zustand** — лёгкая библиотека, как Redux, но проще
- **Jotai** — атомарное состояние
- **Recoil** — от Meta, атомарное состояние
- **MobX** — реактивное состояние (observable)

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| В чём разница Redux и Context API? | Context — встроенный, для простого состояния; Redux — библиотека, для сложного состояния с DevTools и middleware |
| Когда использовать Context API? | Простое глобальное состояние (тема, язык), редкие обновления, небольшие приложения |
| Когда использовать Redux? | Сложное состояние, большие приложения, частые обновления, нужны DevTools/middleware |
| Почему Context API медленнее Redux? | При изменении контекста все подписанные компоненты ререндерятся; Redux использует селекторы |
| Можно ли использовать Context вместо Redux? | Да, для простых случаев; но для больших приложений Redux предпочтительнее |
| Что такое Redux Toolkit? | Официальный способ использования Redux, сокращает boilerplate |
| Можно ли комбинировать Context и Redux? | Да, Redux для бизнес-логики, Context для UI-состояния |

---

## Кратко для ответа

Context API — встроенный React-механизм для передачи данных без prop drilling, подходит для простого глобального состояния (тема, язык), но имеет проблемы с производительностью при частых обновлениях. Redux — библиотека для сложного состояния с предсказуемой архитектурой, DevTools, middleware, оптимизацией через селекторы; избыточен для простых случаев. Context — для маленьких приложений и простого состояния, Redux — для больших приложений и сложной логики.
