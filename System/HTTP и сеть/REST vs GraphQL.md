# REST vs GraphQL

## Краткий ответ для собеседования

**REST** — архитектурный стиль API: ресурсы по URL, операции через HTTP-методы (GET, POST, PUT, DELETE), ответы в фиксированном формате (часто JSON). **GraphQL** — язык запросов и спецификация: один endpoint, клиент описывает, какие поля и связи нужны, сервер возвращает только запрошенное. REST проще и кэшируется по URL; GraphQL гибче (один запрос — нужные данные), но сложнее кэшировать и ограничивать нагрузку.

---

## Что такое REST (напоминание)

**REST** — подход к проектированию API: ресурсы идентифицируются URI, операции — HTTP-методами. Один URL — один тип ресурса (или конкретный экземпляр). Формат ответа задаётся сервером (часто один JSON-шаблон на ресурс). Клиент получает то, что сервер решил отдать для этого endpoint.

**Плюсы:** привычно, легко кэшировать по URL, простота реализации и потребления для стандартных CRUD.

**Минусы:** нередко overfetching (лишние поля) или underfetching (нужно несколько запросов для одного экрана); эволюция API через новые версии URL или полей.

---

## Что такое GraphQL

**GraphQL** — спецификация языка запросов и выполнения: клиент отправляет **запрос** с описанием нужных полей и связей, сервер возвращает JSON только с этими полями. Обычно один HTTP endpoint (например, POST /graphql), а «что именно нужно» передаётся в теле запроса.

**Идея:** клиент сам формулирует форму ответа — меньше лишних данных и меньше круглых поездок (один запрос вместо нескольких REST-вызовов).

---

## Основные отличия

| Критерий | REST | GraphQL |
|----------|------|---------|
| **Endpoint** | Много URL (по ресурсам и действиям) | Один (как правило) |
| **Что запрашивать** | Определяет сервер (фиксированные ответы по URL) | Определяет клиент (поля в запросе) |
| **Запрос** | Метод + URL + query/body | Текст запроса (query, variables) |
| **Ответ** | Формат задан сервером | Формат следует запросу клиента |
| **Кэширование** | По URL (просто) | Сложнее (нет «один URL = один ресурс») |
| **Версионирование** | Новые URL или поля | Новые поля, устаревание полей (deprecation) |
| **Типизация** | Опционально (OpenAPI и т.д.) | Схема и типы из коробки |

---

## Плюсы REST

- Привычная модель: ресурсы, методы, статусы. Легко объяснить и документировать.
- Кэширование по URL: браузер, CDN и прокси кэшируют GET по URI.
- Простая реализация для CRUD и стандартных сценариев.
- Меньше «магии»: один запрос — один тип ответа с предсказуемой структурой.

---

## Минусы REST

- **Overfetching:** ответ содержит все поля ресурса, даже если нужны два.
- **Underfetching:** для одного экрана часто нужно несколько запросов (пользователь, заказы, настройки) — лишние круглые поездки и усложнение клиента.
- Эволюция API: новые версии (v2, новые поля) требуют договорённостей и иногда дублирования endpoint.

---

## Плюсы GraphQL

- **Точно запрошенные данные:** клиент перечисляет поля — нет лишнего (меньше overfetching).
- **Один запрос на экран:** можно запросить пользователя, его заказы и настройки одним запросом (меньше underfetching и круглых поездок).
- Схема и типы: контракт API описан в схеме, удобно для инструментов и типизации на клиенте.
- Гибкая эволюция: новые поля и deprecation старых без смены URL.

---

## Минусы GraphQL

- Кэширование сложнее: нет естественного «один URL = один ресурс»; нужны нормализованный кэш на клиенте (например, Apollo) и аккуратность с кэшем на сервере.
- Риск тяжёлых запросов: клиент может запросить глубокие/широкие связи — нужны лимиты, пагинация, анализ сложности запроса (query complexity).
- Сложнее реализация и отладка: резолверы, N+1, права доступа по полям.
- Не все операции укладываются в «запрос данных» — мутации есть, но файлы, подписки и т.д. часто делают поверх HTTP или отдельно.

---

## Когда что выбирать

**REST** — классические CRUD, простые интеграции, важность кэширования по URL, команда привычна к REST.

**GraphQL** — сложные клиенты (много экранов и связей), желание уменьшить количество запросов и объём данных, нужна единая типизированная схема и гибкая эволюция API без смены URL.

**Гибрид:** основной API на REST, часть сценариев (сложные дашборды, мобильное приложение) — через GraphQL.

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| В чём разница REST и GraphQL? | REST — много URL, ответ задаёт сервер; GraphQL — один endpoint, форму ответа задаёт клиент в запросе. |
| Что такое overfetching? | Получение лишних полей в ответе; в GraphQL клиент запрашивает только нужные поля. |
| Что такое underfetching? | Нехватка данных в одном ответе, нужны несколько запросов; GraphQL позволяет собрать всё в один запрос. |
| Как кэшировать GraphQL? | Нет кэша по URL; используют нормализованный кэш на клиенте (по типу и id) и осторожно на сервере. |
| Минусы GraphQL? | Сложнее кэш, риск тяжёлых запросов, сложнее реализация и контроль нагрузки. |

---

## Кратко для ответа

REST — ресурсы по URL, операции методами HTTP, ответ в фиксированном формате; просто и удобно кэшировать. GraphQL — один endpoint, клиент запрашивает нужные поля и связи, меньше overfetching и underfetching; сложнее кэширование и защита от тяжёлых запросов. Выбор зависит от сложности клиента, требований к кэшу и готовности поддерживать GraphQL-сервер.
