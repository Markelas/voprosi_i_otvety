# Версии HTTP (HTTP/1.1, HTTP/2, HTTP/3)

## Краткий ответ для собеседования

**HTTP/1.1** (1997): одно соединение = один запрос, head-of-line blocking, текстовый протокол. **HTTP/2** (2015): мультиплексирование (много запросов через одно соединение), бинарный, сжатие заголовков, server push. **HTTP/3** (2022): на основе QUIC (UDP), быстрее установка соединения, нет head-of-line blocking на уровне TCP, лучше для мобильных сетей.

---

## HTTP/1.1 (1997)

### Основные характеристики

- **Текстовый протокол** — заголовки и тело в plain text
- **Одно соединение = один запрос** — для параллелизма нужно несколько соединений
- **Keep-Alive** — переиспользование соединения для нескольких запросов

### Ограничения

#### 1. Head-of-Line Blocking

Запросы выполняются **последовательно** через одно соединение — если первый медленный, остальные ждут.

```
Соединение 1: |----Request 1----|----Request 2----|
                   ↑ Если медленный, Request 2 ждёт
```

#### 2. Множество соединений

Браузеры открывают **6-8 соединений** на домен для параллелизма → накладные расходы (TCP handshake, TLS handshake).

#### 3. Избыточные заголовки

Заголовки отправляются с каждым запросом **без сжатия** → лишний трафик.

#### 4. Нет приоритизации

Все запросы равны — нельзя указать, что важнее.

---

## HTTP/2 (2015)

### Основные улучшения

#### 1. Мультиплексирование

**Множество запросов через одно TCP-соединение** — параллельная передача, нет блокировки.

```
Соединение 1: |--Req 1--|--Req 2--|--Req 3--| (параллельно)
```

#### 2. Бинарный протокол

Данные передаются в **бинарном формате** (фреймы) вместо текста → быстрее парсинг, меньше ошибок.

#### 3. Сжатие заголовков (HPACK)

Заголовки сжимаются алгоритмом **HPACK** → меньше трафика.

**Пример:**  
Первый запрос: `User-Agent: Mozilla/5.0...` (полный заголовок)  
Второй запрос: `:path: /page2` (только изменения, остальное из кэша)

#### 4. Server Push

Сервер может **отправить ресурсы без запроса** клиента.

**Пример:**  
Клиент запрашивает `index.html` → сервер сразу отправляет `style.css` и `script.js`.

#### 5. Приоритизация запросов

Клиент может указать **приоритет** запросов — важные загружаются первыми.

---

### Проблемы HTTP/2

#### Head-of-Line Blocking на уровне TCP

Хотя мультиплексирование решает проблему на уровне HTTP, **TCP всё ещё блокирует**:
- Если один TCP-пакет потерян → все HTTP/2-запросы ждут его повторной отправки

---

## HTTP/3 (2022)

### Основной изменения

#### 1. QUIC вместо TCP

**HTTP/3 работает на UDP + QUIC** (Quick UDP Internet Connections).

**QUIC:**
- Основан на UDP (не требует установки соединения)
- Встроенное TLS 1.3 (шифрование из коробки)
- Мультиплексирование **без head-of-line blocking**

#### 2. Быстрая установка соединения

**0-RTT или 1-RTT** вместо 2-3 RTT в HTTP/2 (TCP + TLS handshake).

**HTTP/2 (TCP + TLS):**
```
TCP handshake: SYN → SYN-ACK → ACK (1 RTT)
TLS handshake: Client Hello → Server Hello (1-2 RTT)
Итого: 2-3 RTT
```

**HTTP/3 (QUIC):**
```
QUIC handshake + TLS: 0-1 RTT
```

→ Быстрее на 100-200ms.

#### 3. Нет Head-of-Line Blocking

Каждый HTTP/3-поток **независим** — потеря пакета в одном потоке не блокирует другие.

```
TCP (HTTP/2): Потеря пакета → все потоки ждут
UDP (HTTP/3): Потеря пакета → только один поток ждёт
```

#### 4. Лучше для мобильных сетей

**Connection migration** — если пользователь переключается с Wi-Fi на мобильную сеть, соединение **не рвётся** (в HTTP/2 нужно новое соединение).

#### 5. Встроенное шифрование

QUIC включает TLS 1.3 по умолчанию — нельзя использовать HTTP/3 без шифрования.

---

## Сравнение

| Параметр | HTTP/1.1 | HTTP/2 | HTTP/3 |
|----------|----------|--------|--------|
| **Год** | 1997 | 2015 | 2022 |
| **Протокол** | TCP | TCP | UDP (QUIC) |
| **Формат** | Текстовый | Бинарный | Бинарный |
| **Мультиплексирование** | ❌ Нет | ✅ Да | ✅ Да |
| **Head-of-Line Blocking** | ✅ Да (HTTP) | ⚠️ Да (TCP) | ❌ Нет |
| **Сжатие заголовков** | ❌ Нет | ✅ HPACK | ✅ QPACK |
| **Server Push** | ❌ Нет | ✅ Да | ⚠️ Да (редко используется) |
| **Приоритизация** | ❌ Нет | ✅ Да | ✅ Да |
| **Установка соединения** | 3 RTT | 2-3 RTT | 0-1 RTT |
| **Connection migration** | ❌ Нет | ❌ Нет | ✅ Да |
| **Шифрование** | Опционально (HTTPS) | Опционально | ✅ Обязательно |

---

## Практическое влияние

### HTTP/1.1 → HTTP/2

- **Убрать domain sharding** — не нужно, мультиплексирование решает проблему
- **Меньше соединений** — всё через одно
- **Быстрее загрузка** — параллелизм, сжатие заголовков

### HTTP/2 → HTTP/3

- **Быстрее на слабых сетях** — меньше задержек, нет блокировок
- **Лучше для мобильных** — connection migration
- **Меньше задержек** — 0-1 RTT вместо 2-3 RTT

---

## Поддержка браузеров

- **HTTP/2:** все современные браузеры (>95% пользователей)
- **HTTP/3:** Chrome, Edge, Firefox, Safari (поддержка растёт)

**Проверить:** `chrome://net-internals/#http2` (HTTP/2), `chrome://flags/#enable-quic` (HTTP/3)

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| В чём разница HTTP/1.1 и HTTP/2? | HTTP/2: мультиплексирование, бинарный, сжатие заголовков, server push |
| Что такое мультиплексирование? | Множество запросов через одно соединение параллельно |
| Что такое Head-of-Line Blocking? | Блокировка запросов из-за медленного первого запроса |
| Решён ли HOL в HTTP/2? | Частично — на уровне HTTP да, но на уровне TCP нет |
| В чём разница HTTP/2 и HTTP/3? | HTTP/3 на UDP (QUIC), быстрее установка (0-1 RTT), нет HOL на TCP, connection migration |
| Зачем QUIC? | Быстрее, нет HOL, connection migration, встроенное шифрование |
| Нужен ли domain sharding для HTTP/2? | Нет, мультиплексирование решает проблему |

---

## Кратко для ответа

**HTTP/1.1** — одно соединение = один запрос, head-of-line blocking, текстовый. **HTTP/2** — мультиплексирование (много запросов через одно соединение), бинарный, сжатие заголовков, server push; но HOL на TCP. **HTTP/3** — на UDP (QUIC), быстрее установка (0-1 RTT), нет HOL, connection migration, обязательное шифрование.
