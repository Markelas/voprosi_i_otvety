# Что такое JWT токен

## Краткий ответ для собеседования

**JWT (JSON Web Token)** — компактный способ передавать данные между сторонами в виде строки из трёх частей (Header.Payload.Signature). Данные в Header и Payload — в Base64URL, **не зашифрованы**, а **подписаны**. Сервер проверяет подпись и поля вроде `exp`/`iat`. Используется для **аутентификации** (access token) и часто вместе с **refresh token** для обновления без повторного ввода пароля.

---

## Что такое JWT

**JWT (JSON Web Token)** — открытый стандарт (RFC 7519) для передачи **утверждений (claims)** между клиентом и сервером в виде компактной строки.

**Основное применение:** аутентификация и авторизация — клиент после входа получает токен и при каждом запросе отправляет его серверу, чтобы доказать, что он тот же пользователь.

---

## Структура JWT

JWT — это **строка из трёх частей**, разделённых точками:

```
Header.Payload.Signature
```

**Пример:**

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4iLCJpYXQiOjE2MTYyMzkwMjJ9.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

Каждая часть — **Base64URL** (Base64 без `+`, `/`, с заменой на `-`, `_` и без `=` в конце).

---

### 1. Header (заголовок)

**Содержимое:** JSON с метаданными токена.

**Типичные поля:**

| Поле | Описание | Пример |
|------|----------|--------|
| **alg** | Алгоритм подписи | `HS256`, `RS256` |
| **typ** | Тип токена | `JWT` |

**Пример (после декодирования Base64URL):**

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

---

### 2. Payload (полезная нагрузка)

**Содержимое:** JSON с **утверждениями (claims)** — данными, которые одна сторона заявляет о пользователе или о самом токене.

**Стандартные (зарезервированные) claims:**

| Claim | Описание | Пример |
|-------|----------|--------|
| **sub** | Subject — идентификатор пользователя (кого касается токен) | `"user-123"` |
| **iss** | Issuer — кто выдал токен | `"https://auth.example.com"` |
| **aud** | Audience — для кого предназначен | `"https://api.example.com"` |
| **exp** | Expiration — время истечения (Unix timestamp) | `1616239122` |
| **iat** | Issued At — время выдачи | `1616235522` |
| **nbf** | Not Before — не принимать до этого времени | `1616235522` |
| **jti** | JWT ID — уникальный идентификатор токена (для чёрных списков и т.п.) | `"abc-123"` |

**Свои (custom) claims:** любые другие поля, например `role`, `email`, `name`. Не стоит класть пароли и другую чувствительную информацию — payload читается любым, кто видит токен (Base64URL декодируется без секрета).

**Пример payload:**

```json
{
  "sub": "user-123",
  "email": "user@example.com",
  "role": "admin",
  "iat": 1616235522,
  "exp": 1616321922
}
```

---

### 3. Signature (подпись)

**Назначение:** убедиться, что токен не меняли после выдачи.

**Как считается:**  
Берётся строка `Base64URL(Header).Base64URL(Payload)`, к ней применяется алгоритм из `Header.alg` с использованием **секрета** (при симметричном алгоритме) или **приватного ключа** (при асимметричном). Результат кодируется в Base64URL — это и есть Signature.

**Симметричный алгоритм (HS256):**  
Один и тот же секрет у того, кто подписывает, и у того, кто проверяет. Подпись: `HMAC-SHA256(Header.Payload, secret)`.

**Асимметричный алгоритм (RS256):**  
Приватный ключ только у издателя, публичный ключ — у проверяющего. Подпись: `RSA-SHA256(Header.Payload, privateKey)`. Проверка — публичным ключом. Удобно, когда токен проверяет не тот сервис, который его выдал (микросервисы, несколько приложений).

**Важно:**  
Если кто-то изменит Header или Payload и пересчитает подпись без знания секрета/приватного ключа, проверка на сервере не пройдёт — токен считается недействительным.

---

## Подпись, а не шифрование

- **Payload и Header не шифруются** — их можно прочитать, просто декодировав Base64URL.
- **Signature** не даёт подделать или изменить содержимое: без секрета/приватного ключа корректную подпись создать нельзя.
- **Не храните в JWT пароли, платёжные данные и т.п.** — только идентификаторы, роли, время жизни и т.д.

---

## Access Token и Refresh Token

Часто используют **два типа** токенов:

### Access Token (JWT)

- **Назначение:** доказать личность при каждом запросе к API.
- **Короткий срок жизни** (минуты, часы) — чтобы украденный токен был полезен недолго.
- Отправляется клиентом в заголовке: `Authorization: Bearer <access_token>`.

### Refresh Token

- **Назначение:** получить новый access token без повторного ввода пароля.
- **Длинный срок жизни** (дни, недели) или до явного выхода.
- Хранится безопасно (часто HttpOnly cookie) и отправляется только на специальный endpoint обновления токена.
- Сервер выдаёт новую пару access + refresh (или только access), старый refresh при этом может инвалидироваться.

**Типичный сценарий:**  
Access истёк → клиент отправляет refresh token на `/refresh` → сервер проверяет и возвращает новый access (и при необходимости новый refresh).

---

## Как работает JWT-аутентификация (по шагам)

1. Пользователь отправляет логин и пароль на сервер (например, `POST /login`).
2. Сервер проверяет учётные данные, при успехе формирует JWT (Header + Payload + Signature) и, при необходимости, refresh token.
3. Сервер отдаёт токены клиенту (в теле ответа и/или в cookie).
4. Клиент сохраняет access token (и refresh — см. раздел про хранение) и при запросах к API добавляет access в заголовок `Authorization: Bearer <token>`.
5. Сервер (или API Gateway) извлекает токен из заголовка, проверяет подпись, смотрит `exp` (и при необходимости `iss`, `aud`). Если всё ок — считает пользователя аутентифицированным и обрабатывает запрос.
6. Если access истёк, клиент использует refresh token для получения нового access (и при необходимости повторяет запрос с новым токеном).

---

## Где хранить JWT и Refresh Token

| Что | Где хранить | Плюсы | Минусы / Риски |
|-----|-------------|--------|----------------|
| **Access Token** | Память (переменная в JS) или Session Storage | Не переживает закрытие вкладки, сложнее украсть скриптом с другой вкладки | Пропадает при перезагрузке страницы (если только в памяти) |
| **Access Token** | Session Storage | Переживает перезагрузку в рамках одной вкладки | Доступен любому JS на странице → уязвим к XSS |
| **Refresh Token** | HttpOnly Cookie | JS не видит cookie → сложнее украсть через XSS | Нужна защита от CSRF (SameSite, проверка источника) |
| **Оба в cookie** | HttpOnly + Secure cookie | Удобно для SSR, единый механизм | Нужна корректная настройка домена, путей, SameSite |
| **Не рекомендуется** | Local Storage | Удобно, не пропадает | Легко украсть через XSS; использовать только при осознанных рисках и коротком времени жизни access |

**Практика:**  
Access — в памяти или Session Storage; Refresh — в HttpOnly cookie с `Secure` и `SameSite=Strict` (или Lax). Либо оба в cookie с разными сроками жизни и флагами.

---

## Как передавать токен на сервер

**Чаще всего:** заголовок `Authorization`:

```
Authorization: Bearer <JWT>
```

Сервер читает значение после `Bearer ` и проверяет JWT.

**Альтернатива:** cookie. Токен устанавливается сервером через `Set-Cookie`, браузер отправляет его с каждым запросом на заданный домен/путь. Для защиты: `HttpOnly`, `Secure`, `SameSite`.

---

## Проверка JWT на сервере

1. Извлечь строку токена из заголовка (или cookie).
2. Разбить на три части по точке; убедиться, что части в Base64URL.
3. Проверить подпись (HMAC с секретом для HS256 или RSA с публичным ключом для RS256).
4. Декодировать Payload, проверить `exp` (и при необходимости `nbf`, `iss`, `aud`).
5. Использовать `sub` (и при необходимости другие claims) для идентификации пользователя и авторизации.

**Важно:** не доверять содержимому Payload до проверки подписи — иначе клиент может подделать токен.

---

## Безопасность: что учитывать

- **XSS:** если токен доступен JS (localStorage, обычная cookie), скрипт может его украсть. Минимизировать XSS (CSP, санитизация) и/или хранить access в памяти, refresh — в HttpOnly cookie.
- **CSRF:** если токен в cookie, запросы с других сайтов могут нести cookie. Защита: `SameSite=Strict` (или Lax), при необходимости CSRF-токены для критичных операций.
- **Короткий срок жизни access token** — уменьшает окно, когда украденный токен пригоден.
- **Refresh token rotation** — при каждом обновлении выдавать новый refresh и инвалидировать старый, чтобы украденный refresh быстро перестал работать.
- Не хранить в JWT секреты и чувствительные персональные данные — только необходимый минимум для идентификации и авторизации.

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Что такое JWT? | Компактный формат передачи утверждений (claims) в виде строки Header.Payload.Signature; используется для аутентификации. |
| Из чего состоит JWT? | Header (alg, typ), Payload (claims), Signature; каждая часть в Base64URL. |
| JWT шифрует данные? | Нет, только подписывает. Payload можно прочитать; изменить нельзя без знания секрета/ключа. |
| Что такое exp и iat? | exp — время истечения токена, iat — время выдачи (Unix timestamp). |
| Зачем нужен refresh token? | Чтобы получать новый access token без повторного ввода пароля; хранится безопаснее и дольше. |
| Где хранить access token? | В памяти или Session Storage; не рекомендуется localStorage из-за XSS. |
| Где хранить refresh token? | Часто в HttpOnly cookie — недоступен для JS, меньше риска при XSS. |
| Как передать JWT на сервер? | В заголовке `Authorization: Bearer <token>` или в cookie. |
| В чём разница HS256 и RS256? | HS256 — симметричная подпись (один секрет), RS256 — асимметричная (приватный ключ у издателя, публичный у проверяющего). |

---

## Кратко для ответа

JWT — строка из трёх частей (Header.Payload.Signature) в Base64URL; данные не шифруются, а подписываются. Payload содержит claims (sub, exp, iat и др.). Сервер проверяет подпись и срок действия. Используется как access token; вместе с refresh token — для обновления без повторного ввода пароля. Access передаётся в `Authorization: Bearer <token>`; хранить предпочтительно в памяти или Session Storage, refresh — в HttpOnly cookie с учётом защиты от CSRF.
