# Подходы к аутентификации и авторизации

## Краткий ответ для собеседования

Основные подходы: **сессии (session-based)** — сервер хранит сессию, клиент передаёт идентификатор в cookie; **токены (token-based)** — клиент получает токен (часто JWT) после входа и отправляет его в заголовке при запросах; **OAuth 2.0 / OpenID Connect** — вход через стороннего провайдера («Войти через Google»), клиент получает access token и опционально refresh token; **API-ключи** — статичный ключ в заголовке или query для доступа к API (часто для сервисов, не для конечных пользователей). Для фронта важно: где хранить токен (память, cookie, localStorage), как отправлять (Cookie автоматически, Authorization header), как обновлять (refresh token) и как обрабатывать истечение и 401. См. [[Идентификация, аутентификация, авторизация]], [[Что такое JWT токен]].

---

## Зачем различать подходы

Разные системы используют разные механизмы «проверить, кто пользователь» и «разрешить доступ». Фронтенд должен знать: что отправлять с запросом (cookie, заголовок с токеном), где хранить учётные данные на клиенте, как обрабатывать истечение сессии или токена и редирект на логин. На собеседовании часто спрашивают про отличия сессий и JWT, про OAuth и про то, где безопаснее хранить токен.

---

## 1. Сессии (session-based)

### Суть

Пользователь логинится (логин + пароль). Сервер проверяет данные, **создаёт сессию** (запись на сервере: id сессии, user id, срок жизни) и отправляет клиенту **идентификатор сессии** — обычно в **cookie** (например, `sessionId=abc123`). Cookie помечается как HttpOnly, Secure, при необходимости SameSite. При следующих запросах браузер **автоматически** отправляет эту cookie. Сервер по идентификатору находит сессию, узнаёт пользователя и решает, разрешать ли доступ.

### Где что хранится

- **Сервер** — хранит сессию (в памяти, в Redis, в БД). В сессии: кто пользователь, когда истекёт, при необходимости — дополнительные данные.
- **Клиент** — только идентификатор сессии в cookie. Не пароль, не полный профиль; только «билетик», по которому сервер находит сессию.

### Плюсы

- Сервер полностью контролирует сессию: может инвалидировать её в любой момент (выход, смена пароля, админ отключил пользователя).
- Токен не уезжает в JS (если cookie HttpOnly) — сложнее украсть через XSS.
- Фронту не нужно вручную подставлять токен в каждый запрос — браузер отправляет cookie сам.

### Минусы

- Нужно хранить сессии на сервере (или в Redis и т.п.) — масштабирование и отказоустойчивость.
- Запросы к защищённым ресурсам должны идти на тот же домен (или правильно настроены cookie и CORS), чтобы cookie уходила.

### Что важно фронтенду

- При запросах к API с того же домена cookie уходит сама; с другого домена нужно разрешать отправку cookie (credentials: include) и правильные CORS и cookie-настройки на бэкенде.
- Выход — обычно запрос на сервер «завершить сессию»; сервер удаляет сессию и клиент по желанию удаляет cookie.
- Истечение: сервер возвращает 401 или редирект на логин; фронт перенаправляет пользователя на страницу входа.

---

## 2. Токены (token-based), в том числе JWT

### Суть

После успешного входа сервер **не создаёт сессию у себя**, а выдаёт клиенту **токен** — строку, в которой закодированы данные (например, user id, роли, срок действия). Клиент **сам хранит** этот токен (в памяти, localStorage, или в cookie) и при каждом запросе к API **передаёт его** серверу — обычно в заголовке `Authorization: Bearer <token>`. Сервер **проверяет токен** (подпись у JWT, или запрос в БД/сервис для непрозрачного токена) и по нему определяет пользователя и права.

Подробнее про формат и устройство JWT: [[Что такое JWT токен]].

### Где что хранится

- **Сервер** — не хранит «сессию» по токену (при чистом JWT). Хранит секрет или публичный ключ для проверки подписи. При непрозрачном токене (opaque) — может хранить список выданных токенов или только проверять подпись.
- **Клиент** — хранит сам токен. Варианты: память (переменная в JS) — пропадает при закрытии вкладки; localStorage — сохраняется между сессиями, но доступен любому JS (риск XSS); cookie (если сервер отдаёт токен в cookie) — можно HttpOnly, тогда JS не видит.

### Плюсы

- Серверу не нужно хранить сессию — проще масштабировать, меньше состояние на бэкенде.
- Удобно для API, к которым обращаются с разных доменов или с мобильного приложения: токен просто передаётся в заголовке.
- В JWT можно заложить роли и права (claims) — сервер проверяет подпись и читает данные из токена.

### Минусы

- Пока токен действителен, его нельзя «отозвать» централизованно (если сервер не ведёт чёрный список). Обычно делают короткоживущий access token и refresh token для обновления.
- Если хранить токен в localStorage, он доступен любому скрипту — при XSS токен могут украсть. HttpOnly cookie безопаснее для хранения, но тогда нужна поддержка со стороны бэкенда и аккуратная настройка CORS/cookie.

### Что важно фронтенду

- **Где хранить:** память — максимально безопасно от XSS, но пропадает при перезагрузке; localStorage — удобно, но уязвимо при XSS; cookie (HttpOnly) — безопаснее, но настройка сложнее. На собеседовании можно сказать: «предпочтительно не хранить токен в localStorage при риске XSS, лучше память или HttpOnly cookie».
- **Как отправлять:** заголовок `Authorization: Bearer <token>` при каждом запросе к защищённому API.
- **Refresh token:** если access token короткоживущий, при 401 фронт может отправить refresh token, получить новую пару и повторить запрос; refresh token хранится надёжнее и реже отправляется.
- **Выход:** на клиенте удалить токен; при необходимости отправить запрос «инвалидировать refresh token» на сервер.

---

## 3. OAuth 2.0 и OpenID Connect

### Суть

Пользователь входит **не паролем к вашему серверу**, а через **внешнего провайдера** (Google, GitHub, «Войти через ВКонтакте»). Ваше приложение не видит пароль пользователя — провайдер сам аутентифицирует пользователя и сообщает вашему приложению: «это такой-то пользователь, вот токен доступа». Так реализуется **делегированная авторизация**: пользователь разрешает вашему приложению получить ограниченный доступ к его данным у провайдера (профиль, email) или просто «подтвердить личность».

**OAuth 2.0** — протокол, как получать **токен доступа** к ресурсам пользователя у провайдера. **OpenID Connect (OIDC)** — надстройка над OAuth 2.0, которая добавляет стандартный способ получить **информацию о пользователе** (id, email и т.д.) и аутентифицировать его.

### Как это выглядит для пользователя и фронта

1. Пользователь нажимает «Войти через Google».
2. Фронт перенаправляет на страницу входа провайдера (Google) с параметрами (client_id, redirect_uri, scope).
3. Пользователь вводит пароль у провайдера и разрешает доступ.
4. Провайдер перенаправляет обратно на ваш сайт (redirect_uri) с **кодом** (authorization code) в URL.
5. Фронт отправляет код на **ваш бэкенд**; бэкенд обменивает код на **access token** (и при OIDC — id_token с данными пользователя) у провайдера. Бэкенд не отдаёт код и токены провайдера во фронт «как есть» — обычно ваш бэкенд создаёт **свою сессию или свои JWT** и отдаёт их клиенту.
6. Дальше пользователь работает с вашим API уже по вашей сессии или вашему токену.

Фронт участвует в редиректах и передаче кода на бэкенд; обмен код → токен и хранение токенов провайдера делается на бэкенде из соображений безопасности.

### Зачем

- Пользователю не нужно заводить новый пароль у вас — меньше барьер входа.
- Вы не храните пароли — меньше ответственности и риска утечки.
- Можно запрашивать доступ к данным провайдера (календарь, контакты) по согласию пользователя.

### Что важно фронтенду

- Реализовать редирект на провайдера с нужными параметрами и приём ответа по redirect_uri (извлечь код из URL и отправить на бэкенд).
- Не хранить и не светить токены провайдера во фронте — после обмена код → токен пользователь получает вашу сессию или ваш JWT, с ними и работаете.
- Понимать разницу: OAuth 2.0 — «получить доступ к ресурсам»; OIDC — «узнать, кто пользователь» (аутентификация через провайдера).

---

## 4. API-ключи (API keys)

### Суть

Для доступа к API передаётся **статичный ключ** — длинная строка, выданная заранее. Ключ передаётся в заголовке (например, `X-API-Key` или `Authorization: ApiKey <key>`) или реже в query-параметре. Сервер проверяет ключ и решает, разрешить ли запрос. Часто привязан не к «пользователю-человеку», а к приложению, сервису или аккаунту разработчика.

### Где используется

- Публичные API (погода, карты, платёжные шлюзы): ключ выдаётся после регистрации, лимиты и тарификация по ключу.
- Сервис-сервис: один бэкенд вызывает другой по API-ключу.
- Простые сценарии админки или внутренних инструментов.

### Что важно фронтенду

- **Не класть API-ключи во фронт**, если они дают доступ к платным или чувствительным ресурсам: код фронта доступен всем, ключ украдут. Такие ключи должны жить на бэкенде; фронт вызывает ваш бэкенд, а бэкенд — внешний API с ключом.
- Если ключ всё же на фронте (например, ограниченный публичный ключ карт), использовать ограничения по домену/рефереру на стороне сервиса и не считать ключ секретом.

---

## 5. Basic Auth (базовая аутентификация)

### Суть

Логин и пароль кодируются в Base64 и передаются в заголовке `Authorization: Basic <base64(login:password)>` при каждом запросе. Сервер декодирует и проверяет.

### Где используется

- Простые внутренние инструменты, тестовые стенды.
- Некоторые API (часто вместе с HTTPS).

### Минусы

- Пароль уходит с каждым запросом; при перехвате трафика (если не HTTPS) виден пароль. При HTTPS — лучше, но передавать пароль каждый раз нежелательно.
- Неудобно для пользователей: браузер может запомнить пароль, но управление сессией и выход примитивны.

Для современных веб-приложений с пользователями обычно используют сессии или токены (JWT), а не Basic Auth. Фронту достаточно знать, что такой вариант есть и что пароль при нём не должен светиться в открытом виде.

---

## Сравнение подходов (кратко)

| Подход | Кто аутентифицирует | Что хранит клиент | Что проверяет сервер |
|--------|----------------------|-------------------|------------------------|
| **Сессии** | Ваш сервер (логин/пароль) | Id сессии в cookie | Сессию по id в хранилище |
| **JWT / токены** | Ваш сервер (логин/пароль) | Access token (и опц. refresh) | Подпись токена, claims, exp |
| **OAuth 2.0 / OIDC** | Провайдер (Google и т.д.) | Вашу сессию или ваш токен после обмена | Свою сессию или свой токен; код обменивает бэкенд |
| **API-ключ** | Владелец ключа | Ключ (лучше не во фронте) | Валидность ключа |
| **Basic Auth** | Ваш сервер | — (пароль в заголовке) | Логин/пароль из заголовка |

---

## Что ответить на собеседовании

- **Сессии** — сервер хранит сессию, клиент шлёт id в cookie; сервер может в любой момент отозвать; фронт не управляет токеном вручную.
- **Токены (JWT)** — клиент хранит токен, шлёт в Authorization; сервер не хранит сессию, проверяет подпись; важно где хранить (память / cookie предпочтительнее localStorage при риске XSS), refresh token для обновления.
- **OAuth / OIDC** — вход через провайдера, редиректы, код обменивается на токен на бэкенде; фронт работает уже с нашей сессией/токеном.
- **API-ключи** — для сервисов и API; секретные ключи не во фронте.
- **Фронт:** куда класть токен, как отправлять (cookie автоматически, Bearer в заголовке), как обрабатывать 401 и refresh, не светить секреты.

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Какие подходы к аутентификации знаешь? | Сессии (cookie), токены (JWT), OAuth 2.0 / OIDC, API-ключи, Basic Auth. |
| Чем сессия отличается от JWT? | Сессия: id в cookie, состояние на сервере, можно отозвать. JWT: токен у клиента, сервер только проверяет подпись, без состояния; отзыв сложнее, обычно короткий access + refresh. |
| Где хранить JWT на фронте? | Предпочтительно в памяти или HttpOnly cookie; localStorage уязвим к XSS. |
| Что такое OAuth 2.0? | Протокол делегированного доступа: вход через провайдера (Google и т.д.), приложение получает токен доступа к ресурсам пользователя у провайдера. |
| Почему API-ключ не кладут во фронт? | Код фронта доступен всем; ключ украдут и будут использовать от вашего имени. Секретные ключи — только на бэкенде. |

---

## Кратко для ответа

**Подходы:** сессии (cookie, состояние на сервере), токены/JWT (клиент хранит, Authorization header, без состояния на сервере), OAuth 2.0 / OIDC (вход через провайдера, код обменивает бэкенд), API-ключи (для API/сервисов, не во фронте), Basic Auth (логин/пароль в заголовке, редко для веб-приложений). Фронту важно: где хранить токен, как отправлять, обработка 401 и refresh, не хранить секреты в открытом виде. См. [[Идентификация, аутентификация, авторизация]], [[Что такое JWT токен]].
