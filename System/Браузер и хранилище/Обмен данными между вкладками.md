# Обмен данными между вкладками в браузере

## Краткий ответ для собеседования

Обмениваться данными между вкладками одного **origin** (домен + протокол + порт) можно несколькими способами: **1) localStorage + событие storage** — одна вкладка пишет в localStorage, остальные получают событие `storage` (без данных об инициаторе); **2) BroadcastChannel API** — канал по имени, все вкладки с тем же каналом получают сообщения; **3) SharedWorker** — один воркер общий для вкладок, вкладки подключаются к нему и обмениваются сообщениями через него; **4) Service Worker** — вкладки (clients) могут слать сообщения в SW, SW рассылает их остальным clients; **5) cookie + опрос** — редко, т.к. объём мал и нужен polling. На собеседовании: назвать способы, чем отличаются, когда что использовать.

---

## Важно: один origin

Все перечисленные способы работают **только между вкладками одного origin** (одинаковые схема, хост и порт). Передать данные между вкладками разных доменов средствами браузера напрямую нельзя — только через сервер (например, общий бэкенд или WebSocket с авторизацией).

---

## 1. localStorage + событие `storage`

**Суть:** Одна вкладка записывает данные в **localStorage** (или удаляет ключ). Остальные вкладки того же origin получают событие **storage** — в нём приходят ключ, старое и новое значение. Вкладка, которая записала, **не получает** это событие у себя (только другие вкладки).

**Как использовать:** Подписаться на `window.addEventListener('storage', handler)`. В handler — ключ, newValue, oldValue. Для передачи произвольных данных обычно кладут в один ключ JSON-строку и парсят в другой вкладке.

**Плюсы:** просто, не нужен сервер, поддерживается везде.  
**Минусы:** только строка; событие не приходит в той вкладке, которая записала; при большом объёме данных localStorage может быть неудобен (лимит ~5–10 МБ).

**Когда использовать:** синхронизация настроек, темы, простых флагов между вкладками.

---

## 2. BroadcastChannel API

**Суть:** Создаётся **канал** с именем (строка). Любая вкладка может открыть канал с тем же именем и вызывать **postMessage(data)**. Все вкладки, подписанные на этот канал, получают сообщение, в том числе отправитель (в отличие от storage).

**Как использовать:** `new BroadcastChannel('имя-канала')`, метод **postMessage(data)** для отправки, событие **onmessage** для приёма. Данные сериализуются (structured clone) — можно объекты, но не функции и не DOM-узлы.

**Плюсы:** явный канал по имени, двунаправленная связь, отправитель тоже получает событие при необходимости, простой API.  
**Минусы:** не поддерживается в старых Safari (до 15.4) и части старых браузеров.

**Когда использовать:** уведомления между вкладками, синхронизация состояния, когда нужна именно «рассылка по каналу».

---

## 3. SharedWorker

**Суть:** **SharedWorker** — один экземпляр воркера на все вкладки одного origin, которые к нему подключаются. Вкладки устанавливают с ним связь через **port** (или используют автоматический порт) и шлют сообщения. Воркер может принять сообщение от одной вкладки и разослать остальным — получается «хаб» между вкладками.

**Как использовать:** Вкладки делают `new SharedWorker('worker.js')` и общаются через **worker.port.postMessage** / **onmessage**. В воркере хранят массив портов подключённых вкладок и при сообщении от одного шлют остальным.

**Плюсы:** общая логика в одном месте (воркер), можно обрабатывать и агрегировать данные.  
**Минусы:** сложнее в настройке, SharedWorker не во всех браузерах поддерживается одинаково (в частности, старые версии Safari/Edge).

**Когда использовать:** когда нужен общий «посредник» с логикой или объединение данных из нескольких вкладок.

---

## 4. Service Worker как посредник

**Суть:** **Service Worker** регистрируется для origin и может быть общим для всех вкладок этого origin. Вкладки (clients) могут слать сообщения в SW через **postMessage**, SW получает их в обработчике и может разослать сообщения другим clients через **clients.matchAll()** и **client.postMessage()**.

**Как использовать:** Вкладка: `navigator.serviceWorker.controller.postMessage(data)`. В SW: в событии `message` получить источник и переслать остальным clients. Другая вкладка получает сообщение в `navigator.serviceWorker.onmessage`.

**Плюсы:** SW уже часто есть для PWA/офлайна; можно совместить обмен данными с кэшированием.  
**Минусы:** нужен зарегистрированный Service Worker; логика рассылки в SW чуть сложнее.

**Когда использовать:** когда в приложении уже используется Service Worker и нужно заодно синхронизировать вкладки.

---

## 5. Cookie + опрос (polling)

**Суть:** Cookie общие для всех вкладок одного домена. Одна вкладка записывает данные в cookie (в пределах лимита ~4 КБ на куку), другая периодически читает document.cookie или подписывается на изменения (в части браузеров нет события при изменении cookie из другой вкладки) — поэтому обычно делают **polling** (опрос по таймеру).

**Минусы:** маленький объём, лишние запросы к серверу если куки с HttpOnly, неудобно для сложных данных, polling не моментальный.  
**Когда использовать:** редко, только если уже всё завязано на cookie и нужна минимальная синхронизация.

---

## Сравнение способов

| Способ | Сложность | Поддержка браузерами | Кто получает | Объём данных |
|--------|-----------|----------------------|--------------|--------------|
| **localStorage + storage** | Низкая | Хорошая | Все вкладки, кроме записавшей | Ограничен localStorage (~5–10 МБ) |
| **BroadcastChannel** | Низкая | Хорошая, кроме старых Safari | Все подписанные, включая отправителя | Structured clone (объекты) |
| **SharedWorker** | Средняя | Не везде (Safari, старый Edge) | По логике воркера (все/выбранные) | По каналу |
| **Service Worker** | Средняя | Где есть SW | По логике SW (все clients) | По каналу |
| **Cookie + polling** | Низкая | Везде | Вкладки, которые опрашивают | Мало (~4 КБ) |

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Как обмениваться данными между вкладками? | localStorage + событие storage; BroadcastChannel; SharedWorker; Service Worker (clients ↔ SW); реже cookie + polling. Всё только в рамках одного origin. |
| Чем отличается событие storage от BroadcastChannel? | storage срабатывает только в **других** вкладках (не в той, что записала); данные в localStorage. BroadcastChannel — явный канал, postMessage, получают все подписчики, включая отправителя. |
| Зачем SharedWorker для обмена между вкладками? | Один воркер на все вкладки; вкладки шлют сообщения воркеру, он может рассылать их остальным — общий «хаб» с возможной логикой. |
| Почему вкладка, записавшая в localStorage, не получает storage? | По спецификации событие storage не доставляется в контекст, который инициировал изменение — только в остальные окна/вкладки того же origin. |
| Что такое BroadcastChannel? | API для канала по имени: вкладки открывают канал с одним именем и шлют postMessage; все подписчики канала получают сообщения. |

---

## Кратко запомнить

- Обмен между вкладками возможен **только в рамках одного origin**.
- **localStorage + storage** — запись в одну вкладку, событие в остальные (без инициатора); просто, но только строки.
- **BroadcastChannel** — канал по имени, postMessage, все подписчики получают; удобно для уведомлений и синхронизации.
- **SharedWorker** / **Service Worker** — общий «посредник» между вкладками; сообщения через воркер/SW.
- **Cookie + polling** — редко, малый объём и не моментально.
