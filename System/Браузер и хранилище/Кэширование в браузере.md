# Кэширование в браузере

## Краткий ответ для собеседования

**Кэш браузера** хранит копии ресурсов (HTML, CSS, JS, изображения), чтобы не запрашивать их с сервера повторно. Управляется заголовками HTTP: **Cache-Control** (max-age, no-cache, no-store), **ETag** и **Last-Modified** (валидация), **Expires** (устаревший способ). Есть кэш запросов (HTTP cache) и кэш приложения (Service Worker, localStorage и т.д.). Цель: быстрее загрузка, меньше трафика и нагрузки на сервер.

---

## Что такое кэширование в браузере

**Кэш браузера** — хранилище копий ресурсов (документы, стили, скрипты, картинки), полученных по сети. При повторном запросе того же URL браузер может отдать ответ из кэша, не обращаясь к серверу.

Управление кэшем — через **HTTP-заголовки** в ответе сервера и (реже) в запросе клиента. Браузер решает: сохранять ли ответ, как долго считать его свежим и когда перепроверять у сервера.

---

## Зачем нужно кэширование

- **Скорость:** повторные загрузки страницы или переходы быстрее, если ресурсы берутся из кэша.
- **Трафик:** меньше повторных запросов к серверу — экономия для пользователя и сервера.
- **Нагрузка на сервер:** меньше запросов — меньше работы бэкенда и CDN.

---

## Основные HTTP-заголовки кэширования

### Cache-Control

Главный заголовок управления кэшем. Сервер указывает, можно ли кэшировать и как долго.

**Типичные директивы:**

- **max-age=N** — ответ можно использовать из кэша до N секунд без проверки у сервера.
- **s-maxage=N** — то же для shared-кэша (прокси, CDN); для браузера обычно смотрят на max-age.
- **no-cache** — можно хранить в кэше, но перед использованием нужно проверить актуальность у сервера (revalidate).
- **no-store** — не сохранять ответ в кэш вообще.
- **private** — только браузер пользователя (не прокси/CDN).
- **public** — можно кэшировать и в браузере, и в shared-кэше.
- **must-revalidate** — после истечения max-age обязательно проверить у сервера; без сети нельзя отдавать устаревший ответ.

**Примеры:**

- Долгое кэширование статики: `Cache-Control: public, max-age=31536000` (год).
- Всегда проверять: `Cache-Control: no-cache` или `max-age=0, must-revalidate`.
- Ничего не кэшировать: `Cache-Control: no-store`.

### ETag

Сервер отдаёт идентификатор версии ресурса (хеш или номер версии). При следующем запросе браузер может отправить заголовок **If-None-Match** с этим ETag. Если ресурс не изменился, сервер отвечает **304 Not Modified** без тела — браузер использует кэш. Если изменился — сервер отдаёт **200** и новый ETag.

### Last-Modified

Сервер указывает дату последнего изменения ресурса. Браузер при повторном запросе может отправить **If-Modified-Since**. Если ресурс не менялся — **304 Not Modified**; иначе — **200** и новый контент.

**ETag** обычно точнее **Last-Modified** (изменения в пределах секунды, контент тот же и т.д.).

### Expires

Устаревший способ: дата/время, после которого ответ считается устаревшим. Игнорируется при наличии **Cache-Control: max-age**. Лучше использовать max-age.

---

## Как браузер решает, брать из кэша или нет

1. **Есть ли ответ в кэше для этого URL?**  
   Нет → запрос к серверу.

2. **Есть в кэше.**  
   Смотрит на **Cache-Control**: если **no-store** — не использует кэш, идёт в сеть. Если **max-age** не истёк и нет **no-cache** — может отдать из кэша без запроса (в зависимости от политики).

3. **Кэш есть, но устарел или стоит no-cache.**  
   Браузер отправляет запрос с **If-None-Match** (ETag) и/или **If-Modified-Since**. Сервер отвечает **304** — браузер обновляет метаданные кэша и отдаёт тело из кэша. Сервер отвечает **200** — браузер заменяет кэш новым ответом.

4. **Специфика запроса.**  
   Разный кэш для разных методов, заголовков (Vary) и т.д. Упрощённо: один URL — одна запись в кэше для данной комбинации, которую браузер считает значимой.

---

## Типы кэша в браузере

### HTTP cache (кэш запросов)

Кэш ответов на HTTP-запросы. Управляется заголовками Cache-Control, ETag, Last-Modified. Общий объём и политика вытеснения зависят от браузера и настроек.

### Memory cache / Disk cache

Браузер может хранить кэш в памяти или на диске. Часто мелкие/недавние ресурсы — в памяти, крупные или реже используемые — на диске. Для разработчика важно не «где лежит», а правила свежести (Cache-Control, revalidate).

### Service Worker cache

Скрипт Service Worker может перехватывать запросы и отдавать ответы из своего кэша (Cache API). Полный контроль на стороне клиента: что кэшировать, когда обновлять, офлайн-страницы. Используется в PWA и для тонкой настройки кэширования поверх обычного HTTP cache.

### Application cache (устаревший)

Старый механизм AppCache для офлайн-приложений. Не рекомендуется, заменён на Service Worker + Cache API.

---

## Свежесть и валидация

- **Свежий ответ (fresh):** в рамках max-age, браузер может не обращаться к серверу.
- **Устаревший (stale):** max-age истёк или стоит no-cache — нужна проверка у сервера (revalidate).
- **Валидация:** запрос с If-None-Match / If-Modified-Since; ответ 304 или 200 с новым контентом.

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Как браузер кэширует ресурсы? | По правилам из HTTP-заголовков: Cache-Control, ETag, Last-Modified. |
| Что такое Cache-Control? | Заголовок: как долго кэшировать (max-age), нужно ли проверять (no-cache), кэшировать ли вообще (no-store). |
| В чём разница no-cache и no-store? | no-cache — можно хранить, но перед использованием проверять у сервера; no-store — не сохранять в кэш. |
| Зачем ETag? | Чтобы проверить, изменился ли ресурс (If-None-Match → 304 или 200), не качая тело. |
| Что такое 304 Not Modified? | Ответ сервера: «контент не менялся», браузер использует кэш. |
| Как инвалидировать кэш? | Другой URL (query, версия в пути), или заголовки no-cache/no-store, короткий max-age. |

---

## Кратко для ответа

Кэш браузера хранит копии ресурсов и управляется заголовками: **Cache-Control** (max-age, no-cache, no-store), **ETag** и **Last-Modified** для валидации. Браузер решает по этим правилам: отдать из кэша, проверить у сервера (304/200) или запросить заново. Цель — быстрее загрузка и меньше трафика. Для полного контроля на клиенте используют Service Worker и Cache API.
