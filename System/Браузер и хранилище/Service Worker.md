# Service Worker

## Понятным языком: что это и зачем

**Service Worker** — это **скрипт-посредник между твоим приложением и сетью**. Он не считает числа и не рисует интерфейс. Он «сидит» между страницей и интернетом: когда страница или любой ресурс на ней (скрипт, картинка, запрос к API) хочет что-то загрузить, запрос **сначала попадает к Service Worker**. Тот решает: отдать ответ из **кэша** (которым сам управляет) или **пойти в сеть**. Так можно сделать сайт работающим офлайн, ускорить повторные загрузки и получать push-уведомления в фоне.

**Одной фразой:** Service Worker — это «прокси в браузере», который перехватывает сетевые запросы и может отдавать закэшированные ответы или ходить в сеть. Нужен для **офлайна**, **умного кэша** и **PWA** (push, фоновая синхронизация).

---

### Чем Service Worker не является

- **Не Web Worker.** Web Worker — для тяжёлых вычислений в отдельном потоке (сортировки, парсинг). Service Worker — не для вычислений, а для **сети и кэша**: перехват запросов, кэширование, офлайн, push.
- **Не часть страницы.** Он регистрируется страницей, но живёт отдельно: у него нет доступа к DOM и `window`, он не привязан к одной вкладке и может «просыпаться» даже когда вкладка закрыта (например, для push).
- **Не «просто кэш».** Обычный HTTP-кэш браузера управляется заголовками с сервера. Service Worker даёт **полный контроль на клиенте**: ты в коде решаешь, что кэшировать, когда обновлять, что отдать при офлайне.

---

### Где он «живёт» и когда запускается

Service Worker — это **отдельный JS-файл** (например, `sw.js`). Страница **регистрирует** его через `navigator.serviceWorker.register('/sw.js')`. Браузер скачивает файл и запускает Service Worker **в фоне**, в своём контексте (отдельно от вкладок). Он привязан к **origin** (протокол + домен + порт) и к **scope** (путь, например `/app/` — тогда он перехватывает запросы только внутри этого пути).

Работает только по **HTTPS** (и на localhost для разработки). После регистрации у него свой **жизненный цикл**: установка (install), активация (activate), потом он «спит», пока не произойдёт событие — например, запрос (fetch) или push-уведомление. То есть он **запускается не постоянно**, а по событиям; браузер может его останавливать для экономии ресурсов.

---

### Зачем это на собеседовании

На собеседовании проверяют, понимаешь ли ты разницу между **Web Worker** и **Service Worker**, зачем нужен офлайн и PWA, и как устроено кэширование «поверх» браузера. Достаточно объяснить: Service Worker — это сетевой прокси в браузере, перехватывает запросы, может отдавать из кэша или из сети; используется для офлайна, быстрой загрузки и push-уведомлений.

---

## Краткий ответ для собеседования

**Service Worker** — скрипт в браузере, который работает **между приложением и сетью**: перехватывает запросы (fetch) и решает — отдать ответ из своего кэша (Cache API) или из сети. Нужен для **офлайн-работы**, **контроля кэширования** и **PWA** (push-уведомления, фоновая синхронизация). Работает только по HTTPS, не имеет доступа к DOM; живёт отдельно от вкладок и может «просыпаться» по событиям (запрос, push). От **Web Worker** отличается тем, что не для вычислений, а для сети и кэша.

---

## Основные понятия

### Перехват запросов (fetch)

Когда страница, скрипт или запрос из кода (fetch/XHR) обращается по сети, браузер **сначала** отправляет запрос в Service Worker (если он зарегистрирован и активен для этого URL). В обработчике события `fetch` ты получаешь запрос и решаешь:

- вернуть ответ из **Cache API** (тогда сеть не вызывается);
- или вызвать **fetch(request)** и пойти в сеть, при желании закэшировать ответ для следующих раз.

Так реализуют стратегии кэширования: «сначала кэш, при промахе — сеть», «сначала сеть, при ошибке — кэш» (офлайн), «сеть и обновление кэша в фоне» и т.д.

### Cache API

Отдельное хранилище, которым управляет именно твоя логика (и часто — Service Worker). Туда можно класть пары «запрос → ответ» и потом отдавать их без обращения к серверу. Service Worker использует Cache API, чтобы отдавать закэшированные ответы при перехвате fetch.

### Scope (область действия)

При регистрации можно указать scope — путь, в котором Service Worker имеет право перехватывать запросы. Например, scope `/app/` — перехватываются только запросы к `yoursite.com/app/...`. Один Service Worker на origin может обслуживать все страницы в scope.

---

## Жизненный цикл (упрощённо)

1. **Регистрация** — страница вызывает `navigator.serviceWorker.register('/sw.js')`. Браузер скачивает скрипт и пытается установить.
2. **Install** — событие `install`: здесь обычно кэшируют критичные ресурсы (оболочку приложения, офлайн-страницу). Если всё ок — Service Worker переходит к ожиданию активации.
3. **Activate** — событие `activate`: старые кэши можно почистить, обновить список ресурсов. После этого Service Worker **контролирует** все страницы в scope (старый SW отключается, если был).
4. **Idle** — Worker «спит», пока не прийдёт событие.
5. **Fetch** — при любом сетевом запросе в scope срабатывает `fetch`: ты решаешь, что вернуть (из кэша или из сети).
6. **Push / Sync** — при push-уведомлении или background sync срабатывают соответствующие события; Worker может показать уведомление или отправить данные на сервер.

**Обновление:** при изменении файла `sw.js` браузер видит новый скрипт, устанавливает его «рядом» со старым. Новый переходит в состояние «waiting», пока все вкладки, использующие старый Worker, не закроются (или пока не вызвать skipWaiting). Тогда новый активируется (событие `activate`), старый выгружается.

---

## Зачем нужен: офлайн, кэш, PWA

- **Офлайн** — при отсутствии сети Service Worker может отдавать закэшированные HTML/JS/CSS и данные (например, последний ответ API). Пользователь видит не «нет интернета», а работающую оболочку или данные из кэша.
- **Быстрая загрузка** — повторные заходы можно обслуживать из кэша, не дожидаясь ответа сервера; можно кэшировать статику (скрипты, стили, картинки) и реже ходить в сеть.
- **PWA** — Progressive Web App: офлайн, установка на рабочий стол, **push-уведомления** (сервер шлёт событие, браузер будит Service Worker, тот показывает уведомление), при необходимости — фоновая синхронизация (отправка данных, когда сеть появилась).

---

## Ограничения

- **Только HTTPS** (и localhost).
- **Нет доступа к DOM** — нельзя менять разметку; можно только показывать уведомления, обновлять кэш, отвечать на fetch.
- **Асинхронный** — в install/activate нельзя опираться на синхронные хранилища вроде localStorage; используют Cache API, IndexedDB.
- **Обновление по новой версии файла** — пользователь получит новый Service Worker только после повторного захода или обновления страницы; активация может откладываться до закрытия вкладок (если не вызывать skipWaiting).

---

## Отличие от Web Worker (кратко)

| | Web Worker | Service Worker |
|---|------------|----------------|
| **Назначение** | Тяжёлые вычисления | Сеть, кэш, офлайн, push |
| **Кто создаёт** | Страница (new Worker) | Страница (register), живёт отдельно |
| **Привязка** | К одной странице | К origin/scope, все вкладки |
| **Жизненный цикл** | Пока жив контекст страницы | Устанавливается, активируется, живёт по событиям |
| **Типичное использование** | Парсинг, сортировка, криптография | Кэширование, офлайн, PWA, push |

На собеседовании: **«Web Worker — для выноса вычислений в отдельный поток, Service Worker — для перехвата запросов и кэширования, офлайна и push; это разные цели.»**

---

## Типичные вопросы на собеседовании

**Что такое Service Worker?**  
Скрипт-посредник между приложением и сетью; перехватывает запросы и может отдавать ответы из кэша или из сети. Нужен для офлайна, контроля кэша и PWA (push, фоновая синхронизация).

**Чем отличается от Web Worker?**  
Web Worker — для тяжёлых вычислений в фоне. Service Worker — для сети и кэша: перехват fetch, Cache API, офлайн, push-уведомления. Разные задачи.

**Зачем перехватывать запросы?**  
Чтобы решать на клиенте: отдать из кэша (быстро, работает офлайн) или пойти в сеть и при желании обновить кэш. Так делают офлайн-страницы и гибкие стратегии кэширования.

**Почему только HTTPS?**  
Service Worker имеет широкие права (перехват всего трафика в scope); по HTTP это было бы небезопасно (перехват, подмена). Исключение — localhost для разработки.

**Что такое Cache API?**  
Хранилище в браузере для пар «запрос → ответ». Им управляет твой код (часто в Service Worker); туда кладут ответы и отдают их при повторных запросах без обращения к серверу.

**Как обновляется Service Worker?**  
Браузер периодически проверяет файл sw.js; если изменился — скачивает и устанавливает новую версию. Она переходит в «waiting», затем при отсутствии активных вкладок со старым Worker (или при skipWaiting) активируется и заменяет старый.

---

## Кратко запомнить

- **Service Worker** — «прокси в браузере»: перехватывает fetch, отдаёт из кэша или из сети.
- **Зачем:** офлайн, быстрый повторный заход, PWA (push, фоновая синхронизация).
- **Не Web Worker:** не для вычислений, а для сети и кэша.
- **Жизненный цикл:** регистрация → install → activate → события fetch/push/sync.
- **Ограничения:** только HTTPS, нет DOM, асинхронная работа; кэш через Cache API (и при необходимости IndexedDB).
