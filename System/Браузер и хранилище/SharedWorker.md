# SharedWorker

## Краткий ответ для собеседования

**SharedWorker** — воркер, **один экземпляр которого** разделяется между несколькими вкладками (или окнами) одного origin. В отличие от обычного **Web Worker** (Dedicated Worker), где у каждой вкладки свой отдельный воркер, SharedWorker общий: все вкладки подключаются к одному и тому же скрипту и общаются с ним через **port**. Воркер может хранить общее состояние, принимать сообщения от одной вкладки и рассылать их остальным — получается «хаб» для обмена данными между вкладками или общая точка для тяжёлых вычислений. Ограничения те же, что у обычного воркера: нет DOM, только postMessage; плюс **поддержка в браузерах** не везде одинаковая (Safari, старые Edge). На собеседовании: что это, чем отличается от Dedicated Worker, зачем (обмен между вкладками, общее состояние), как устроено (port, один экземпляр на origin).

---

## Что такое SharedWorker

**SharedWorker** — это скрипт, выполняющийся в **отдельном потоке**, как и обычный Web Worker, но с отличием: **один и тот же экземпляр** воркера используется всеми страницами (вкладками, окнами, iframe) одного **origin**, которые создают его через `new SharedWorker(url)`.

- У **Dedicated Worker** (обычный `new Worker()`) — у каждой вкладки **свой** воркер; вкладки друг с другом через него не связаны.
- У **SharedWorker** — все вкладки, вызвавшие `new SharedWorker('worker.js')`, подключаются к **одному** воркеру. Воркер знает все подключения и может рассылать сообщения любому из них или всем сразу.

Общение идёт через **MessagePort**: у каждой страницы есть свой порт (например, `sharedWorker.port`). Воркер получает сообщения на портах и может отвечать на конкретный порт или рассылать по всем. У SharedWorker **нет доступа к DOM**, `window`, `document` — только окружение воркера (fetch, таймеры, и т.д.), как у обычного Worker.

---

## Как устроено: port и подключения

- Страница создаёт воркер: `const worker = new SharedWorker('worker.js')`.
- Связь с воркером идёт через **worker.port**. Нужно вызвать **port.start()** (в части браузеров порт стартует при первом postMessage), затем **port.postMessage(data)** и **port.onmessage = (e) => { ... }**.
- В самом воркере при каждом новом подключении (новая вкладка) срабатывает событие **connect**: в событии приходит **MessagePort**. Воркер сохраняет порты в массив (или коллекцию) и при получении сообщения от одного порта может переслать его остальным портам — так реализуется обмен между вкладками.

Идея: воркер — «посредник». Вкладка A шлёт сообщение воркеру, воркер по своей логике рассылает его вкладкам B и C (и при необходимости A). Общее состояние (счётчики, кэш, подписчики) можно хранить внутри воркера — оно одно на все вкладки.

---

## Зачем нужен SharedWorker

1. **Обмен данными между вкладками** — одна точка подключения для всех вкладок; воркер рассылает сообщения между портами. Удобно для синхронизации состояния, уведомлений, общего сокета или кэша.
2. **Общее состояние и логика** — один воркер может вести общий кэш, счётчик подключений, пул запросов; все вкладки используют одну и ту же логику без дублирования.
3. **Тяжёлые вычисления без множения воркеров** — если несколько вкладок делают однотипные тяжёлые задачи, можно отдавать их в один SharedWorker, чтобы не создавать по воркеру на вкладку (экономия памяти и согласованность).

Минусы: **сложнее**, чем Dedicated Worker (управление портами, жизнь воркера при закрытии части вкладок); **поддержка**: SharedWorker долго не поддерживался в Safari и в старых Edge — перед использованием стоит проверить поддержку.

---

## SharedWorker vs Dedicated Worker (Web Worker)

| Критерий | Dedicated Worker (Worker) | SharedWorker |
|----------|---------------------------|--------------|
| **Экземпляры** | У каждой страницы/вкладки свой воркер | Один воркер на все вкладки одного origin |
| **Связь между вкладками** | Нет; вкладки не связаны через воркер | Да; воркер может рассылать сообщения между портами |
| **API** | worker.postMessage / onmessage | worker.port.postMessage / port.onmessage, в воркере — событие connect и порты |
| **Когда использовать** | Тяжёлые задачи в фоне для одной страницы | Обмен между вкладками, общее состояние, один «хаб» на несколько страниц |

---

## Ограничения

- **Нет DOM** — как у любого воркера: нет доступа к document, window, элементам страницы.
- **Только postMessage** — данные передаются копированием (structured clone) или через transferable; общей памяти между страницей и воркером нет.
- **Один origin** — SharedWorker виден только страницам того же origin (схема + хост + порт).
- **Поддержка браузеров** — в старых Safari (до 15.4) и в части старых Edge SharedWorker не поддерживался или работал с багами; в современных Chrome, Firefox, новых Safari и Edge поддерживается.

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Что такое SharedWorker? | Воркер, один экземпляр которого разделяется между несколькими вкладками одного origin. Все подключаются к одному скрипту, общаются через port. |
| Чем отличается от обычного Web Worker? | У Dedicated Worker у каждой вкладки свой воркер; у SharedWorker один воркер на все вкладки, они подключаются к нему и могут обмениваться данными через воркер. |
| Зачем нужен SharedWorker? | Обмен сообщениями между вкладками (воркер как хаб), общее состояние или общая логика (кэш, счётчики), одна точка для тяжёлых задач от нескольких вкладок. |
| Как воркер узнаёт о новых вкладках? | В воркере срабатывает событие **connect**, в нём приходит MessagePort новой страницы. Воркер сохраняет порты и может слать сообщения любому или всем. |
| Какие ограничения у SharedWorker? | Нет DOM, только postMessage; один origin; поддержка не во всех браузерах (старые Safari, Edge). |

---

## Кратко запомнить

- **SharedWorker** — один экземпляр воркера на все вкладки одного origin; общение через **port** (port.postMessage, событие connect в воркере).
- От **Dedicated Worker** отличается тем, что вкладки **делят один воркер** и через него могут обмениваться данными.
- Используют для **обмена между вкладками**, общего состояния и общей тяжёлой логики.
- Ограничения: нет DOM, только сообщения; поддержка в браузерах не везде одинаковая.
