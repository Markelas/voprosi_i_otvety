# Web Workers

## Краткий ответ для собеседования

**Web Worker** — это скрипт, который выполняется в **отдельном потоке** (в фоне), не блокируя главный поток браузера. Обмен данными с главным потоком только через **postMessage**; у воркера **нет доступа к DOM**, `window`, `document`. Нужны для тяжёлых вычислений (сортировки, парсинг больших данных, криптография), чтобы интерфейс оставался отзывчивым.

---

## Зачем это на собеседовании

- Понимание **однопоточности JavaScript**: один главный поток — рендер и JS; долгая задача «подвисает» UI.
- Знание способа **вынести вычисления в фон**: воркеры — стандартный браузерный механизм.
- Ограничения воркеров (нет DOM, только postMessage, same-origin) и когда их использовать.

---

## Основные понятия

### Главный поток (main thread)

- В нём выполняется весь JS страницы, рендеринг, обработка событий.
- Пока выполняется тяжёлая функция — **ни рисование, ни обработка кликов не идут** → страница «висит».
- **Web Worker** переносит выполнение кода в **отдельный поток**, главный остаётся свободным.

### Отдельный поток

- У воркера свой глобальный контекст: есть только то, что даёт браузер (например, `fetch`, `setTimeout`), но **нет** `window`, `document`, DOM.
- С главным потоком общение **только через сообщения** (копирование или transfer), общей памяти нет (в классических воркерах).

---

## Как пользоваться

### Создание и обмен сообщениями

**Главный поток (страница):**

```js
// Создание воркера (скрипт должен быть same-origin или data URL и т.п.)
const worker = new Worker('/path/to/worker.js');

// Отправка данных воркеру
worker.postMessage({ type: 'calculate', data: [1, 2, 3, 4, 5] });

// Получение ответа
worker.onmessage = (event) => {
  console.log('Результат:', event.data);
};

// Ошибки
worker.onerror = (event) => {
  console.error('Ошибка воркера:', event.message);
};

// Завершение
worker.terminate();
```

**Воркер (worker.js):**

```js
// Получение данных от главного потока
self.onmessage = (event) => {
  const { type, data } = event.data;
  if (type === 'calculate') {
    const result = heavyCalculation(data);
    self.postMessage(result);
  }
};

function heavyCalculation(arr) {
  // Тяжёлые вычисления, не блокируют UI
  return arr.sort((a, b) => b - a);
}
```

Данные при **postMessage** копируются (structured clone) или передаются через **transferable** (например, `ArrayBuffer`), чтобы не клонировать большие буферы.

---

## Ограничения Web Worker

| Ограничение | Пояснение |
|-------------|-----------|
| **Нет доступа к DOM** | Нельзя читать/менять DOM, вызывать `document`, `window` |
| **Нет доступа к window** | Нет глобального `window`, только свой глобал (часто `self`) |
| **Только postMessage** | Обмен с главным потоком только через сообщения |
| **Same-origin** | Скрипт воркера подчиняется CORS/same-origin (можно обойти через blob URL своего скрипта) |
| **Нет доступа к localStorage напрямую** | Можно передавать данные через postMessage, а запись в storage делать в главном потоке |
| **Свой контекст** | В воркере доступны, например: `fetch`, `setTimeout`/`setInterval`, `importScripts`, WebSocket (зависит от окружения) |

На собеседовании часто спрашивают: **«Почему воркер не может менять DOM?»** — потому что DOM принадлежит главному потоку; доступ из нескольких потоков без синхронизации привёл бы к гонкам и нестабильности. Безопасная модель — один поток владеет DOM, воркер только считает и шлёт результат.

---

## Когда использовать

- **Тяжёлые вычисления:** большие сортировки, поиск, математика, криптография.
- **Парсинг больших данных:** большой JSON, CSV, разбор файлов.
- **Обработка данных без DOM:** подготовка данных для графика, фильтрация массивов.
- **Фоновая загрузка/обработка:** предзагрузка и разбор данных, пока пользователь смотрит UI.

### Когда не нужны

- Простые операции (добавление в DOM, лёгкие расчёты).
- Когда нужен постоянный доступ к DOM или к состоянию страницы в реальном времени — логику удобнее держать в главном потоке, а в воркер отправлять только «задачи».

---

## Типы воркеров (кратко)

| Тип | Описание |
|-----|----------|
| **Dedicated Worker** | Один воркер привязан к одному создавшему его контексту (странице). Создаётся через `new Worker(url)`. |
| **Shared Worker** | Один воркер может быть общим для нескольких вкладок/окон (одного origin). Меньше поддержка в старых браузерах. |
| **Service Worker** | Отдельная тема: кэширование, офлайн, push; не для «тяжёлых вычислений», а для работы с сетью и кэшем. |

На собеседовании обычно имеют в виду **Dedicated Worker**; при вопросе «какие бывают воркеры» можно назвать Dedicated, Shared и уточнить, что Service Worker — отдельный механизм для PWA и кэша.

---

## Каверзные и типичные вопросы

**Что такое Web Worker и зачем он нужен?**  
Скрипт в отдельном потоке; не блокирует главный поток. Нужен для тяжёлых вычислений, чтобы UI оставался отзывчивым.

**Почему воркер не может обращаться к DOM?**  
DOM принадлежит главному потоку; многопоточный доступ без жёсткой синхронизации опасен. Воркер только считает и обменивается данными через postMessage.

**Как воркер общается с главным потоком?**  
Только через **postMessage** и **onmessage**. Данные копируются (structured clone) или передаются через transferable (например, ArrayBuffer).

**Чем передача через postMessage отличается от общей памяти?**  
В классических воркерах общей памяти нет — данные копируются или «передаются» (transfer), чтобы не было гонок между потоками. SharedArrayBuffer — отдельный механизм (с ограничениями из-за Spectre и т.п.).

**Что нельзя использовать внутри воркера?**  
DOM, `document`, `window`, `localStorage`/`sessionStorage` напрямую. Можно: `fetch`, таймеры, `importScripts`, математика, работа с данными.

**Когда воркеры не помогут с «подвисанием»?**  
Когда узкое место — не CPU, а, например, главный поток занят частыми мелкими задачами, рендерингом или доступом к DOM. Воркеры не ускоряют сам DOM и не заменяют оптимизацию рендера.

**Что такое transferable и зачем они в postMessage?**  
Объекты вроде `ArrayBuffer` можно не копировать, а **передать** во воркер: тогда они «переезжают» из одного контекста в другой и становятся недоступны в отправителе. Нужны для больших бинарных данных (звук, видео, большие массивы).

**Чем Dedicated Worker отличается от Shared Worker?**  
Dedicated привязан к одному контексту (одна страница). Shared может быть общим для нескольких вкладок/окон одного origin.

---

## Кратко запомнить

- **Web Worker** = отдельный поток, тяжёлые задачи не блокируют UI.
- **Обмен** только через **postMessage** / **onmessage**; нет DOM и `window`.
- **Использовать** для вычислений, парсинга, криптографии; **не использовать** для доступа к DOM.
- **Dedicated** — один на страницу; **Shared** — на несколько вкладок; **Service Worker** — про кэш и сеть, не про вычисления.
