# Socket.IO

## Краткий ответ для собеседования

**Socket.IO** — библиотека для **двусторонней связи в реальном времени** между клиентом (браузер, мобильное приложение) и сервером. Использует **WebSocket**, когда он доступен, и при необходимости **fallback** на Long Polling или другие механизмы, чтобы работать и в старых окружениях. Предоставляет единый API: **emit** (отправка события с данными), **on** (подписка на событие), **rooms** и **namespaces** для группировки соединений. На собеседовании часто спрашивают: чем Socket.IO отличается от «голого» WebSocket, зачем fallback, что такое комнаты и неймспейсы, как устроена доставка сообщений (события по имени).

---

## Что такое Socket.IO

**Socket.IO** — это не протокол, а **библиотека** (есть версии для JavaScript/Node.js на сервере и для клиента в браузере). Она даёт канал связи в реальном времени: клиент и сервер могут отправлять друг другу данные без постоянных HTTP-запросов. Под капотом по умолчанию используется **WebSocket**; если он недоступен (прокси, старый браузер, ограничения сети), Socket.IO автоматически переключается на **Long Polling** или другие транспорты. Для разработчика остаётся один и тот же API — не нужно вручную выбирать транспорт.

Используют для чатов, уведомлений, совместного редактирования, онлайн-игр, дашбордов с живыми данными — везде, где нужна быстрая двусторонняя связь.

---

## Отличие от «голого» WebSocket

**WebSocket** — нативный браузерный API: одно соединение, отправка/получение сырых сообщений (чаще всего строк или бинарных данных). Нужно самому придумывать формат сообщений (например, JSON с полем «тип» и «данные»), обрабатывать переподключение и совместимость со старыми окружениями.

**Socket.IO** поверх WebSocket (или fallback) добавляет:
- **События по имени** — не просто «сообщение», а «новое сообщение в чат», «пользователь онлайн» и т.д.; на клиенте и сервере подписываются на имя события (**on**) и шлют через **emit**.
- **Автоматический fallback** — если WebSocket недоступен, используется Long Polling без смены кода.
- **Переподключение** — при обрыве соединения клиент сам пытается переподключиться.
- **Комнаты (rooms) и неймспейсы (namespaces)** — группировка соединений: можно слать сообщение не всем, а только в определённую «комнату» или неймспейс.

То есть Socket.IO — это **удобная обёртка** над идеей «постоянное соединение + события», а не замена протокола WebSocket; когда окружение позволяет, она как раз и использует WebSocket.

---

## Основные понятия

- **Подключение (connection)** — один клиент устанавливает одно постоянное соединение с сервером Socket.IO. Сервер и клиент хранят ссылку на этот сокет.
- **Событие (event)** — именованное сообщение. Клиент или сервер вызывает **emit('имяСобытия', данные)**; на другой стороне подписаны через **on('имяСобытия', callback)** и получают данные в callback.
- **Комната (room)** — логическая группа сокетов на сервере. Сокет можно **присоединить** к комнате; затем **emit** в комнату — сообщение получат только сокеты в этой комнате. Удобно для чатов по каналам, игр по комнатам, уведомлений группе пользователей.
- **Неймспейс (namespace)** — отдельный «путь» подключения (например, `/chat`, `/admin`). Разные неймспейсы изолированы: свои комнаты и свои события. Используют, чтобы разделить логику (один неймспейс для чата, другой для служебных уведомлений) или права доступа.
- **Транспорт** — способ доставки данных: WebSocket, HTTP Long Polling и т.д. Socket.IO выбирает транспорт при handshake; при проблемах с WebSocket может откатиться на Long Polling.

На фронтенде обычно: подключаются к серверу Socket.IO по URL, подписываются **on** на нужные события, по действиям пользователя вызывают **emit** с данными. Сервер обрабатывает подключения, добавляет сокеты в комнаты и рассылает события по комнатам или конкретным сокетам.

---

## Зачем это на собеседовании

На фронтенде часто используют Socket.IO для чатов, уведомлений и живых обновлений. Важно понимать: это библиотека поверх идеи постоянного соединения (чаще всего WebSocket); она даёт модель «события по имени» и fallback, а не «просто WebSocket». Вопросы про «чем отличается от WebSocket», «что такое комнаты», «как доставляются сообщения» — типичны.

---

## Что могут спросить на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Что такое Socket.IO? | Библиотека для двусторонней связи в реальном времени; использует WebSocket с fallback на Long Polling, даёт API с событиями по имени. |
| Чем Socket.IO отличается от WebSocket? | WebSocket — протокол и низкоуровневый API. Socket.IO — библиотека поверх него: именованные события (emit/on), авто fallback, переподключение, комнаты и неймспейсы. |
| Зачем fallback в Socket.IO? | Чтобы работать там, где WebSocket блокируют (прокси, файрволы, старые браузеры); клиент переключается на Long Polling без смены кода. |
| Что такое комнаты (rooms)? | Группы сокетов на сервере; сообщение можно отправить только в комнату — получат только сокеты в этой комнате (чат-канал, игровая комната). |
| Что такое неймспейс (namespace)? | Отдельный «путь» подключения (/chat, /admin); изолированные комнаты и события, чтобы разделить логику или доступ. |
| Как отправить/получить данные в Socket.IO? | Отправка: **emit('имяСобытия', данные)**. Получение: **on('имяСобытия', (данные) => { ... })**. |
| Когда использовать Socket.IO, а когда «голый» WebSocket? | Socket.IO — когда нужны именованные события, fallback и удобство (комнаты, переподключение). Голый WebSocket — когда важен минимум зависимостей и полный контроль над форматом и транспортом. |

---

## Кратко запомнить

- **Socket.IO** — библиотека для real-time двусторонней связи; под капотом WebSocket + fallback (Long Polling и др.).
- **emit** / **on** — отправка и приём **именованных событий** с данными.
- **Комнаты** — группировка сокетов на сервере; рассылка только по комнате.
- **Неймспейсы** — отдельные «пути» подключения для разной логики.
- От **WebSocket** отличается тем, что даёт уровень событий, fallback и переподключение, а не только сырой канал.
