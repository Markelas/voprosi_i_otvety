# Webpack

## Краткий ответ для собеседования

**Webpack** — сборщик модулей (module bundler) для фронтенда: берёт много файлов (JS, CSS, картинки, шрифты), строит граф зависимостей (кто что импортирует) и на выходе выдаёт один или несколько бандлов, готовых к загрузке в браузере. Нужен, чтобы превратить современный код (модули, импорты, разные форматы) в то, что браузер умеет загружать и выполнять. Обычно настраивают: точку входа и выходы, лоадеры (трансформация файлов: Babel, CSS, картинки), плагины (минификация, HTML, копирование ассетов), разбиение на чанки (code splitting), режим dev/production, оптимизации. Альтернативы: Vite, Parcel, Rollup.

---

## Для чего нужен Webpack

В проекте десятки или сотни файлов: JavaScript-модули, стили, изображения, шрифты. Раньше нужно было следить за очередностью скриптов при подключении. Браузер не умеет «из коробки» загружать десятки модулей по импортам как Node.js, не умеет собирать SCSS или TypeScript. Нужен инструмент, который:

- **Соберёт** все зависимости в связные куски (бандлы).
- **Преобразует** то, что браузер не понимает (TypeScript, современный JS, SCSS, изображения) в то, что понимает (JS, CSS, URL к файлам).
- **Оптимизирует** результат для продакшена (минификация, сжатие, разбиение на чанки для быстрой загрузки).

Webpack как раз такой инструмент — **сборщик модулей (bundler)**. Он берёт точку входа (например, главный JS-файл), обходит все импорты и подключённые ресурсы, применяет к ним правила преобразования и на выходе отдаёт один или несколько файлов, которые уже можно отдать браузеру.

Простыми словами: Webpack превращает «проект из кучи файлов и импортов» в «несколько готовых к загрузке бандлов». Без него пришлось бы вручную склеивать скрипты и подключать их в нужном порядке.

---

## Как работает Webpack

- **Точка входа (entry)** — с какого файла начинать. Webpack читает этот файл и находит в нём все импорты и подключения ресурсов (стили, картинки и т.д.).
- **Граф зависимостей** — каждый импорт ведёт к другому файлу; Webpack рекурсивно обходит все такие ссылки и строит дерево: что от чего зависит. В итоге получается полный список модулей и ресурсов, которые нужны для работы приложения.
- **Лоадеры (loaders)** — для каждого типа файла задаётся правило: «как преобразовать». Например, JS проходит через Babel (современный синтаксис → старый), SCSS — через лоадер в CSS, картинки — в путь или base64. Webpack не «понимает» сам TypeScript или SCSS — ему говорят через лоадеры, каким инструментом их обрабатывать.
- **Модули в один граф** — после лоадеров всё превращается в модули, которые Webpack умеет объединять (обычно в формате своих внутренних модулей с обёртками).
- **Плагины (plugins)** — выполняют разовые или сложные задачи над результатом: создание HTML-файла с подключением бандлов, минификация, извлечение CSS в отдельный файл, копирование ассетов, подсчёт хешей для кэширования. Работают на уровне всей сборки, а не одного файла.
- **Выход (output)** — куда положить итоговые файлы и как назвать. В результате получаются один или несколько бандлов (например, main.js, vendor.js, стили и т.д.), которые можно отдавать с сервера или CDN.

Кратко: **entry → обход зависимостей → лоадеры преобразуют файлы → плагины обрабатывают результат → output**. Всё это один процесс «сборки» (build).

---

## Что обычно настраивают и зачем

### Entry и Output

- **Entry** — с какого файла (или нескольких) начинать сборку. Обычно один главный JS (например, index.js или main.tsx). Для мультистраничного приложения — несколько точек входа (по странице).
- **Output** — папка для результата (часто dist или build), имена файлов. Часто к именам добавляют хеш (contenthash), чтобы при изменении кода менялось имя файла и браузер не использовал старый кэш.

Зачем: без entry Webpack не знает, с чего начать; без output некуда писать результат.

### Лоадеры (Loaders)

- **babel-loader** — превращает современный JS (или JSX, TypeScript при использовании с соответствующими пресетами) в код, понятный нужным браузерам. Зачем: поддержка старших браузеров и синтаксиса ES6+, JSX.
- **ts-loader** или **babel-loader + TypeScript** — компиляция TypeScript в JavaScript. Зачем: писать на TS, отдавать браузеру JS.
- **css-loader** — разрешает импорты CSS в JS (например, import './style.css') и подставляет в бандл. **style-loader** или **mini-css-extract-plugin** — либо вставляет стили в JS (тег style), либо выносит в отдельный .css файл. Зачем: модульный CSS и единая точка входа.
- **sass-loader** (или less-loader) — компиляция SCSS/Less в CSS, дальше обрабатывается как обычный CSS. Зачем: препроцессоры.
- **file-loader** / **url-loader** (или в новых версиях **asset modules**) — картинки, шрифты, файлы: либо копировать в output и подставлять URL, либо встраивать маленькие файлы в бандл как base64. Зачем: импорт изображений и шрифтов из кода.

Идея: **лоадеры = «как превратить тот или иной тип файла в то, что Webpack умеет положить в бандл»**.

### Плагины (Plugins)

- **HtmlWebpackPlugin** — генерирует HTML-файл и автоматически подключает в него собранные JS и CSS. Зачем: не писать вручную теги script/link при каждом изменении имён бандлов.
- **MiniCssExtractPlugin** — выносит CSS в отдельные .css файлы вместо встраивания в JS. Зачем: кэширование стилей отдельно, быстрее загрузка при повторном заходе.
- **TerserPlugin** (или встроенная минификация) — сжимает и минифицирует JS. Зачем: меньший размер, быстрее загрузка в продакшене.
- **DefinePlugin** — подставляет глобальные константы на этапе сборки (например, флаг production, URL API). Зачем: разное поведение в dev и prod без смены кода вручную.
- **CopyWebpackPlugin** — копирует статические файлы (иконки, manifest) в папку вывода. Зачем: ассеты, которые не проходят через импорты, но должны оказаться в dist.

Идея: **плагины = действия над всей сборкой** (файлы, оптимизация, генерация HTML).

### Режим (mode) и окружение

- **development** — быстрая сборка, подсказки об ошибках, без минификации. Зачем: удобная разработка и отладка.
- **production** — минификация, оптимизации, tree shaking. Зачем: минимальный размер и быстрая загрузка у пользователя.

### Разбиение на чанки (Code Splitting)

Настраивают так, чтобы не всё попадало в один огромный main.js: выносят редко меняющиеся библиотеки (vendor) в отдельный чанк, разбивают по маршрутам (каждая страница — свой чанк, подгружается по требованию). Зачем: быстрее первая загрузка (меньше грузить сразу) и лучше кэширование (изменения в коде приложения не инвалидируют кэш библиотек).

### Dev-сервер (webpack-dev-server)

Поднимает локальный сервер, отдаёт собранное приложение и при изменении файлов пересобирает и обновляет страницу (или только обновляет модули при HMR). Зачем: комфортная разработка без ручного перезапуска сборки.

---

## Кратко: зачем что нужно

| Что настраивают | Зачем |
|-----------------|--------|
| Entry / Output | С чего начать сборку и куда положить результат |
| Лоадеры | Преобразовать файлы (TS, SCSS, картинки) в то, что можно положить в бандл |
| Плагины | Генерация HTML, минификация, извлечение CSS, копирование ассетов |
| Mode (dev/prod) | Разная скорость и оптимизация для разработки и продакшена |
| Code splitting | Меньший начальный бандл, загрузка по требованию, лучше кэш |
| Dev-server | Удобная разработка с авто-пересборкой |

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Что такое Webpack? | Сборщик модулей: по точкам входа обходит зависимости, преобразует файлы (лоадеры) и выдаёт бандлы; плагины делают оптимизацию и генерацию файлов. |
| Для чего нужен Webpack? | Собрать много файлов и ресурсов в готовые к загрузке бандлы, преобразовать TS/SCSS/современный JS в то, что браузер понимает. |
| Что такое лоадер? | Правило преобразования одного типа файла (например, babel для JS, sass-loader для SCSS); Webpack применяет лоадеры к каждому импортированному файлу. |
| Что такое плагин? | Действие над всей сборкой: минификация, создание HTML, извлечение CSS, копирование файлов. |
| Чем лоадер отличается от плагина? | Лоадер обрабатывает конкретные файлы по типу; плагин работает с результатом сборки в целом (оптимизация, генерация, копирование). |
| Что такое code splitting? | Разбиение кода на несколько чанков (например, vendor и по маршрутам), чтобы не грузить всё сразу и лучше кэшировать. |

---

## Кратко для ответа

**Webpack** — сборщик модулей: по entry обходит граф зависимостей, лоадеры преобразуют файлы (JS, TS, CSS, SCSS, ассеты), плагины обрабатывают результат (HTML, минификация, извлечение CSS). Настраивают entry/output, лоадеры под типы файлов, плагины под задачи сборки, mode (dev/prod), code splitting. Нужен, чтобы из множества модулей и ресурсов получить готовые к загрузке в браузере бандлы.
