# nginx

## Простыми словами: где он, зачем отдельно и когда запускается

### Где nginx хранится и работает

**nginx — это обычная программа** (как браузер или Node.js). Она **установлена там, где крутится твой сайт** — на сервере в интернете (виртуальная машина, VPS, облако) или внутри контейнера Docker. Отдельного «места хранения» у nginx нет: он просто стоит на той же машине (или в том же образе), куда ты выкладываешь собранный фронт. Конфиг nginx (правила «откуда отдавать файлы», «куда проксировать API») лежит рядом — в файлах на этой машине или в образе. То есть **«где хранится» = там же, где и твоё приложение в проде.**

Если без Docker: nginx ставят на сервер (например, через `apt install nginx`), в конфиге указывают папку с твоими файлами (например, `/var/www/app`), туда же при деплое кладут результат сборки. Если с Docker: в образ кладут и nginx, и папку со статикой; при запуске контейнера внутри него стартует процесс nginx — он и «хранится», и работает внутри этого контейнера.

---

### Зачем его делают отдельно (почему не обойтись без него)

После сборки фронта у тебя есть **просто папка с файлами**: `index.html`, JS, CSS, картинки. Файлы сами по себе **ничего не умеют** — они не слушают порт и не отвечают на запросы. Когда пользователь вводит в браузере твой URL, кто-то должен **принять запрос по сети и отдать эти файлы**. Этим «кем-то» и является nginx.

То есть: **фронт в проде — это не «приложение, которое само крутится», а набор файлов.** Чтобы их раздавать по HTTP/HTTPS, нужна программа, которая умеет слушать порт 80/443 и отдавать файлы с диска. Такую программу и делают «отдельно» — чаще всего это nginx. Без неё (или без другой подобной программы) браузер просто не получит ни HTML, ни JS: некому ответить на запрос.

В разработке у тебя «крутится» Webpack Dev Server или Vite — они как раз и делают эту работу: слушают порт и отдают файлы. В проде вместо них ставят nginx (или аналог), потому что он легкий, быстрый и хорошо подходит для раздачи статики и проксирования на бэкенд. **Отдельно его делают не «для красоты», а потому что кто-то должен выполнять роль «раздатчика файлов» на сервере — и это nginx.**

---

### В какой момент nginx запускается

**Он запускается тогда, когда «включается» то место, где он установлен.**

- **Без Docker:** nginx ставят на сервер как сервис (демон). При загрузке сервера он стартует автоматически (или его поднимают вручную / через скрипт деплоя). Дальше он **работает постоянно**: висит в фоне, слушает порт 80/443 и ждёт запросы. Каждый новый деплой фронта — это обычно «положили новые файлы в папку»; nginx перезапускать не обязательно, он уже читает файлы с диска при каждом запросе.

- **С Docker:** при деплое запускают контейнер. Внутри контейнера при старте выполняется одна главная команда — как правило, **запуск nginx**. То есть момент запуска nginx — это **момент запуска контейнера** (после деплоя или перезапуска). Контейнер живёт — nginx работает; контейнер остановили — nginx тоже остановился.

- **С Kubernetes:** поды с фронтом — это те же контейнеры (nginx + статика). Они запускаются когда Kubernetes создаёт или обновляет поды (при деплое новой версии). То есть nginx стартует **вместе с подом** при каждом деплое или масштабировании.

**Итого:** nginx не «запускается от твоего кода» и не «идёт вместе с Webpack». Он запускается **вместе с сервером или контейнером**, где развёрнут твой фронт, и крутится всё время, пока крутится этот сервер или контейнер. Ты выкладываешь новые файлы (или новый образ) — nginx продолжает раздавать их с той же папки (или из нового образа).

---

## Краткий ответ для собеседования

**nginx** — это веб-сервер и обратный прокси: принимает HTTP-запросы, отдаёт статические файлы или перенаправляет запросы на другое приложение (бэкенд, другой сервис). Во фронтенде его используют, чтобы отдавать собранную статику (HTML, JS, CSS), проксировать API на бэкенд, сжимать ответы, кэшировать заголовки и раздавать трафик. Он не собирает проект — сборку делает Webpack (или другой бандлер); nginx лишь раздаёт уже готовые файлы и может стоять в контейнере Docker или за Ingress в Kubernetes.

---

## Что такое nginx

nginx — это **веб-сервер** и **обратный прокси**. Он слушает порт (обычно 80 или 443), принимает входящие HTTP/HTTPS-запросы и либо сам отдаёт файлы с диска (статику), либо пересылает запрос на другой сервер (бэкенд, другой микросервис) и возвращает клиенту ответ от него. То есть он стоит «перед» приложением: клиент общается с nginx, а nginx уже решает — отдать файл самому или спросить бэкенд.

За счёт асинхронной модели и эффективной работы с соединениями nginx хорошо держит много одновременных запросов при малых затратах ресурсов. Поэтому его часто выбирают для отдачи статики и в качестве единой точки входа (reverse proxy) перед несколькими сервисами.

---

## Зачем nginx во фронтенд-разработке

После сборки фронтенда (Webpack, Vite и т.д.) получается набор файлов: `index.html`, бандлы JS, CSS, картинки, шрифты. Эти файлы нужно **кто-то отдавать** по HTTP. Этим «кем-то» чаще всего и бывает nginx: он знает, из какой папки (например, `dist` или `build`) отдавать файлы, по какому пути отдавать `index.html` для SPA (чтобы при прямом заходе на `/some/route` не было 404), и может при этом сжимать ответы (gzip), проставлять заголовки кэширования, обслуживать HTTPS.

Дополнительно nginx часто настраивают как **прокси к API**: запросы на `/api/*` он не отдаёт как файлы, а пересылает на бэкенд-сервер. Так фронт и бэкенд для браузера выглядят одним доменом и портом — проще с CORS и куками, один сертификат для HTTPS.

Итого для фронта nginx — это: **раздача статики**, **проксирование API**, **сжатие и кэш-заголовки**, иногда **терминация SSL** (приём HTTPS на nginx, дальше к приложению уже по HTTP внутри сети).

---

## Как nginx соотносится с Webpack (и другими бандлерами)

**Прямого «взаимодействия» между nginx и Webpack нет.** Webpack (или Vite, Rollup) — инструмент **сборки**: на этапе билда он берёт исходники и выдаёт готовые файлы в выходную папку. nginx — инструмент **отдачи**: он уже работает с этой папкой на сервере (или в контейнере) и отдаёт файлы по HTTP запросам.

Цепочка такая: разработка и сборка (Webpack) → артефакты в `dist`/`build` → эти же файлы попадают на сервер или в образ → nginx настроен отдавать их с этой папки. Настройки Webpack (пути к ассетам, publicPath, разбиение на чанки) влияют на то, какие URL запрашивает браузер; nginx должен эти URL уметь обслуживать (например, отдавать один и тот же `index.html` для путей SPA). То есть они **согласованы по контракту** (какие пути и файлы), но не связаны в runtime.

В режиме разработки (dev server) обычно nginx не используют — раздаёт сам Webpack Dev Server или Vite; nginx появляется при деплое готовой сборки.

---

## Как nginx взаимодействует с Docker

В Docker nginx чаще всего используется как **образ, который только отдаёт статику**. Сборка фронта может происходить либо на хосте/в CI, либо в том же Docker-образе (multi-stage build): на одной стадии собирают проект (Node, npm run build), на другой — берут только папку с артефактами и кладут её в лёгкий образ на базе nginx. Итоговый образ содержит только nginx и статические файлы, без Node и исходников. При запуске контейнер слушает порт 80 (или другой), nginx отдаёт файлы из примонтированной в образ папки.

Так фронтенд в проде — это один образ: nginx + статика. Деплой сводится к сборке образа и запуску контейнера; окружение везде одинаковое. Если в одном docker-compose поднимают фронт и бэкенд, фронт-сервис — как раз такой nginx-контейнер со статикой, а запросы к API могут проксироваться с этого же nginx на контейнер бэкенда по внутренней сети Docker.

---

## Как nginx взаимодействует с Kubernetes

В Kubernetes фронтенд обычно разворачивается как **Pod'ы с контейнером nginx** (тем же образом «nginx + статика»). Входящий трафик из интернета не идёт напрямую в поды; перед ними стоит **Ingress** — объект Kubernetes, который описывает правила маршрутизации (какой домен/путь на какой сервис направить) и часто сам по себе использует **Ingress Controller**. Один из самых распространённых контроллеров — именно **nginx** (NGINX Ingress Controller): он принимает HTTP/HTTPS, смотрит на хост и путь и направляет запросы в нужный Service (например, во фронт-поды или в бэкенд).

Получается два «слоя» nginx в типичной схеме: внутри подов — nginx, который отдаёт статику фронта; на границе кластера — Ingress на базе nginx, который решает, куда направить запрос. Для фронтенд-разработчика важно понимать: статика отдаётся из подов с nginx, а правила маршрутизации, SSL, балансировка между репликами задаются на уровне Ingress и Service; от этого зависят итоговые URL и поведение в проде.

---

## На что это влияет в обычной практике

- **Деплой:** фронт собирается один раз; результат кладётся в образ или на диск, nginx просто отдаёт файлы. Изменения в коде требуют пересборки и нового деплоя образа/артефактов, а не перенастройки nginx при каждом коммите.

- **Пути и SPA:** для одностраничного приложения на nginx настраивают «fallback» на `index.html` по путям без файла, чтобы клиентский роутер обрабатывал маршруты при прямом заходе и обновлении страницы. Если это не настроено, на проде будут 404 на любом пути, кроме корня.

- **API и CORS:** когда API проксируется через nginx с того же домена, браузер не видит cross-origin запросов — CORS для таких запросов настраивать не нужно. Если фронт и API отдаются с разных доменов, CORS настраивают на бэкенде (или на прокси), и понимание «где заканчивается фронт и начинается бэкенд» помогает не путаться с заголовками.

- **Кэш и заголовки:** от nginx (или от CDN перед ним) часто отдаются заголовки кэширования для статики (долгий кэш для хэшированных файлов, без кэша для HTML). Это влияет на то, как быстро пользователи получают обновления после релиза.

- **Среда и переменные:** в проде URL API, feature flags и т.п. часто задаются через переменные окружения или конфиг; в Docker/Kubernetes их передают в контейнер. Сам nginx не «знает» про Webpack; важно, чтобы собранное приложение уже содержало нужные значения (через env при сборке) или читало конфиг с сервера, который nginx отдаёт как статику.

---

## Кратко запомнить

- **nginx** — веб-сервер и обратный прокси: отдаёт статику и проксирует запросы на бэкенд.
- **Во фронте** — раздача собранной статики, прокси API, сжатие, кэш-заголовки; сборку делает Webpack/другой бандлер, nginx только отдаёт результат.
- **С Webpack** — нет прямой связи; Webpack собирает в папку, nginx отдаёт из этой папки; пути и publicPath должны быть согласованы.
- **С Docker** — образ «nginx + статика», часто multi-stage; контейнер только слушает порт и отдаёт файлы.
- **С Kubernetes** — поды с nginx со статикой; Ingress (часто на nginx) маршрутизирует трафик на сервисы.
- **В практике** — важен fallback для SPA, прокси API, кэш и заголовки, согласование путей и конфигурации между сборкой и окружением.
