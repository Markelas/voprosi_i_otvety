# Kubernetes

## Краткий ответ для собеседования

**Kubernetes (K8s)** — система **оркестрации контейнеров**: она запускает, масштабирует и перезапускает контейнеры на кластере машин, распределяет нагрузку, управляет конфигурацией и входящим трафиком. Сама по себе Kubernetes не собирает приложение и не заменяет Webpack или Docker: **Webpack** собирает фронт в артефакты, **Docker** упаковывает их в образ (например, nginx + статика), **Kubernetes** берёт этот образ из реестра и запускает поды, сервисы и Ingress. Для фронтенда цепочка такая: сборка (Webpack) → образ (Docker) → деплой и маршрутизация в кластере (Kubernetes).

---

## Что такое Kubernetes

Kubernetes — это **оркестратор контейнеров**. Он работает не с одной машиной, а с **кластером**: множество серверов (нод), на которых запускаются контейнеры. Ты описываешь желаемое состояние («запусти три реплики приложения фронта, отдавай трафик по такому-то домену»), а Kubernetes сам решает, на каких нодах запустить поды, как распределить нагрузку, как перезапустить упавший контейнер и как направить входящие запросы в нужные поды.

То есть Kubernetes не заменяет Docker: он **использует образы** (часто собранные через Docker), скачивает их из реестра образов и **запускает контейнеры** по твоим правилам. Docker даёт «что запускать» (образ), Kubernetes — «где, сколько и как это жить будет в кластере».

---

## Зачем Kubernetes на фронтенде

На проде фронт обычно — это статика (собранная Webpack или другим бандлером) и веб-сервер (чаще nginx), который её отдаёт. Всё это уже упаковано в **один Docker-образ**. Kubernetes нужен, когда такой образ нужно не просто «запустить на одном сервере», а:

- запускать **несколько реплик** (несколько подов с одним и тем же образом) и распределять между ними трафик;
- **перезапускать** упавшие контейнеры и поднимать новые при деплое без простоя;
- **направлять входящий трафик** (один домен, разные пути или сервисы) на нужные приложения через Ingress;
- хранить **конфигурацию и секреты** (переменные окружения, URL API) отдельно от образа и подставлять их в поды.

Для фронтенд-разработчика важно понимать: твоё приложение в проде — это образ (часто nginx + статика), который в Kubernetes запускается как поды; доступ снаружи настраивается через Service и Ingress. Ты не настраиваешь K8s каждый день, но понимание цепочки «сборка → образ → кластер» помогает при деплое, отладке и разговоре с DevOps.

---

## Цепочка: Webpack → Docker → Kubernetes

Прямого «взаимодействия» между Kubernetes и Webpack нет: они стоят в разных местах пайплайна.

1. **Webpack (или Vite, другой бандлер)** — этап **сборки**. На нём из исходников получают готовые файлы (HTML, JS, CSS) в папку `dist`/`build`. Webpack не знает про Docker и Kubernetes; его результат — просто файлы на диске.

2. **Docker** — этап **упаковки**. Dockerfile описывает, как из этих файлов (и, при необходимости, из этапа сборки внутри образа) собрать образ. Итоговый образ для фронта часто такой: nginx + скопированная папка со статикой. Образ пушат в реестр (Docker Registry, GitLab Registry, ECR и т.д.). Docker не знает про Kubernetes; он только производит образ и кладёт его в реестр.

3. **Kubernetes** — этап **запуска и оркестрации**. В манифестах (YAML) или через Helm/другие инструменты описывают: какой образ из какого реестра использовать, сколько реплик, какие порты, переменные окружения, как входящий трафик направлять на этот сервис (Service, Ingress). Kubernetes тянет образ из реестра и запускает контейнеры в подах на нодах кластера.

Итого: **Webpack собирает, Docker упаковывает в образ, Kubernetes запускает этот образ в кластере.** С точки зрения фронта: настройки Webpack (publicPath, пути к ассетам) влияют на то, что лежит в образе и как nginx должен отдавать файлы; Docker и Kubernetes с содержимым сборки не «общаются», они просто хранят и запускают то, что уже собрано.

---

## Как Kubernetes взаимодействует с Docker

Kubernetes **не привязан только к Docker**: он работает с **образами в формате OCI** (стандарт образов контейнеров). Обычно образы собирают именно через Docker (docker build) или через другие инструменты (buildah, kaniko в CI), а затем пушат в реестр. Kubernetes образы **не собирает** — он их только **скачивает (pull)** из реестра и **запускает как контейнеры** в подах.

Типичный сценарий: в CI пайплайне вызывают сборку фронта (npm run build / Webpack), по Dockerfile собирают образ (часто multi-stage: сборка в одном образе, в итоговом — nginx + статика), образ пушат в реестр с тегом (например, версия или коммит). В Kubernetes в Deployment указан этот образ и тег; при деплое или обновлении K8s тянет новый образ и перезапускает поды. То есть **Docker (или аналог) производит образ, Kubernetes потребляет его** из реестра и управляет жизненным циклом контейнеров в кластере.

Если разработчик запускает приложение локально через `docker run` или `docker-compose`, то же самый образ (или тот же Dockerfile) может использоваться в Kubernetes на тестовом или продовом кластере — окружение совпадает, отличия только в конфигурации (переменные, масштаб, Ingress).

---

## Как Kubernetes взаимодействует с Webpack

**Напрямую не взаимодействует.** Webpack выполняется до того, как появляется образ и кластер: либо на машине разработчика, либо в CI (часто внутри временного Docker-контейнера с Node). Результат Webpack — файлы в выходной папке. Эти файлы попадают в Docker-образ (копируются в образ с nginx или собираются внутри multi-stage образа), а образ уже разворачивается в Kubernetes.

Что важно для согласованности: настройки Webpack (например, `publicPath`, разбиение на чанки, имена файлов) определяют, по каким URL браузер будет запрашивать ассеты. nginx в образе и правила в Ingress должны эти URL корректно обслуживать (отдавать статику, для SPA — fallback на index.html). То есть **согласование идёт по контракту путей и файлов**, а не за счёт прямой связи K8s и Webpack.

---

## Основные объекты Kubernetes (что полезно знать фронту)

- **Pod** — минимальная единица запуска; один или несколько контейнеров, которые делят сеть и том. Для фронта часто один под — один контейнер (образ nginx + статика).

- **Deployment** — описание «какое приложение запустить и в каком количестве»: образ, число реплик, переменные окружения, порты. При обновлении образа Deployment по очереди перезапускает поды (rolling update).

- **Service** — даёт подам стабильный сетевой адрес и балансирует трафик между репликами. Другие поды и Ingress обращаются к приложению по имени Service, а не по IP подов.

- **Ingress** — правила входящего HTTP/HTTPS-трафика: какой домен или путь направить на какой Service. За Ingress обычно стоит Ingress Controller (например, nginx), который и выполняет маршрутизацию. Для фронта часто настроен один домен/путь на Service фронтенда (поды с nginx и статикой).

- **ConfigMap / Secret** — конфигурация и секреты (переменные окружения, URL API). Подставляются в поды при запуске, чтобы не зашивать их в образ.

Фронтенд-разработчику не обязательно писать манифесты самому, но понимание «поды запускают наш образ, Service даёт к ним доступ, Ingress ведёт трафик снаружи» помогает при деплое и обсуждении с DevOps.

---

## Что влияет на практику

- **Деплой** — новая версия фронта = новый образ (собранный из кода после Webpack), запушенный в реестр с новым тегом; в Kubernetes обновляют Deployment (новый тег образа), K8s подтягивает образ и перезапускает поды. Без понимания цепочки «сборка → образ → деплой» сложнее отлаживать «почему на проде старая версия».

- **Переменные окружения** — URL API, feature flags часто задаются через ConfigMap/Secret и подставляются в поды. В образе может быть уже «зашит» publicPath или базовый путь; переменные меняют поведение приложения в разных средах (stage/prod) без пересборки образа.

- **Масштабирование** — количество реплик фронта задаётся в Deployment. Ingress и Service распределяют трафик между подами; для фронта (статики) это обычно просто и предсказуемо.

- **Отладка** — если что-то не открывается или отдаётся не тот контент, проверяют: правильный ли образ и тег в Deployment, те же ли пути в nginx и в сборке (Webpack), корректны ли правила Ingress и Service.

---

## Кратко запомнить

- **Kubernetes** — оркестрация контейнеров в кластере: запуск, масштабирование, перезапуск, маршрутизация трафика. Не заменяет Docker и не собирает приложение.
- **Цепочка для фронта:** Webpack собирает статику → Docker упаковывает её в образ (nginx + статика) → образ пушится в реестр → Kubernetes тянет образ и запускает поды, Service и Ingress отдают трафик.
- **С Docker:** K8s не собирает образы, а использует готовые из реестра (часто собранные через Docker); тот же образ можно запускать локально в Docker и в кластере в K8s.
- **С Webpack:** прямой связи нет; Webpack выполняется на этапе сборки, результат попадает в образ; в K8s важно согласование путей (nginx, Ingress) с тем, что генерирует Webpack.
- **На практике:** понимание этой цепочки помогает при деплое, настройке окружений и общении с DevOps.
