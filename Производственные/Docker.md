# Docker

## Понятным языком: от проблемы к решению

### Зачем вообще серверы

Любое приложение — это программа, которая должна где-то запускаться. На своём компе можно крутить только учебные штуки. Если приложением пользуются много людей, домашнему ПК не хватит ресурсов (память, процессор), плюс он может выключиться — и сервис «ляжет». Поэтому приложения крутят на **серверах**: мощные машины в дата-центрах, с резервным питанием и нормальной сетью.

### Проблема: несколько программ на одном сервере

На одном сервере обычно крутят не только приложение, но и базу, кэш и т.д. Они **делят одни и те же ресурсы** (CPU, память). Если одно приложение «съест» всё, остальным не хватит — всё начнёт падать. Плюс конфликты версий: одному нужна одна версия библиотеки, другому — другая.

### Решение сначала: виртуальные машины (VM)

Придумали запускать на одном железе **несколько отдельных операционных систем** — по одной под приложение, под базу, под кэш. Каждой VM выделяют фиксированные ресурсы, они изолированы друг от друга. Это дало **изоляцию** и **контроль ресурсов**.

Но появились новые проблемы: настройку (библиотеки, версии, конфиг) нужно делать **на каждой ОС отдельно**. Добавили второй сервер для нагрузки — снова поднимать и настраивать несколько VM вручную. Долго, дорого, легко ошибиться. Плюс каждая VM — это **полноценная тяжёлая ОС**, много ресурсов уходит просто на её работу.

### Идея Docker: «запускатор» вместо ручной настройки

Хотелось бы иметь **один пакет**, который можно положить на любой компьютер, нажать «запустить» — и приложение само развернётся со всем нужным: своей мини-ОС, зависимостями, кодом и командой запуска. Ничего не надо ставить и настраивать вручную. Так и устроен **Docker**.

---

## Главные понятия (чтобы запомнить и рассказать)

### Образ (Image)

**Образ** — это как **архив-запускатор**: в нём упаковано всё, что нужно, чтобы приложение взлетело на любом компе, где есть Docker.

Внутри образа:
- **Минимальная ОС** (лёгкий Linux) — не полноценная виртуальная машина, а урезанный набор для запуска программ.
- **Среда исполнения** (Node, JDK, Python — что нужно приложению).
- **Зависимости и библиотеки** нужных версий.
- **Код приложения** (или результат сборки).
- **Настройки и команда запуска** — что выполнить, чтобы приложение стартовало.

Ты один раз собираешь образ (через Docker и Dockerfile), сохраняешь. Дальше на любом сервере достаточно поставить Docker, взять этот образ и запустить — **никакой ручной настройки**, всё уже внутри.

Образ не запущен — это просто «шаблон», файл. **Image = шаблон с всем необходимым для запуска.**

### Контейнер (Container)

**Контейнер** — это **уже запущенное приложение** на основе образа. Образ один, контейнеров из него можно запустить сколько угодно.

Внутри контейнера приложение работает в своей **мини-ОС** из образа — изолировано от основной системы и от других контейнеров. Поэтому контейнер даёт те же плюсы, что и виртуальная машина (изоляция, ограничение ресурсов), но **легче и быстрее**: нет полной ОС, используется ядро хоста, запуск за секунды. Контейнер = «ящик», в котором приложение и его окружение изолированы от всего остального.

**Контейнер = запущенный экземпляр образа.**

### Docker (программа)

**Docker** — это программа, которая умеет **собирать образы** (по инструкциям из Dockerfile) и **запускать контейнеры** из образов. На сервере нужно установить только Docker; образы ты кладёшь туда (или тянем из реестра) и запускаешь контейнеры одной командой.

### Docker Hub (реестр образов)

Образ можно хранить у себя на диске, но удобнее — в **облачном хранилище** (Docker Hub, GitLab Registry и т.п.). Туда загружаешь образ (push), а на любом сервере Docker сам скачивает его (pull), если его ещё нет. Не нужно вручную таскать файлы между машинами. Плюс на Docker Hub лежат **готовые образы** (Postgres, Redis, Node, nginx) — свои образы делаешь только для своего приложения, базу и кэш можно брать готовыми.

### Dockerfile

**Dockerfile** — обычный текстовый файл с **инструкциями**, как собрать образ. Ты не собираешь архив руками: пишешь, от какого базового образа отталкиваться (например, node:18), что скопировать, какие команды выполнить, какой командой запускать приложение. Программа Docker читает Dockerfile и по нему **собирает образ**. Обычно первая строка — FROM (базовый образ с Docker Hub), дальше — COPY, RUN, WORKDIR, ENTRYPOINT/CMD и т.д.

---

## Цепочка одной фразой

**Сервер** — железо для приложений. **Виртуальные машины** дали изоляцию, но настройка вручную на каждой ОС и на каждом сервере — долго и тяжело. **Docker** даёт **образ** — один раз собранный «запускатор» со всем нужным внутри; **контейнер** — запущенное из этого образа приложение, лёгкое и изолированное. **Dockerfile** описывает, как собрать образ; **Docker Hub** — где хранить и откуда качать образы. На новом сервере: поставил Docker, скачал образ (или собрал из Dockerfile), запустил контейнер — без ручной настройки окружения.

---

## Краткий ответ для собеседования

**Docker** — платформа для запуска приложений в **контейнерах**: изолированных средах с мини-ОС, зависимостями и кодом. **Образ (image)** — шаблон, «архив» со всем нужным для запуска (ОС, среда, приложение, команда старта). **Контейнер** — уже запущенный экземпляр образа; из одного образа можно поднять много контейнеров. Контейнеры легче виртуальных машин (общее ядро хоста), запускаются быстро и дают изоляцию. **Dockerfile** — инструкции для сборки образа; **Docker Hub** (или другой реестр) — хранилище образов, откуда Docker тянет образы на сервер. Зачем: одинаковое окружение везде, деплой без ручной настройки; на фронте — сборка в контейнере, деплой образа с nginx и статикой.

---

## Что помнить к собеседованию

| Понятие | Коротко |
|--------|--------|
| **Образ** | Шаблон: всё для запуска приложения (мини-ОС, зависимости, код, команда). Не запущен. |
| **Контейнер** | Запущенное приложение из образа. Изоляция, ограничение ресурсов, быстро стартует. |
| **Docker** | Программа: собирает образы по Dockerfile и запускает контейнеры. |
| **Dockerfile** | Текстовый файл с инструкциями сборки образа (FROM, COPY, RUN, CMD и т.д.). |
| **Docker Hub** | Облачное хранилище образов; pull/push; много готовых образов (БД, Node, nginx). |
| **Чем контейнер лучше VM** | Легче, быстрее запуск, меньше ресурсов; изоляция и контроль ресурсов сохраняются. |

---

## Порты, тома, Compose, multi-stage и другие термины для собеседования

### Порты (port mapping)

Контейнер внутри слушает свой порт (например, 80 у nginx). С хоста к нему по умолчанию не достучаться — у контейнера своя сеть. **Проброс портов** (port mapping): порт хоста → порт контейнера (например, 8080:80). Тогда запрос на `localhost:8080` на твоей машине уходит в порт 80 контейнера. Зачем: зайти в приложение в контейнере с компа или извне.

**На собеседовании:** «Порты нужны, чтобы пробросить порт хоста на порт контейнера и получить доступ к приложению снаружи.»

---

### Тома (volumes)

Файлы внутри контейнера по умолчанию живут только пока контейнер жив: пересоздал контейнер — данные пропали. **Том (volume)** — каталог с хоста (или именованный том Docker) примонтирован внутрь контейнера. Всё, что приложение пишет в эту папку, остаётся на хосте и переживает пересоздание контейнера. Зачем: хранить данные БД, загруженные файлы; при разработке — подмонтировать исходники с хоста, чтобы менять код без пересборки образа.

**На собеседовании:** «Тома — чтобы данные не терялись при пересоздании контейнера и чтобы можно было подставить папку с хоста (например, код при разработке).»

---

### Docker Compose

Один контейнер — часто мало: нужны фронт, бэкенд, БД, nginx. **Docker Compose** — способ описать несколько контейнеров (сервисов) в одном файле (`docker-compose.yml`): какие образы, порты, тома, переменные окружения, зависимости (например, бэкенд ждёт запуска БД). Командой `docker-compose up` поднимаешь весь стек одной кнопкой. Зачем: локально или на стенде поднять целое приложение без ручного запуска каждого контейнера.

**На собеседовании:** «Compose — описание нескольких контейнеров в одном файле и их совместный запуск одной командой.»

---

### Multi-stage (многоэтапная сборка)

Обычно для сборки нужна тяжёлая среда (Node, компиляторы), а для запуска — только результат (например, статика и nginx). В одном **Dockerfile** можно описать несколько **стадий (stages)**: на первой — установить зависимости и собрать приложение (npm run build), на второй — взять только папку `dist`/`build` и положить в лёгкий образ с nginx. Итоговый образ не содержит Node и исходников — только статику и nginx. Зачем: меньший размер образа, быстрее деплой, меньше поверхность для атак.

**На собеседовании:** «Multi-stage — несколько этапов в одном Dockerfile: на одном этапе собираем, на другом — только результат в лёгкий образ; финальный образ без лишнего.»

---

### Другие полезные термины

| Термин | Что значит |
|--------|------------|
| **Base image (базовый образ)** | Образ, от которого наследуется твой (FROM node:18). Часто с Docker Hub: node, nginx, alpine. |
| **Tag (тег)** | Версия образа: `node:18`, `node:18-alpine`. Без тега подразумевается `latest`. |
| **Registry (реестр)** | Хранилище образов (Docker Hub, GitLab Registry, ECR). pull — скачать, push — загрузить. |
| **Layer (слой)** | Каждая инструкция в Dockerfile добавляет слой к образу. Слои кэшируются: пока зависимости не менялись, пересборка не нужна. |
| **Build** | Сборка образа из Dockerfile: `docker build -t my-app .` |
| **Run** | Запуск контейнера из образа: `docker run ...` |
| **ENV / переменные окружения** | Передаются в контейнер при запуске (API_URL, NODE_ENV). Разная конфигурация для dev/stage/prod без пересборки образа. |
| **WORKDIR** | Рабочая директория внутри контейнера; следующие команды выполняются в ней. |
| **COPY / ADD** | Копирование файлов с хоста в образ. |
| **CMD / ENTRYPOINT** | Команда, которая выполняется при старте контейнера. |

---

## Зачем Docker на фронтенде

- Одинаковое окружение в разработке, CI и проде (та же Node, те же зависимости).
- Сборка фронта в контейнере (npm run build) — в CI или multi-stage образ; итоговый образ — nginx + статика.
- Деплой — выкат одного образа на сервер или в облако, без «зайди и настрой».
- Локально можно поднять бэкенд, БД в контейнерах (docker-compose), фронт к ним подключается.
