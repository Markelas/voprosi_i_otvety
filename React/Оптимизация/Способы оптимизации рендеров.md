## ⚡ Способы оптимизации рендеров в React

**Краткий ответ для собеседования:**  
Основные способы оптимизации: `React.memo` для компонентов, `useMemo`/`useCallback` для мемоизации, оптимизация `useEffect` (удаление лишних зависимостей), код-сплиттинг (`React.lazy`), виртуализация длинных списков, минимизация бандла, правильные `key` для списков, избегание создания объектов/функций в JSX, оптимизация изображений, удаление циклических зависимостей.

---

## Инструменты для отслеживания производительности

Перед оптимизацией важно **измерить**: где тормозит, какие компоненты рендерятся лишний раз, сколько времени уходит на первый рендер и т.д. Основные инструменты:

### Lighthouse (Chrome DevTools)

**Что это:** встроенный в Chrome (вкладка Lighthouse в DevTools) или отдельный инструмент аудита. Запускает сценарий загрузки страницы и выдаёт отчёты по производительности, доступности, SEO, лучшим практикам.

**Зачем:** общая картина — медленная загрузка, большие ресурсы, долгие задачи в главном потоке, метрики (FCP, LCP, TBT, CLS). Показывает баллы и конкретные рекомендации (уменьшить JS, отложить неиспользуемый код, оптимизировать изображения). Удобно для «как мы выглядим по сравнению с лучшими практиками» и для проверки после оптимизаций.

### React DevTools — Profiler

**Что это:** вкладка Profiler в расширении React DevTools. Включаешь запись, выполняешь действия в приложении (переход, клик, ввод), останавливаешь — видишь, какие компоненты рендерились и сколько времени занял каждый рендер (commit).

**Зачем:** находить лишние ререндеры и тяжёлые компоненты. Если компонент рендерится при каждом клике родителя, хотя его props не менялись — кандидат для `React.memo` или пересмотра пропсов. Если один компонент тянет 50 ms — кандидат для разбиения или мемоизации. Без профилировщика оптимизация часто «вслепую».

### Chrome DevTools — Performance

**Что это:** вкладка Performance в DevTools. Запись таймлайна: JS, стили, layout, paint, загрузка ресурсов по времени.

**Зачем:** видеть долгие задачи (long tasks), частые reflow/repaint, что блокирует главный поток. Не привязано к React — общая картина работы браузера. Помогает связать «страница дёргается» с конкретными скриптами или операциями.

### Chrome DevTools — Network

**Что это:** вкладка Network — все запросы, размер, время, порядок загрузки.

**Зачем:** большие бандлы, дубли запросов, блокирующие ресурсы, медленный API. Оптимизация загрузки (код-сплиттинг, ленивая загрузка, прелоад) опирается на понимание того, что и когда грузится.

### Прочие

- **Bundle analyzer** (webpack-bundle-analyzer, source-map-explorer) — визуализация размера бандла: какие пакеты и модули сколько весят. Нужно для решения, что вынести в lazy или заменить более лёгкой библиотекой.
- **Why did you render** — библиотека, которая логирует в консоль причины ререндера компонентов (изменение каких props). Удобно в разработке для поиска лишних рендеров.

**На собеседовании:** перед оптимизацией важно измерять. Lighthouse — общий аудит и метрики; React DevTools Profiler — кто и как часто рендерится; Chrome Performance — что нагружает главный поток; Network — что и как грузится; bundle analyzer — что раздувает бандл.

---

## 1. Мемоизация компонентов и значений

### `React.memo` — мемоизация компонентов

**Что делает:**  
Предотвращает ререндер функционального компонента, если `props` не изменились (поверхностное сравнение).

**Когда использовать:**
- Компонент часто рендерится с теми же props
- Компонент тяжёлый (много элементов, вычислений)
- Родитель рендерится часто, а компонент — нет

**Кастомное сравнение:**

```jsx
const MyComponent = React.memo(Component, (prevProps, nextProps) => {
  // Вернуть true, если НЕ нужно рендерить
  return prevProps.id === nextProps.id;
});
```

**Важно:**  
Бесполезен, если в props передаются **новые объекты/функции** при каждом рендере (нужен `useMemo`/`useCallback`).

---

### `useMemo` — мемоизация вычислений

**Что делает:**  
Кэширует результат тяжёлых вычислений и пересчитывает только при изменении зависимостей.

**Когда использовать:**
- Тяжёлые вычисления (фильтрация, сортировка больших массивов)
- Создание объектов/массивов для `React.memo`-компонентов
- Избежание пересоздания ссылок

```jsx
const filteredList = useMemo(() => {
  return items.filter(item => item.active).sort((a, b) => a.price - b.price);
}, [items]);
```

**Не используй для:**
- Простых вычислений (дешевле пересчитать, чем мемоизировать)
- Значений, которые всегда меняются

---

### `useCallback` — мемоизация функций

**Что делает:**  
Возвращает мемоизированную версию функции, которая не пересоздаётся при каждом рендере.

**Когда использовать:**
- Передача функций в `React.memo`-компоненты
- Функции как зависимости в `useEffect`
- Избежание ререндеров дочерних компонентов

```jsx
const handleClick = useCallback(() => {
  doSomething(id);
}, [id]);

return <Child onClick={handleClick} />; // Child обёрнут в React.memo
```

---

## 2. Оптимизация useEffect

### Проблемы с useEffect

**Лишние зависимости:**  
Чем больше зависимостей — тем чаще эффект срабатывает → больше ререндеров.

**Решения:**
- **Удалить лишние зависимости** — используй только то, что реально меняется
- **Функциональный апдейт** `setState` — не добавлять state в зависимости:

```jsx
// ❌ Плохо
useEffect(() => {
  setCount(count + 1);
}, [count]); // count в зависимостях — бесконечный цикл

// ✅ Хорошо
useEffect(() => {
  setCount(prev => prev + 1);
}, []); // нет зависимостей
```

- **Разделить эффекты** — один эффект = одна задача (не смешивать логику)

**Циклические зависимости:**  
Эффект вызывает setState → ререндер → эффект снова → бесконечный цикл.

**Решение:**  
Проверить зависимости, использовать `useRef` для значений без ререндера.

---

## 3. Код-сплиттинг (Code Splitting)

**Что это:**  
Разделение бандла на части — загружается только нужный код, остальное — по требованию.

### `React.lazy` + `Suspense`

**Динамическая загрузка компонентов:**

```jsx
const HeavyComponent = React.lazy(() => import('./HeavyComponent'));

function App() {
  return (
    <Suspense fallback={<div>Загрузка...</div>}>
      <HeavyComponent />
    </Suspense>
  );
}
```

**Преимущества:**
- Уменьшение начального бандла
- Быстрая загрузка первой страницы (FCP, LCP)
- Компоненты загружаются по требованию

**Где использовать:**
- Роуты (разные страницы — разные чанки)
- Модальные окна, попапы
- Тяжёлые библиотеки (графики, редакторы)

**Route-based code splitting:**

```jsx
const Home = React.lazy(() => import('./pages/Home'));
const About = React.lazy(() => import('./pages/About'));

<Routes>
  <Route path="/" element={<Suspense fallback={<Loader />}><Home /></Suspense>} />
  <Route path="/about" element={<Suspense fallback={<Loader />}><About /></Suspense>} />
</Routes>
```

---

## 4. Оптимизация рендеринга списков

### Правильные `key`

**Проблема:**  
Неправильный `key` (индекс массива) → React не может определить, что изменилось → лишние рендеры.

```jsx
// ❌ Плохо — индекс как key
{items.map((item, index) => <Item key={index} {...item} />)}

// ✅ Хорошо — уникальный стабильный ID
{items.map(item => <Item key={item.id} {...item} />)}
```

**Правила:**
- `key` должен быть уникальным и стабильным (не меняться между рендерами)
- Не использовать индекс, если список может изменяться (добавление/удаление)

---

### Виртуализация (Windowing)

**Проблема:**  
Длинный список (1000+ элементов) → все рендерятся в DOM → медленно.

**Решение:**  
Рендерить только **видимые элементы** (виртуализация).

**Библиотеки:**
- **react-window** (лёгкая)
- **react-virtualized** (больше возможностей)

```jsx
import { FixedSizeList } from 'react-window';

<FixedSizeList
  height={400}
  itemCount={1000}
  itemSize={35}
>
  {({ index, style }) => <div style={style}>Item {index}</div>}
</FixedSizeList>
```

**Преимущества:**
- Рендерятся только ~20-30 элементов вместо 1000+
- Быстрая прокрутка, меньше памяти

---

## 5. Минимизация размера бандла

### Tree Shaking

**Что это:**  
Удаление неиспользуемого кода при сборке.

**Как использовать:**
- Импорты ES6 (`import`/`export`)
- Избегать `import *` — импортировать только нужное:

```jsx
// ❌ Плохо
import * as _ from 'lodash';

// ✅ Хорошо
import debounce from 'lodash/debounce';
```

---

### Анализ бандла

**Инструменты:**
- `webpack-bundle-analyzer` — визуализация размера модулей
- `source-map-explorer` — анализ source maps

**Что искать:**
- Дубликаты библиотек
- Неиспользуемые зависимости
- Тяжёлые библиотеки (можно заменить на лёгкие аналоги)

---

### Удаление неиспользуемых зависимостей

- Проверка: `npm ls`, `depcheck`
- Удаление: `npm uninstall <package>`
- Заменить тяжёлые библиотеки: `moment.js` → `date-fns`, `lodash` → нативные методы

---

## 6. Избегайте тяжёлых вычислений в основном потоке

**Проблема:**  
Тяжёлые синхронные вычисления (обработка больших данных, парсинг) блокируют UI.

**Решения:**

### Web Workers

Выполнение вычислений в отдельном потоке:

```jsx
const worker = new Worker('worker.js');
worker.postMessage(data);
worker.onmessage = (e) => setResult(e.data);
```

### Debounce / Throttle

Ограничение частоты вызова функций (поиск, скролл):

```jsx
const debouncedSearch = useMemo(() => 
  debounce((value) => search(value), 300),
  []
);
```

---

## 7. Оптимизация изображений

**Проблемы:**
- Большие изображения → долгая загрузка → медленная отрисовка

**Решения:**

### Ленивая загрузка (Lazy Loading)

```jsx
<img src="image.jpg" loading="lazy" alt="..." />
```

### Современные форматы

- **WebP** — на 25-35% меньше, чем JPEG
- **AVIF** — ещё меньше

### Responsive изображения

```jsx
<picture>
  <source srcSet="image-small.webp" media="(max-width: 600px)" type="image/webp" />
  <source srcSet="image-large.webp" media="(min-width: 601px)" type="image/webp" />
  <img src="image.jpg" alt="..." />
</picture>
```

### CDN и оптимизация

- Использовать CDN (Cloudflare, Cloudinary)
- Сжатие, ресайз, конвертация в WebP

---

## 8. Избегайте создания объектов/функций в JSX

**Проблема:**  
Новый объект/функция при каждом рендере → `React.memo` не работает.

```jsx
// ❌ Плохо — новый объект при каждом рендере
<Child style={{ color: 'red' }} />

// ✅ Хорошо — стабильная ссылка
const style = { color: 'red' };
<Child style={style} />

// Или useMemo
const style = useMemo(() => ({ color: 'red' }), []);
```

---

## 9. Удаление циклических зависимостей

**Проблема:**  
Модуль A импортирует B, B импортирует A → замедление сборки, проблемы с tree shaking.

**Решение:**
- Рефакторинг — вынести общую логику в отдельный модуль
- Использовать динамические импорты

---

## 10. Другие приёмы

### Debounce для обработчиков

Ограничение частоты вызова (поиск, ресайз):

```jsx
const handleSearch = useMemo(() => 
  debounce((value) => fetchResults(value), 300),
  []
);
```

### Избегать `inline styles` в циклах

Каждый элемент получает новый объект:

```jsx
// ❌ Плохо
{items.map(item => <div style={{ color: 'red' }}>{item}</div>)}

// ✅ Хорошо
const itemStyle = { color: 'red' };
{items.map(item => <div style={itemStyle}>{item}</div>)}
```

### Использовать CSS вместо JS

Анимации через CSS (`transition`, `animation`) быстрее, чем через JS.

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Как оптимизировать ререндеры? | `React.memo`, `useMemo`, `useCallback`, оптимизация `useEffect` |
| Что такое код-сплиттинг? | Разделение бандла на части, загрузка по требованию (`React.lazy`) |
| Как оптимизировать длинные списки? | Виртуализация (react-window), правильные `key` |
| Зачем виртуализация списков? | Рендерятся только видимые элементы → меньше DOM-узлов, быстрее |
| Как уменьшить размер бандла? | Tree shaking, удаление неиспользуемых зависимостей, замена тяжёлых библиотек, код-сплиттинг |
| Почему `useEffect` может вызывать лишние рендеры? | Лишние зависимости, циклические зависимости |
| Как оптимизировать изображения? | Lazy loading, WebP, responsive images, CDN |
| Почему не стоит создавать объекты в JSX? | Новая ссылка при каждом рендере → `React.memo` не работает |

---

## Кратко для ответа

Основные способы оптимизации: `React.memo` (мемоизация компонентов), `useMemo`/`useCallback` (мемоизация значений/функций), оптимизация `useEffect` (удаление лишних зависимостей, функциональный апдейт), код-сплиттинг через `React.lazy` (уменьшение начального бандла), виртуализация длинных списков (react-window), минимизация бандла (tree shaking, удаление неиспользуемого), правильные `key` для списков, избегание создания объектов/функций в JSX, оптимизация изображений (lazy loading, WebP).
