# Почему React не реактивный

## Краткий ответ для собеседования

**React не реактивный** в том смысле, что обновление UI не привязано автоматически к изменению данных. Изменение данных само по себе ничего не перерисовывает: нужно **явно** обновить состояние через `setState`/`useState`, тогда React запланирует ререндер. Какие компоненты перерисовать и когда — решает React по правилам (родитель обновился, пропсы/стейт изменились), а не «подписка на поля» как во Vue или MobX. Поэтому контроль с нашей стороны: мы решаем, что считать состоянием и когда его менять.

---

## Что значит «реактивный»

В **реактивной** модели данные объявлены как «наблюдаемые»; при их изменении автоматически пересчитываются зависимые части (вычисляемые значения, компоненты). Разработчик не вызывает «обнови экран» — система сама отслеживает, кто от каких полей зависит, и обновляет только их. Примеры: Vue (реактивные данные), MobX (observable).

В **нереактивной** модели изменение данных не ведёт само по себе к обновлению экрана. Нужно явно сообщить системе: «состояние изменилось, перерисуй». Кто именно перерисуется — решает система по своим правилам (дерево компонентов, пропсы, стейт). Пример: React.

---

## Почему React считают нереактивным

### 1. Явное обновление состояния

В React обновление интерфейса всегда инициируется **явным** вызовом обновления состояния: `setState`, `useState` (setter), `useReducer` (dispatch). Пока ты не вызвал setState, никакой ререндер из-за «просто изменившихся данных» не произойдёт.

Пример: если у тебя есть объект в переменной и ты сделал `obj.name = 'New'`, React об этом не узнает и экран не обновится. Нужно положить новое значение в состояние через setState/setter — тогда React запланирует ререндер.

То есть **связь «данные изменились → экран обновился» не автоматическая**, её обеспечивает разработчик, вызывая API состояния.

### 2. Нет автоматического отслеживания зависимостей

React не отслеживает, «какие поля данных читал этот компонент». Он не строит граф зависимостей «компонент — поле объекта». Ререндер происходит по правилам: компонент получил новый вызов (родитель ререндерился) и у него изменились пропсы или собственное состояние (по ссылке/примитиву). Что именно «подписано» на какое поле — React не знает.

Поэтому, например, мутация вложенного объекта без вызова setState не приведёт к ререндеру: ссылка на объект в стейте та же, React не видит изменения.

### 3. Ререндер — от корня вниз по дереву

React не обновляет «только тот компонент, который зависит от этого поля». Он идёт от компонента, в котором вызвали setState, вниз по дереву: решает, какие дочерние компоненты перерисовать, сравнивая пропсы и опционально мемо. То есть модель обновления — **дерево и дифф**, а не «подписки на поля».

Контроль с нашей стороны: мы решаем, **что** хранить в состоянии, **где** (в каком компоненте) и **когда** вызывать setState. От этого зависит, сколько компонентов ререндерится и как часто.

### 4. Иммутабельность и ссылки

React ориентирован на обновление через **новые** объекты/массивы, а не мутацию. Сравнение «изменилось ли состояние» делается по ссылке (для объектов) или по значению (для примитивов). Мутация без смены ссылки не считается изменением — ререндер не запустится. Это ещё раз подчёркивает: «реакции» на изменение данных нет, есть только реакция на вызов setState с новым значением/ссылкой.

---

## Что требует контроля с нашей стороны

- **Где хранить состояние:** в каком компоненте или во внешнем сторе (Redux, Zustand и т.д.). От этого зависит, кто ререндерится при обновлении.
- **Когда вызывать setState:** при каком событии, ответе сервера, таймере. Без вызова setState экран не обновится.
- **Что класть в состояние:** примитивы, неизменяемые структуры (новые объекты/массивы при изменении). Мутации без setState React не учитывает.
- **Оптимизация ререндеров:** при необходимости — мемо (React.memo, useMemo, useCallback), чтобы лишние ререндеры не тянули за собой тяжёлые поддеревья.
- **Порядок и батчинг:** понимание, что несколько setState в одном обработчике могут схлопнуться в один ререндер (автоматический батчинг в React 18).

То есть «реактивность» в React — это не «данные изменились, всё само обновилось», а «мы явно обновили состояние, и React по своим правилам перерисовал дерево». Контроль за тем, что считать состоянием и когда его менять, полностью у разработчика.

---

## Сравнение с реактивными подходами (Vue, MobX)

Во **Vue** данные в `data`/`reactive` отслеживаются; при изменении поля автоматически обновляются компоненты, которые это поле использовали. Не нужно вызывать аналог setState — достаточно присвоить значение полю.

В **MobX** помечаешь объекты как observable; при изменении полей автоматически перерисовываются компоненты, которые их читали. Тоже без явного «обнови вид».

В **React** такой автоматической связи нет: только вызов setState/setter запускает обновление. Поэтому React и называют нереактивным: реакция привязана к нашему действию (вызов setState), а не к самому факту изменения данных в памяти.

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Почему React не реактивный? | Обновление UI только после явного setState/useState; нет автоматического отслеживания «кто от каких полей зависит». |
| Что нужно делать, чтобы экран обновился? | Явно обновить состояние через setState (или аналог); положить в состояние новое значение/ссылку. |
| Почему мутация объекта без setState не обновляет экран? | React не отслеживает мутации; сравнение по ссылке — ссылка та же, ререндер не запускается. |
| Чем React отличается от Vue по обновлению? | Во Vue изменение реактивных данных само обновляет компоненты; в React нужно вызвать setState. |
| Что в React под нашим контролем? | Где хранить состояние, когда вызывать setState, что класть в состояние (иммутабельность), при необходимости — мемо и структура дерева. |

---

## Кратко для ответа

React не реактивный: экран обновляется только после **явного** обновления состояния (setState/useState). Нет автоматического отслеживания зависимостей «компонент — поле»; ререндер идёт по дереву от того места, где вызвали setState. Контроль с нашей стороны: что считать состоянием, когда его менять и как оптимизировать ререндеры. В реактивных системах (Vue, MobX) изменение данных само запускает обновление зависимых частей; в React запускает только наш вызов setState.
