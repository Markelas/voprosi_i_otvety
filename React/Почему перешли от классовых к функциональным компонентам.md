# Почему перешли от классовых к функциональным компонентам

## Краткий ответ для собеседования

С появлением **хуков в React 16.8** функциональные компоненты получили всё, что было у классов (состояние, lifecycle), но проще в написании, лучше переиспользуются и легче тестируются. Классы остались только для ErrorBoundary.

---

## Основные причины перехода

### 1. **Хуки решили проблему переиспользования логики**

**Проблема в классах:**
- Дублирование логики между компонентами
- Сложные паттерны: HOC (Higher-Order Components), Render Props
- "Wrapper hell" — множество вложенных компонентов

**Решение через хуки:**
- **Кастомные хуки** позволяют переиспользовать логику состояния без изменения структуры компонентов
- Простое извлечение и повторное использование

**Пример:**  
Вместо HOC для отслеживания размера окна — кастомный хук `useWindowSize()`.

---

### 2. **Проще и лаконичнее код**

**Классы требуют:**
- Ключевое слово `class`, `extends`
- Конструктор для инициализации state
- Биндинг методов (`this.handleClick = this.handleClick.bind(this)`)
- Понимание `this` (частый источник багов)

**Функции:**
- Обычная функция
- `useState` для состояния
- Нет `this` — замыкания решают всё
- Меньше кода, проще читать

---

### 3. **Логика размазана в классах**

**Проблема классов:**  
Связанная логика размазывается по разным lifecycle-методам:
- Подписка в `componentDidMount`
- Отписка в `componentWillUnmount`
- Обновление в `componentDidUpdate`

**Хуки объединяют логику:**  
`useEffect` собирает связанную логику в одном месте:

```js
useEffect(() => {
  // Подписка
  const subscription = props.source.subscribe();
  
  // Очистка (отписка)
  return () => subscription.unsubscribe();
}, [props.source]);
```

Вся логика подписки — в одном месте, а не размазана по трём методам.

---

### 4. **Проблема с `this` в классах**

**Частые ошибки:**
- Забыли забиндить метод — `this` будет `undefined`
- Сложно понять контекст `this` для новичков
- Нужны стрелочные функции или `.bind()` в конструкторе

**В функциях:**  
Нет `this` — всё работает через замыкания, понятнее и безопаснее.

---

### 5. **Оптимизация и производительность**

**Классы:**
- Больше кода под капотом (прототипы, наследование)
- Сложнее минифицировать и оптимизировать

**Функции:**
- Легче минифицируются
- Меньше синтаксического сахара
- Лучше для tree-shaking

---

### 6. **Lifecycle-методы избыточны**

В большинстве случаев нужен только `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`.  
**`useEffect`** заменяет все три одной конструкцией.

---

### 7. **Легче тестировать**

**Функции:**
- Проще тестировать — чистые функции
- Кастомные хуки можно тестировать отдельно

**Классы:**
- Нужно создавать инстансы
- Мокать методы сложнее

---

### 8. **Лучше для будущего React**

**Concurrent Mode и Fiber:**  
Архитектура React всё больше ориентируется на функциональную модель. Хуки изначально проектировались с учётом новых возможностей (приоритизация, прерывание рендера).

---

## Что осталось от классов

**ErrorBoundary** — пока единственная причина использовать классы.  
Нет хука-аналога для `componentDidCatch` и `getDerivedStateFromError`.

---

## Сравнение: класс vs функция

| Аспект | Классовый компонент | Функциональный с хуками |
|--------|---------------------|-------------------------|
| **Состояние** | `this.state`, `this.setState()` | `useState()` |
| **Lifecycle** | Несколько методов (Did, Will, Update) | `useEffect()`, `useLayoutEffect()` |
| **Переиспользование логики** | HOC, Render Props | Кастомные хуки |
| **`this`** | Нужен, источник ошибок | Не нужен |
| **Объём кода** | Больше | Меньше |
| **Читаемость** | Логика размазана по методам | Логика в одном месте |
| **Тестирование** | Сложнее | Проще |
| **Будущее** | Устаревает | Основной способ |

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Почему перешли на функциональные компоненты? | Хуки упростили код, решили проблему переиспользования логики, убрали `this`, объединили lifecycle |
| Что было не так с классами? | Логика размазана по lifecycle-методам, проблемы с `this`, сложное переиспользование (HOC/Render Props) |
| Когда ещё нужны классы? | Только для ErrorBoundary (нет хука-аналога) |
| Что такое HOC и Render Props? | Паттерны для переиспользования логики в классах; хуки сделали их почти ненужными |
| В чём преимущество useEffect? | Объединяет связанную логику (подписка + очистка) в одном месте вместо трёх lifecycle-методов |
| Можно ли использовать классы сейчас? | Да, они работают, но новые компоненты лучше писать как функции с хуками |

---

## Кратко

Переход на функциональные компоненты произошёл с появлением хуков (React 16.8): они упростили код, решили проблему переиспользования логики (кастомные хуки вместо HOC/Render Props), убрали проблемы с `this`, объединили lifecycle-логику в одном месте. Классы остались только для ErrorBoundary.
