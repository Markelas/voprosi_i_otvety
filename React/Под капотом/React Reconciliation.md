# React Reconciliation

## Краткий ответ для собеседования

**Reconciliation (согласование)** — процесс, в котором React сравнивает новое дерево компонентов со старым и решает, какие изменения внести в реальный DOM. **Diffing** (сравнение деревьев) выполняется на фазе **Render**; **patching** (применение изменений к DOM) — на фазе **Commit**. Цель: обновить экран с минимальным числом операций. React опирается на эвристики: тот же тип элемента — обновляем узел; разный тип — заменяем целиком; в списках важны стабильные ключи. Результат diffing — список эффектов; на коммите этот список применяется к DOM.

---

## Что такое Reconciliation

**Reconciliation** — это механизм React, который **согласовывает** новое описание интерфейса (новое дерево элементов/компонентов) со старым и определяет **минимальный набор изменений** для реального DOM.

Простыми словами: после того как состояние или пропсы изменились, React заново «рисует» дерево компонентов в памяти. Потом он **сравнивает** это новое дерево с тем, что было раньше, и решает: что оставить, что обновить, что удалить, что добавить. Не перерисовывает всё с нуля, а вносит только нужные правки.

---

## Зачем это нужно

Прямые операции с DOM (создать узел, удалить, изменить атрибут) дорогие для браузера. Если при каждом изменении данных перестраивать всю страницу целиком, приложение будет тормозить.

Reconciliation даёт возможность:
- **Сравнивать** новое и старое дерево в памяти (быстро, это просто объекты).
- **Вычислять** только то, что реально изменилось.
- **Применять** к реальному DOM только этот минимальный набор изменений.

В итоге браузер делает меньше тяжёлых операций, интерфейс остаётся отзывчивым.

---

## С чем именно сравнивает React

React сравнивает не строки HTML и не «сырой» DOM. Он сравнивает **дерево элементов** (в старых версиях — Virtual DOM, в текущей архитектуре — дерево fiber-узлов). Каждый узел — это тип элемента (тег или компонент), пропсы и дети. React обходит оба дерева и на каждом уровне решает: тот же узел или нет, обновить или заменить.

То есть согласование идёт на уровне **логической структуры** (какой компонент, какие пропсы, какие дети), а не на уровне байтов или HTML-тегов.

---

## Две фазы: Render и Commit

**Diffing** (сравнение деревьев) выполняется на фазе **Render**. **Patching** (применение изменений к реальному DOM) выполняется на фазе **Commit**.

- **Render-фаза:** React строит новое дерево (или обновлённое представление), **сравнивает** его со старым (**diffing**) и помечает, что нужно сделать с DOM: добавить узел, обновить, удалить. Формируется список эффектов — «план изменений». DOM при этом **не трогается**. В архитектуре Fiber эту фазу можно прерывать и возобновлять.
- **Commit-фаза:** React **применяет** накопленный список изменений к реальному DOM (**patching**): создаёт узлы, обновляет атрибуты, удаляет лишнее. Выполняется синхронно, без прерываний, чтобы пользователь не видел «полусобранный» интерфейс.

На собеседовании: **diffing — в render, patching — в commit**. Reconciliation (согласование) — это по сути diffing на фазе рендера; коммит — это уже patching, применение результата к DOM.

Последний элемент в дереве — leaf.

---

### Таблица этапов (порядок фаз)

| Фаза | Что происходит | Результат |
|------|----------------|-----------|
| **1. Render (рендер)** | Построение нового дерева (fiber) по текущим state/props | Новое дерево в памяти |
| **2. Render (diffing)** | Сравнение нового дерева со старым; решение по каждому узлу: оставить, обновить, заменить, удалить | Список эффектов (effect list) — план изменений для DOM |
| **3. Commit (patching)** | Применение списка эффектов к реальному DOM: создание узлов, обновление атрибутов и детей, удаление узлов | Обновлённый DOM на экране |

**Кратко:** Render = «посчитали, что менять» (дерево + diffing), Commit = «применили к DOM» (patching).

---

## Правила сравнения (эвристики React)

React не перебирает все возможные способы «перейти» от старого дерева к новому (это было бы слишком дорого). Он использует **эвристики** — упрощённые правила, которые в большинстве случаев дают правильный и быстрый результат.

### 1. Разный тип элемента на одном уровне — замена целиком

Если на одном и том же уровне дерева в старом дереве был, например, `div`, а в новом — `span` (или был компонент `Button`, а стал `Link`), React **не пытается** обновить старый узел. Он считает, что это уже другой элемент: старый удаляется вместе со всем поддеревом, новый создаётся и вставляется с нуля.

Почему так: разные типы элементов ведут себя по-разному (другой DOM-узел, другая логика компонента). Сравнивать и «мержить» их сложно и часто бессмысленно. Проще заменить.

### 2. Один и тот же тип элемента — обновление узла

Если на одном уровне в старом и новом дереве один и тот же тип (тот же тег или тот же компонент), React оставляет существующий DOM-узел (или инстанс компонента) и **обновляет** только то, что изменилось: атрибуты, пропсы, затем рекурсивно согласовывает детей.

Так минимизируется количество операций с DOM: не удаляем и не создаём узел заново, а только правим свойства и детей.

### 3. Рекурсия по детям

После того как React решил, что узел «тот же» и его нужно обновить, он переходит к списку дочерних элементов и применяет те же правила к каждому ребёнку. Так обход идёт сверху вниз по дереву, один проход.

### 4. Списки и ключи (key)

Списки — самое тонкое место. Без дополнительной информации React не знает, «кто есть кто» при изменении порядка, добавлении или удалении элементов. Он сравнивает детей по позиции: первый с первым, второй со вторым и т.д. Поэтому при вставке элемента в начало списка React может решить, что «всё сдвинулось», и пересоздать много узлов вместо того, чтобы переместить один.

**Ключ (key)** — это подсказка React: «этот элемент в старом дереве и этот элемент в новом — один и тот же сущностно». Тогда React может сопоставить их и решить: обновить на месте, переместить или удалить. В результате список обновляется с минимальными операциями: переиспользуются существующие узлы, а не пересоздаётся весь список.

**Стабильный и уникальный ключ** — тот, который не меняется между рендерами и разный у разных элементов списка. Часто используют id из данных. Не используют индекс массива как ключ, если список может меняться (сортировка, добавление, удаление), иначе согласование будет работать неправильно и возможны лишние ререндеры и баги.

---

## Что получается в итоге согласования

В процессе reconciliation React не меняет DOM сразу. Он формирует **список эффектов** (effect list): какие узлы создать, обновить, удалить, в каком порядке. Этот список привязан к узлам дерева (в Fiber — к fiber-узлам). На фазе Commit React в одном проходе применяет эти эффекты к реальному DOM: добавляет новые узлы, обновляет атрибуты и детей, удаляет лишнее.

Так что «результат» reconciliation — это именно этот план изменений, а не сами мутации DOM; мутации выполняются на фазе коммита.

---

## Связь с Virtual DOM и Fiber

- **Virtual DOM** — идея хранить описание интерфейса в виде дерева объектов в памяти и сравнивать его с предыдущим деревом, чтобы минимизировать обращения к реальному DOM. Reconciliation — это и есть алгоритм такого сравнения.
- **Fiber** — текущая реализация reconciler в React. Дерево представлено не «просто» объектами Virtual DOM, а **fiber-узлами** (с полями child, sibling, return и т.д.), что позволяет разбивать работу на куски, приостанавливать и возобновлять её. Но суть согласования та же: сравнить новое дерево со старым и вычислить минимальный набор изменений.

То есть можно сказать: reconciliation — это алгоритм сравнения деревьев; в React 16+ он реализован внутри архитектуры Fiber и по-прежнему опирается на тип элемента, ключи и обход по дереву.

---

## Почему важно понимать ключи

Без ключей или с плохими ключами (например, индекс в изменяемом списке) React не может надёжно сопоставить старые и новые элементы. Он будет чаще считать, что элементы «другие», и пересоздавать узлы вместо обновления и перемещения. Это ведёт к лишним операциям с DOM, потере фокуса и внутреннего состояния компонентов (например, ввод в поле), а иногда к визуальным багам (не те данные в не той строке).

Поэтому на собеседовании важно сказать: в списках нужны стабильные уникальные ключи, чтобы reconciliation работал корректно и эффективно.

---

## Ограничения подхода

React не гарантирует «идеально минимальный» набор изменений. Он гарантирует **достаточно хороший** за один проход по дереву за линейное время. В редких случаях ручная работа с DOM могла бы дать меньше операций, но в подавляющем большинстве приложений эвристики React дают отличный результат без необходимости думать об этом самому.

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Что такое React Reconciliation? | Процесс сравнения нового дерева компонентов со старым и вычисления минимального набора изменений для DOM. |
| Зачем нужен reconciliation? | Чтобы не перестраивать весь DOM, а вносить только нужные изменения и не тормозить интерфейс. |
| Что сравнивает React? | Дерево элементов/компонентов (тип, пропсы, дети), а не HTML-строки и не «сырой» DOM. |
| Что происходит, если тип элемента на одном уровне разный? | React удаляет старый узел и всё его поддерево и создаёт новый узел с нуля. |
| Что происходит, если тип тот же? | React оставляет узел и обновляет только изменившиеся пропсы/атрибуты и рекурсивно согласовывает детей. |
| Зачем нужны ключи (key) в списках? | Чтобы React мог сопоставить элемент в старом и новом списке и решить: обновить, переместить или удалить, а не пересоздавать узлы по позиции. |
| Почему не используют индекс как key при динамических списках? | При изменении порядка/добавлении/удалении индексы сдвигаются, React неправильно сопоставляет элементы — лишние обновления и баги. |
| На какой фазе происходит reconciliation? | Diffing (сравнение деревьев) — на фазе Render; patching (применение к DOM) — на фазе Commit. |
| Как reconciliation связан с Fiber? | В React 16+ согласование реализовано внутри Fiber: обход по fiber-дереву, список эффектов, затем коммит. |

---

## Кратко для ответа

Reconciliation — сравнение нового дерева со старым и вычисление минимального набора изменений. **Diffing** (сравнение) — на фазе **Render**; **patching** (применение к DOM) — на фазе **Commit**. React сравнивает по типу элемента и по ключам в списках; один тип — обновляем узел, разный — заменяем целиком. В списках нужны стабильные уникальные ключи. В React 16+ реализовано в архитектуре Fiber.
