# React Fiber

## Понятным языком: все этапы и зачем они нужны

Чтобы запомнить и рассказать на собеседовании, удобно идти по шагам: что происходит с момента обновления до появления новой картинки на экране.

---

### Идея одной фразой

**Раньше** React обрабатывал обновление «одним большим куском»: прошёл по всему дереву, всё пересчитал, разом обновил DOM. Прервать это было нельзя — пока он не закончит, ввод с клавиатуры и анимации «подвисали».

**С Fiber** работа разбита на маленькие шаги (каждый шаг — один fiber-узел), и есть **две отдельные стадии**: сначала React **только считает**, что нужно поменять (эту стадию можно прерывать), потом **один раз применяет** все изменения к DOM (эту стадию не прерывают). Так он может между шагами «отвлечься» на срочное (например, ввод пользователя) и потом вернуться к расчётам.

---

### Этап 0: Откуда вообще берётся работа

Пользователь что-то сделал или пришли новые данные → вызывается `setState` / обновление props. React получает **запрос на обновление** и ставит его в очередь с учётом приоритета (ввод — срочно, фоновое обновление списка — можно позже). Дальше планировщик решает, когда начать обрабатывать это обновление.

**Зачем:** чтобы React мог отложить некритичные обновления и сначала обработать то, что важно для отзывчивости (клики, ввод).

---

### Этап 1: Два дерева — current и work-in-progress

У React всегда есть **текущее дерево** (current) — то, что сейчас на экране. Каждый узел в нём — это **fiber**: объект с полями вроде `type`, `props`, ссылками на дочерние и соседние узлы (`child`, `sibling`, `return`).

Когда начинается обновление, React **не меняет current сразу**. Он создаёт второе дерево — **work-in-progress (WIP)**. По сути это «черновик»: React копирует/строит узлы, помечает, что изменилось, и только когда черновик полностью готов — меняет указатель: WIP становится новым current. Это называется **двойная буферизация**.

**Зачем:** чтобы в любой момент на экране было согласованное состояние. Мы не показываем «полуобновлённый» интерфейс: либо старое дерево, либо уже полностью новое после коммита.

---

### Этап 2: Render Phase (фаза рендеринга) — «посчитать, что менять»

В этой фазе React **проходит по WIP-дереву** и для каждого fiber-узла:

- вызывает твой код: функцию компонента или `render()` у класса;
- получает новый React-элемент (что компонент хочет отрисовать);
- сравнивает с тем, что было в current-дереве (reconciliation);
- решает: узел нужно **вставить** (PLACEMENT), **обновить** (UPDATE) или **удалить** (DELETION);
- записывает это в fiber (например, в `effectTag`) и добавляет узел в список **effects** (список «что потом сделать с DOM»).

При этом **DOM не трогают** — только вызывают чистые функции и пишут в память (в fiber-узлы и список effects). Поэтому эту фазу **можно прерывать**: если пришло срочное обновление (клик, ввод), React может бросить текущий проход, обработать срочное, потом заново или с того же места продолжить расчёт. Из-за этого методы вроде `render()` и тело функционального компонента могут вызываться **несколько раз** — они должны быть без побочных эффектов.

**Зачем:** вся «тяжёлая» и прерываемая работа — здесь. Разбиение на fiber-узлы даёт точки, в которых можно остановиться и позже продолжить, не блокируя UI.

---

### Этап 3: Commit Phase (фаза коммита) — «сделать изменения в DOM»

Когда Render Phase полностью закончилась, список effects готов. Наступает **Commit Phase**:

- React **один раз подряд** проходит по списку effects и **применяет** их к реальному DOM: вставляет узлы (PLACEMENT), обновляет атрибуты/содержимое (UPDATE), удаляет узлы (DELETION).
- После обновления DOM вызываются «после-отрисовочные» вещи: `componentDidMount` / `componentDidUpdate`, `useLayoutEffect`, затем (уже асинхронно) планируются `useEffect`.

Эту фазу React **не прерывает**: она выполняется синхронно, за один заход. Иначе пользователь мог бы увидеть несогласованное состояние DOM (половина обновлена, половина нет).

**Зачем:** дать браузеру один цельный набор изменений и только потом запускать эффекты. Так интерфейс остаётся предсказуемым и без «мельканий» из-за прерывания в середине.

---

### Этап 4: Поменять указатель и обновить refs

После коммита WIP-дерево становится **новым current** (указатель переключается). Старое current можно выбросить или переиспользовать как будущий WIP. Обновляются refs на DOM-узлы. Пользователь видит финальный результат.

**Зачем:** зафиксировать новое состояние как текущее и подготовить дерево к следующему циклу обновлений.

---

### Сводка этапов одной фразой каждый

| Этап | Что делаем | Зачем |
|------|------------|--------|
| **Обновление в очереди** | setState/props → задача с приоритетом в очередь | Можно отложить некритичное, сначала обработать ввод/клики |
| **Два дерева** | Есть current (на экране) и WIP (черновик) | Не показывать «полуготовый» UI; двойная буферизация |
| **Render Phase** | Обходим WIP, вызываем компоненты, сравниваем с current, пишем список effects. DOM не трогаем | Посчитать все изменения; фазу можно прерывать, поэтому UI не блокируется |
| **Commit Phase** | По списку effects меняем DOM, вызываем layoutEffect/useEffect и lifecycle | Применить изменения за один раз, без прерываний — согласованный UI |
| **Смена current** | WIP становится current, обновляются refs | Зафиксировать новое состояние, готовность к следующему обновлению |

На собеседовании можно сказать: **«Fiber делит работу на две фазы: сначала только считаем изменения по дереву fiber-узлов, эту фазу можно прерывать; потом за один проход применяем все изменения к DOM — эту фазу не прерываем. Так React не блокирует главный поток надолго и может приоритизировать обновления.»**

---

## Краткий ответ для собеседования

**React Fiber** — новая архитектура reconciler в React 16+. Разбивает рендеринг на маленькие единицы работы (fiber-узлы), позволяет прерывать, возобновлять и приоритизировать обновления. Состоит из двух фаз: **Render** (прерываемая, вычисляет изменения) и **Commit** (непрерываемая, применяет изменения к DOM). Fiber-дерево — это связанный список узлов с информацией о компонентах. Появился для реализации **Concurrent Mode** — рендеринг с приоритетами для плавного UI.

---

## Что такое React Fiber

**React Fiber** — это **новая имплементация ядра React** (reconciler), которая была представлена в React 16 (2017).

**Основная цель:**  
Сделать рендеринг **прерываемым** и **приоритизируемым** — React может прерывать работу, чтобы обработать более важные задачи (например, пользовательский ввод), а потом вернуться к прежней работе.

**Что изменилось:**
- **Старый алгоритм (Stack Reconciler)** — синхронный, блокирующий, рекурсивный
- **Fiber** — асинхронный, прерываемый, итеративный (через связанный список)

---

## Почему появился Fiber

### Проблемы старого Stack Reconciler

1. **Блокировка UI** — рендеринг был синхронным, нельзя было прервать
2. **Долгие обновления** — большое дерево компонентов могло "заморозить" UI
3. **Нет приоритетов** — все обновления обрабатывались одинаково
4. **60 FPS** — если рендеринг занимал > 16ms (1/60 секунды), анимации "лагали"

**Пример:**  
Печатаешь в input → React рендерит большой список → ввод "тормозит" (UI заблокирован).

### Решение: Fiber

- **Прерываемый рендеринг** — можно остановиться, обработать ввод, продолжить
- **Приоритеты** — важные обновления (ввод) выполняются раньше неважных (фоновая загрузка)
- **Плавный UI** — никаких "заморозок"

---

## Что такое Fiber (узел)

**Fiber** — это **объект JavaScript**, который представляет **единицу работы** (компонент, DOM-элемент).

**Структура fiber-узла (упрощённо):**

```js
{
  type: 'div',              // тип элемента (div, span, функция-компонент)
  props: { ... },           // props компонента
  stateNode: DOMElement,    // ссылка на реальный DOM-узел
  child: Fiber,             // первый дочерний fiber
  sibling: Fiber,           // следующий sibling fiber
  return: Fiber,            // родительский fiber
  alternate: Fiber,         // fiber из предыдущего дерева (для сравнения)
  effectTag: 'PLACEMENT',   // тип изменения (создать, обновить, удалить)
}
```

**Важно:**  
Fiber-узлы связаны через **child**, **sibling**, **return** → образуют **связанный список** (а не дерево в классическом понимании).

---

## Fiber-дерево

React создаёт **два fiber-дерева**:

### 1. Current Fiber Tree

**Отображается на экране** — текущее состояние UI.

### 2. Work-in-Progress (WIP) Fiber Tree

**Новое дерево**, которое React строит во время обновления.

**Процесс:**
1. React получает обновление (`setState`, новые props)
2. Создаёт WIP-дерево (клонирует + применяет изменения)
3. Когда WIP готов → **меняет указатель**: WIP становится Current

**Это называется "двойная буферизация" (double buffering).**

---

## Две фазы работы Fiber

### 1. Render Phase (Фаза рендеринга)

**Что происходит:**
- React проходит по fiber-дереву
- Вызывает функции-компоненты / lifecycle-методы
- Вычисляет, что изменилось (reconciliation)
- Строит список изменений (effects)

**Особенности:**
- **Прерываемая** — можно остановить, возобновить, выбросить
- **Без побочных эффектов** — никакого DOM, никаких сетевых запросов
- **Может вызываться несколько раз** — если React прерывает и возобновляет

**Что вызывается:**
- `render()` в классах
- Функциональный компонент
- `getDerivedStateFromProps`
- `shouldComponentUpdate`

---

### 2. Commit Phase (Фаза коммита)

**Что происходит:**
- React применяет изменения к **реальному DOM**
- Вызывает lifecycle-методы и хуки с побочными эффектами
- Обновляет refs

**Особенности:**
- **Непрерываемая** — выполняется синхронно, за один проход
- **С побочными эффектами** — мутации DOM, `useEffect`, `componentDidMount`
- **Выполняется один раз** — после завершения Render Phase

**Что вызывается:**
- `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`
- `useLayoutEffect` (синхронно)
- `useEffect` (асинхронно, после отрисовки)

---

## Как Fiber работает (пошагово)

### 1. Обновление инициируется

```jsx
setState({ count: 1 });
```

### 2. Render Phase начинается

- React создаёт Work-in-Progress (WIP) дерево
- Проходит по fiber-узлам:
  - Начинает с корня
  - Переходит к `child` → `sibling` → `return` (обход в глубину)
- Для каждого узла:
  - Вызывает функцию-компонент или `render()`
  - Сравнивает новый результат со старым
  - Помечает изменения (`effectTag`: PLACEMENT, UPDATE, DELETION)

**Важно:**  
React может **прервать** эту фазу (например, если пришёл клик пользователя с высоким приоритетом).

### 3. Commit Phase начинается

- React проходит по списку изменений (effects)
- Применяет изменения к DOM:
  - **PLACEMENT** — вставить элемент
  - **UPDATE** — обновить атрибуты
  - **DELETION** — удалить элемент
- Вызывает lifecycle-методы и хуки

### 4. Завершение

- WIP-дерево становится Current
- Пользователь видит обновлённый UI

---

## Приоритеты обновлений

Fiber позволяет React **различать приоритеты** обновлений:

| Приоритет | Примеры | Обработка |
|-----------|---------|-----------|
| **Синхронный (Sync)** | `ReactDOM.render`, события клика | Немедленно |
| **Высокий (User Blocking)** | Ввод в input, hover | Быстро (~250ms) |
| **Обычный (Normal)** | Сетевые запросы, `setState` | Обычная очередь |
| **Низкий (Low)** | Аналитика, логи | Можно отложить |
| **Idle** | Фоновая работа | Когда браузер свободен |

**Пример:**
- Печатаешь в input (высокий приоритет) → React прерывает рендеринг большого списка (низкий приоритет)
- Обрабатывает ввод → возвращается к списку

---

## Concurrent Mode (Конкурентный режим)

**Concurrent Mode** — режим, в котором React может работать над **несколькими обновлениями одновременно**.

**Возможности:**
- **Приоритизация** — важные обновления вытесняют неважные
- **Прерываемый рендеринг** — React может остановиться и вернуться
- **Time Slicing** — разбивает работу на маленькие кусочки, выполняет между кадрами
- **Suspense** — показ fallback UI, пока данные загружаются

**Как Fiber влияет на Concurrent Mode:**

Fiber **делает Concurrent Mode возможным**:
- Без Fiber (старый Stack Reconciler) рендеринг был синхронным и непрерываемым
- С Fiber React может прерывать, приоритизировать, возобновлять — это основа Concurrent Mode

---

## Что изменилось для разработчиков

### Что осталось прежним

- **API React не изменился** — `useState`, `useEffect`, классы работают так же
- **Компоненты пишутся так же** — никаких изменений в коде

### Что изменилось

1. **Lifecycle-методы Render Phase могут вызываться несколько раз**

Методы `render()`, `getDerivedStateFromProps`, `shouldComponentUpdate` должны быть **чистыми** (без побочных эффектов), потому что React может вызвать их несколько раз (прерывание и возобновление).

**Устаревшие методы удалены:**
- `componentWillMount`
- `componentWillReceiveProps`
- `componentWillUpdate`

Эти методы **не были чистыми** → проблемы в Concurrent Mode.

2. **Появились новые возможности**

- `Suspense` — ожидание данных/компонентов
- `useTransition` — низкоприоритетные обновления
- `useDeferredValue` — отложенные значения

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Что такое React Fiber? | Новая архитектура reconciler в React 16+, делает рендеринг прерываемым и приоритизируемым |
| Почему появился Fiber? | Старый алгоритм блокировал UI; нужна была возможность прерывать рендеринг и работать с приоритетами |
| Что такое fiber-узел? | Объект JavaScript, представляющий единицу работы (компонент, элемент); связаны в список |
| Что такое fiber-дерево? | Структура из fiber-узлов, связанных через child/sibling/return; React создаёт Current и WIP деревья |
| Какие две фазы работы Fiber? | **Render** (прерываемая, вычисляет изменения) и **Commit** (непрерываемая, применяет к DOM) |
| Какая фаза прерываемая? | Render — React может остановить, обработать важное событие, вернуться |
| Какая фаза непрерываемая? | Commit — изменения применяются к DOM синхронно, за один проход |
| Что такое Concurrent Mode? | Режим, где React работает над несколькими обновлениями с приоритетами; возможен благодаря Fiber |
| Как Fiber влияет на Concurrent Mode? | Fiber делает его возможным — прерываемый рендеринг и приоритеты |
| Что изменилось для разработчиков? | API то же, но Render Phase методы должны быть чистыми; устаревшие lifecycle удалены |

---

## Кратко для ответа

React Fiber — новая архитектура reconciler (React 16+), делающая рендеринг прерываемым и приоритизируемым. Fiber-узел — единица работы (объект с информацией о компоненте), связаны в список (fiber-дерево). Две фазы: **Render** (прерываемая, вычисляет изменения, может вызываться несколько раз) и **Commit** (непрерываемая, применяет к DOM). Fiber позволяет React приоритизировать обновления и реализовать **Concurrent Mode** — работу над несколькими обновлениями одновременно с разными приоритетами.
