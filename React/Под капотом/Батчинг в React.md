# Батчинг в React

## Краткий ответ для собеседования

**Батчинг** — объединение нескольких `setState`/`useState` в один ререндер для оптимизации. В **React 17** батчинг работал только в обработчиках событий; в **React 18** (Automatic Batching) — везде: в `setTimeout`, `Promise`, нативных событиях. Зачем придумали: избежать лишних ререндеров, ускорить работу, меньше операций с DOM.

---

## Что такое батчинг

**Батчинг (Batching)** — процесс объединения нескольких обновлений состояния (`setState`, `useState`) в **один ререндер**.

**Без батчинга:**

```jsx
setCount(1);    // ререндер 1
setName('John'); // ререндер 2
setAge(30);      // ререндер 3
// Итого: 3 ререндера
```

**С батчингом:**

```jsx
setCount(1);
setName('John');
setAge(30);
// Итого: 1 ререндер (все обновления объединены)
```

---

## Зачем придумали батчинг

### 1. **Избежать лишних ререндеров**

Каждый ререндер:
- Вызывает функцию-компонент / `render()`
- Пересчитывает Virtual DOM
- Сравнивает с предыдущим Virtual DOM (reconciliation)
- Обновляет реальный DOM

**3 `setState` без батчинга = 3 полных цикла рендеринга.**

### 2. **Ускорить работу приложения**

Меньше ререндеров → меньше работы → быстрее UI.

### 3. **Меньше операций с DOM**

DOM-операции дорогие; батчинг минимизирует их количество.

### 4. **Консистентность состояния**

Все изменения применяются одновременно → нет промежуточных состояний.

---

## Батчинг в React 17 и раньше

### Где работал батчинг

✅ **В обработчиках событий React:**

```jsx
function handleClick() {
  setCount(count + 1);
  setFlag(true);
  // 1 ререндер
}

<button onClick={handleClick}>Click</button>
```

✅ **В lifecycle-методах:**

```jsx
componentDidMount() {
  this.setState({ count: 1 });
  this.setState({ name: 'John' });
  // 1 ререндер
}
```

---

### Где НЕ работал батчинг

❌ **В `setTimeout`:**

```jsx
function handleClick() {
  setTimeout(() => {
    setCount(count + 1); // ререндер 1
    setFlag(true);        // ререндер 2
  }, 0);
}
// 2 ререндера
```

❌ **В Promise:**

```jsx
function handleClick() {
  fetch('/api')
    .then(() => {
      setCount(count + 1); // ререндер 1
      setFlag(true);        // ререндер 2
    });
}
// 2 ререндера
```

❌ **В нативных обработчиках событий:**

```jsx
useEffect(() => {
  document.addEventListener('click', () => {
    setCount(count + 1); // ререндер 1
    setFlag(true);        // ререндер 2
  });
}, []);
// 2 ререндера
```

**Причина:**  
В React 17 батчинг работал только внутри **синхронных React-обработчиков** (onClick, onChange). Асинхронный код (setTimeout, Promise) выполняется вне контроля React → нет батчинга.

---

## Automatic Batching в React 18

**Нововведение:**  
React 18 автоматически батчит обновления **везде**, а не только в обработчиках событий.

### Где теперь работает батчинг

✅ **В `setTimeout`:**

```jsx
setTimeout(() => {
  setCount(count + 1);
  setFlag(true);
  // 1 ререндер (было 2 в React 17)
}, 0);
```

✅ **В Promise:**

```jsx
fetch('/api').then(() => {
  setCount(count + 1);
  setFlag(true);
  // 1 ререндер (было 2 в React 17)
});
```

✅ **В нативных событиях:**

```jsx
document.addEventListener('click', () => {
  setCount(count + 1);
  setFlag(true);
  // 1 ререндер (было 2 в React 17)
});
```

✅ **Везде:**

Батчинг работает в **любом месте** — обработчиках, таймаутах, промисах, async/await, нативных событиях.

---

## Как отключить батчинг (React 18)

Иногда нужно **принудительный синхронный ререндер** (например, чтение значения из DOM сразу после обновления).

### `ReactDOM.flushSync()`

```jsx
import { flushSync } from 'react-dom';

function handleClick() {
  flushSync(() => {
    setCount(count + 1); // ререндер 1 (сразу)
  });
  
  flushSync(() => {
    setFlag(true); // ререндер 2 (сразу)
  });
}
// Итого: 2 ререндера (батчинг отключён)
```

**Когда использовать:**
- Нужно прочитать DOM сразу после обновления
- Интеграция со сторонними библиотеками
- Очень редко (батчинг почти всегда лучше)

---

## Примеры

### Пример 1: React 17 vs React 18

```jsx
function handleClick() {
  fetch('/api').then(() => {
    setCount(c => c + 1);
    setName('John');
    setAge(30);
  });
}
```

**React 17:** 3 ререндера (каждый `setState` отдельно)  
**React 18:** 1 ререндер (автоматический батчинг)

---

### Пример 2: Несколько `setState` в одной функции

```jsx
function handleClick() {
  setCount(1);
  setCount(2);
  setCount(3);
}
```

**Результат:**  
1 ререндер, `count = 3` (последнее значение).

**Важно:**  
Если используете функциональный апдейт, порядок имеет значение:

```jsx
setCount(c => c + 1); // 0 → 1
setCount(c => c + 1); // 1 → 2
setCount(c => c + 1); // 2 → 3
// count = 3
```

---

## Преимущества батчинга

1. **Меньше ререндеров** — один вместо нескольких
2. **Быстрее** — меньше работы для React и браузера
3. **Меньше операций с DOM** — DOM обновляется один раз
4. **Консистентность** — все изменения применяются одновременно, нет промежуточных состояний

---

## Недостатки / ограничения

1. **Отложенные обновления**

Обновления не применяются мгновенно:

```jsx
setCount(1);
console.log(count); // 0 (старое значение, обновление ещё не произошло)
```

Решение: использовать `useEffect` для реакции на изменение.

2. **Редкие случаи без батчинга**

Если действительно нужен синхронный ререндер — использовать `flushSync()`.

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| Что такое батчинг? | Объединение нескольких `setState` в один ререндер |
| Зачем придумали батчинг? | Избежать лишних ререндеров, ускорить работу, меньше DOM-операций |
| Где работал батчинг в React 17? | Только в обработчиках событий React (onClick, onChange), lifecycle-методах |
| Где НЕ работал батчинг в React 17? | В `setTimeout`, `Promise`, нативных событиях |
| Что изменилось в React 18? | Automatic Batching — батчинг везде (setTimeout, Promise, нативные события) |
| Как отключить батчинг? | `ReactDOM.flushSync()` — принудительный синхронный ререндер |
| Сколько ререндеров при 3 `setState`? | 1 ререндер (если батчинг работает) |

---

## Кратко для ответа

Батчинг — объединение нескольких `setState` в один ререндер для оптимизации. **React 17:** батчинг только в обработчиках событий; в `setTimeout`/`Promise` — нет батчинга (несколько ререндеров). **React 18:** Automatic Batching — батчинг везде (таймауты, промисы, нативные события). Зачем: меньше ререндеров, быстрее, меньше DOM-операций. Отключить: `ReactDOM.flushSync()`.
