# React.js и Next.js — разница

## Краткий ответ для собеседования

**React** — библиотека для UI: компоненты, стейт, хуки, всё выполняется в браузере. **Next.js** — фреймворк поверх React: роутинг, серверный рендеринг, серверные и клиентские компоненты. В Next по умолчанию компоненты **серверные**: в них нельзя использовать стейт, хуки (useState, useEffect), методы жизненного цикла и классовые компоненты — они выполняются на сервере. Для интерактивности нужны **клиентские компоненты** с директивой `'use client'`: там работает обычный React. Fetch в Next доработан: кэширование, один и тот же запрос даёт один результат, можно задать revalidate. На сервере можно делать запросы к БД и использовать секретные ключи — пользователь их не видит. Серверные компоненты — для данных и разметки, клиентские — только там, где нужны события и состояние.

---

## React и Next: кто что делает

**React.js** — это библиотека. Она отвечает за то, как устроены компоненты, стейт, хуки, отрисовка в браузере. React не знает про роуты, серверный рендеринг или откуда брать данные: это ты настраиваешь сам (или через другой фреймворк).

**Next.js** — это фреймворк на базе React. Он добавляет роутинг по файлам, серверный рендеринг (SSR), статическую генерацию (SSG), серверные и клиентские компоненты, доработанный fetch и многое другое. В Next часть приложения выполняется на сервере, часть — в браузере. Поэтому не всё, что привычно в «голом» React, доступно в любом компоненте Next.

Главное запомнить: в Next есть **два типа компонентов** — серверные и клиентские. От этого зависит, что в компоненте можно, а что нельзя.

---

## Серверные и клиентские компоненты

### Серверные компоненты (по умолчанию в App Router)

В Next (App Router) компоненты по умолчанию считаются **серверными**. Они выполняются **только на сервере**: при запросе страницы сервер их отрисовывает и отправляет готовый результат (разметку и данные) в браузер. Код серверного компонента в браузер не попадает.

Из этого следует, чего **нельзя** в серверном компоненте:

- **Стейт** (useState) — компонент не «живёт» в браузере, обновлений по клику нет.
- **Хуки вроде useEffect, useLayoutEffect** — они привязаны к жизненному циклу в браузере (монтирование, обновление, размонтирование). На сервере жизненного цикла в таком виде нет.
- **Методы жизненного цикла** (componentDidMount и т.д.) — это про классовые компоненты и поведение в браузере. В серверном компоненте классовый компонент с жизненным циклом не имеет смысла: он выполняется один раз на сервере.
- **Классовые компоненты** — в серверных компонентах не используются; серверные компоненты — только функциональные, причём без хуков и стейта.
- **Браузерные API** (window, document, localStorage и т.д.) — на сервере их нет.
- **Обработчики событий** (onClick, onChange и т.д.) — интерактивность нужна в браузере, поэтому события обрабатываются только в клиентских компонентах.

Что **можно** в серверном компоненте:

- **async/await** — серверный компонент может быть асинхронной функцией и прямо внутри себя делать запросы к БД или API.
- **Прямые запросы к базе или внутренним сервисам** — без отдельного API-слоя для браузера.
- **Секретные ключи и переменные окружения** — они остаются на сервере, в браузер не уходят.
- **Тяжёлые библиотеки** — их код выполняется только на сервере и не увеличивает клиентский бандл.

Итого: серверный компонент — это «кусок UI», который рисуется на сервере один раз при запросе. Никакой интерактивности, стейта и жизненного цикла в нём нет. Он нужен для данных и разметки.

### Клиентские компоненты и 'use client'

Если нужна интерактивность — кнопки, форма, стейт, подписки, эффекты — компонент должен выполняться в браузере. Для этого в Next его помечают директивой **'use client'** в начале файла. Такой компонент называется **клиентским**.

В клиентском компоненте работает **обычный React**:

- Можно использовать **стейт** (useState), **хуки** (useEffect, useCallback, useMemo и т.д.).
- Можно писать **классовые компоненты** (хотя обычно используют функциональные с хуками).
- Доступны **методы жизненного цикла** через хуки (useEffect как аналог componentDidMount и т.д.).
- Можно использовать **обработчики событий** (onClick, onChange).
- Доступны **браузерные API** (window, document, localStorage).

Важно: директива **'use client'** не означает «весь файл отправляется в браузер». Она означает «компоненты из этого файла выполняются на клиенте». Импорты из этого файла в другие файлы делают дочерние компоненты тоже клиентскими, если они там определены или реэкспортируются. То есть граница «сервер — клиент» проходит по файлам и импортам: как только в цепочке есть 'use client', всё ниже по дереву компонентов считается клиентским.

Зачем это различать: серверные компоненты не попадают в клиентский бандл, не навешивают обработчики в браузере и могут спокойно тянуть данные и секреты на сервере. Клиентские — только там, где реально нужны события и состояние. Так и бандл меньше, и безопасность лучше.
![[Screenshot at Jan 31 17-04-10.png]]
---

## Как использовать серверные и клиентские компоненты вместе

- **По умолчанию** делай компоненты серверными: они дешёвые для клиента и могут сразу тянуть данные.
- **'use client'** добавляй только тем компонентам (или их родителям), которым нужны стейт, эффекты или события. Например: кнопка «Добавить в корзину», форма входа, модальное окно, табы.
- Серверный компонент может **рендерить** клиентский как ребёнка: передаёт ему пропсы (данные), а интерактивность остаётся внутри клиентского. Данные подготовил сервер — отобразил и передал в клиентский компонент; клиентский только «оживляет» UI.
- Не стоит оборачивать всё приложение в один большой 'use client': тогда всё станет клиентским и потеряется смысл серверных компонентов (меньший бандл, данные на сервере). Лучше держать 'use client' на уровне мелких интерактивных кусков.

На собеседовании можно сказать: «В Next по умолчанию компоненты серверные, в них нет стейта и хуков. Где нужна интерактивность — ставлю 'use client' и пишу обычный React. Серверные использую для данных и разметки, клиентские — только для событий и состояния.»

---

## Fetch в Next.js: кэширование и revalidate

В Next встроен **доработанный fetch**. Поведение такое:

- **Кэширование по умолчанию**: один и тот же запрос (тот же URL и опции) при повторном обращении может вернуть закэшированный результат, а не идти в сеть снова. То есть «один запрос — один результат» в рамках кэша.
- Это удобно для статики и данных, которые не меняются каждый раз: меньше запросов, быстрее ответ.
- Если нужно **обновлять данные** (например, раз в минуту или при определённом действии), в Next можно задать **revalidate**: через сколько секунд кэш считать устаревшим и при следующем запросе обновить данные, или отключить кэш для конкретного запроса.

То есть fetch в Next — не «как в браузере», а с настройками кэша и revalidate под серверный и клиентский рендеринг. На собеседовании: «В Next fetch расширен: по умолчанию кэшируется, один и тот же запрос даёт один результат. Можно настроить revalidate или отключить кэш там, где нужны свежие данные.»

---

## Запросы на сервере и секретные ключи

В серверных компонентах (и в серверных API-роутах) запросы выполняются **на сервере**. Пользователь их не видит: в браузере в Network летят только запросы к твоему Next-приложению (или к тем API, которые вызываются из клиентского кода). Запросы с сервера к БД, к внутренним микросервисам или к внешним API с секретным ключом **не попадают в браузер**.

Поэтому в Next можно:

- **Использовать секретные ключи** (API keys, пароли к БД) в переменных окружения на сервере и вызывать с ними внешние API или БД. В клиентский бандл и в ответ пользователю они не уходят.
- **Делать запросы напрямую к своей БД** из серверного компонента или серверного API — без проксирования через отдельный backend, если не нужна отдельная служба.
- Не светить лишние эндпоинты и ключи в браузере — вся чувствительная логика остаётся на сервере.

На собеседовании: «В Next запросы из серверных компонентов идут с сервера. Пользователь не видит эти запросы и не видит секретные ключи — они остаются на сервере.»

---

## Что ещё полезно помнить про разницу React и Next

- **Роутинг**: в React маршруты настраиваются вручную (например, React Router). В Next роутинг файловый: структура папок в `app` (или `pages`) задаёт маршруты.
- **SSR и SSG**: Next из коробки умеет рендерить страницы на сервере (SSR) или генерировать статический HTML при сборке (SSG). В «голом» React по умолчанию только клиентский рендеринг (CSR).
- **Метаданные и SEO**: в Next удобно задавать title, description и т.д. для страниц (через конфиг или экспорт метаданных). В обычном React это обычно делают вручную в документе или через хелперы.
- **API Routes**: в Next можно описать API-эндпоинты рядом с фронтом (файлы в `app` или `pages`). В React отдельно нужен backend.
- **Сборка и деплой**: Next собирает и серверную часть, и клиентский бандл; для работы нужен Node-сервер (или адаптер под статику). React (CRA, Vite) чаще отдаёт статику, которую крутит любой веб-сервер.

Кратко: React — «как рисовать UI и управлять состоянием в браузере». Next — «как собрать полноценное приложение с роутингом, сервером, серверными и клиентскими компонентами и умным fetch».

---

## Вопросы на собеседовании

| Вопрос | Краткий ответ |
|--------|----------------|
| В чём разница React и Next? | React — библиотека для UI (компоненты, стейт, хуки). Next — фреймворк на React: роутинг, SSR/SSG, серверные и клиентские компоненты, расширенный fetch. |
| Почему в Next нельзя использовать стейт и хуки в любом компоненте? | По умолчанию компоненты в Next (App Router) — серверные. Они выполняются на сервере один раз; там нет жизненного цикла браузера и стейта. Стейт и хуки — только в клиентских компонентах. |
| Что такое 'use client'? | Директива в Next: компоненты из этого файла выполняются на клиенте. В них можно использовать стейт, хуки, события — обычный React. |
| Чем fetch в Next отличается от обычного? | В Next fetch расширен: кэширование по умолчанию, один и тот же запрос даёт один результат. Можно настроить revalidate (обновление кэша по времени) или отключить кэш. |
| Почему в Next можно использовать секретные ключи? | Запросы из серверных компонентов идут с сервера. Пользователь не видит эти запросы и не видит ключи — они не попадают в браузер. |
| Как сочетать серверные и клиентские компоненты? | По умолчанию — серверные (данные, разметка). 'use client' только там, где нужны события, стейт или эффекты. Серверный может рендерить клиентский и передавать ему данные через пропсы. |

---

## Кратко для ответа

**React** — библиотека для UI в браузере; **Next.js** — фреймворк на React с роутингом, SSR/SSG и делением на серверные и клиентские компоненты. В **серверных** компонентах нельзя использовать стейт, хуки, методы жизненного цикла и классовые компоненты — они выполняются на сервере. Для интерактивности нужны **клиентские** компоненты с **'use client'** — там работает обычный React. Fetch в Next доработан: кэширование, один запрос — один результат, настраивается revalidate. Запросы с сервера и секретные ключи пользователь не видит. Серверные компоненты — для данных и разметки, клиентские — только где нужны события и состояние.
