## üîß –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã –≤ TypeScript

–†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã –ø–æ–∑–≤–æ–ª—è—é—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å –≥–∏–±–∫–∏–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –¥–ª—è —Ç–∏–ø–∏–∑–∞—Ü–∏–∏, —É–ø—Ä–æ—â–∞—è —Ä–∞–±–æ—Ç—É —Å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–º–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö –∏ –ø–æ–≤—ã—à–∞—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∫–æ–¥–∞.

---

## üó∫Ô∏è Mapped Types (–ú–∞–ø–ø–∏–Ω–≥ —Ç–∏–ø–æ–≤)

–ú–∞–ø–ø–∏–Ω–≥ —Ç–∏–ø–æ–≤ —Å–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—ã–µ —Ç–∏–ø—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö, –∏—Ç–µ—Ä–∏—Ä—É—è—Å—å –ø–æ –∫–ª—é—á–∞–º –æ–±—ä–µ–∫—Ç–∞.

### **–ë–∞–∑–æ–≤—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å:**

```ts
type Readonly<T> = {
  readonly [K in keyof T]: T[K];
};

interface User {
  id: number;
  name: string;
}

type ReadonlyUser = Readonly<User>;
// { readonly id: number; readonly name: string; }
```

### **–£–¥–∞–ª–µ–Ω–∏–µ –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–≤:**

```ts
// –£–¥–∞–ª–µ–Ω–∏–µ readonly
type Mutable<T> = {
  -readonly [K in keyof T]: T[K];
};

// –£–¥–∞–ª–µ–Ω–∏–µ optional (?)
type Required<T> = {
  [K in keyof T]-?: T[K];
};
```

### **–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Ç–∏–ø–æ–≤ —Å–≤–æ–π—Å—Ç–≤:**

```ts
type Stringify<T> = {
  [K in keyof T]: string;
};

type User = { id: number; name: string; };
type StringUser = Stringify<User>;
// { id: string; name: string; }
```

---

## ‚ùì Conditional Types (–£—Å–ª–æ–≤–Ω—ã–µ —Ç–∏–ø—ã)

–£—Å–ª–æ–≤–Ω—ã–µ —Ç–∏–ø—ã –æ–ø–∏—Å—ã–≤–∞—é—Ç –ª–æ–≥–∏–∫—É –Ω–∞ —É—Ä–æ–≤–Ω–µ —Ç–∏–ø–æ–≤: `T extends U ? X : Y`

### **–ë–∞–∑–æ–≤—ã–π –ø—Ä–∏–º–µ—Ä:**

```ts
type IsString<T> = T extends string ? true : false;

type A = IsString<string>;  // true
type B = IsString<number>;  // false
```

### **–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–∏–ø–∞ –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏:**

```ts
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

function getValue(): string {
  return "Hello";
}

type ValueType = ReturnType<typeof getValue>; // string
```

### **–§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Ç–∏–ø–æ–≤:**

```ts
type ExcludeString<T> = T extends string ? never : T;

type Result = ExcludeString<number | string | boolean>;
// number | boolean (string –∏—Å–∫–ª—é—á—ë–Ω)
```

### **–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –∫–ª—é—á–∞:**

```ts
type HasKey<T, K extends string> = K extends keyof T ? true : false;

type Check = HasKey<{ name: string }, "name">; // true
```

---

## üîç Infer (–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–∏–ø–æ–≤)

`infer` –ø–æ–∑–≤–æ–ª—è–µ—Ç –∏–∑–≤–ª–µ–∫–∞—Ç—å —Ç–∏–ø—ã –≤–Ω—É—Ç—Ä–∏ —É—Å–ª–æ–≤–Ω—ã—Ö –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–π.

### **–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏:**

```ts
type Parameters<T> = T extends (...args: infer P) => any ? P : never;

function sum(a: number, b: number): number {
  return a + b;
}

type Args = Parameters<typeof sum>; // [number, number]
```

### **–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–∏–ø–∞ –∏–∑ –º–∞—Å—Å–∏–≤–∞:**

```ts
type ElementType<T> = T extends (infer U)[] ? U : never;

type ArrayElement = ElementType<number[]>; // number
type StringElement = ElementType<string[]>; // string
```

### **–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ —Ç–∏–ø–∞:**

```ts
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

type FuncReturn = ReturnType<() => string>; // string
```

---

## üéØ –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–∏–º–µ—Ä—ã

### **–°–æ–∑–¥–∞–Ω–∏–µ —Ç–∏–ø–∞ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è:**

```ts
type Update<T> = Partial<Pick<T, Exclude<keyof T, 'id'>>>;

interface User {
  id: number;
  name: string;
  email: string;
}

type UserUpdate = Update<User>;
// { name?: string; email?: string; } (id –∏—Å–∫–ª—é—á—ë–Ω)
```

### **–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Ç–∏–ø–∞ –ø—Ä–æ–º–∏—Å–∞:**

```ts
type Awaited<T> = T extends Promise<infer U> ? U : T;

type PromiseValue = Awaited<Promise<string>>; // string
```

### **–£—Å–ª–æ–≤–Ω–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–≤–æ–π—Å—Ç–≤–∞:**

```ts
type WithId<T, HasId extends boolean> = HasId extends true
  ? T & { id: number }
  : T;

type UserWithId = WithId<{ name: string }, true>;
// { name: string; id: number; }
```

---

## üéØ –ö—Ä–∞—Ç–∫–∏–π –æ—Ç–≤–µ—Ç –¥–ª—è —Å–æ–±–µ—Å–µ–¥–æ–≤–∞–Ω–∏—è

**–†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã TypeScript:**
- **Mapped Types** ‚Äî —Å–æ–∑–¥–∞—é—Ç –Ω–æ–≤—ã–µ —Ç–∏–ø—ã, –∏—Ç–µ—Ä–∏—Ä—É—è—Å—å –ø–æ –∫–ª—é—á–∞–º –æ–±—ä–µ–∫—Ç–∞ (`[K in keyof T]`)
- **Conditional Types** ‚Äî —É—Å–ª–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞ –Ω–∞ —É—Ä–æ–≤–Ω–µ —Ç–∏–ø–æ–≤ (`T extends U ? X : Y`)
- **Infer** ‚Äî –∏–∑–≤–ª–µ–∫–∞–µ—Ç —Ç–∏–ø—ã –≤–Ω—É—Ç—Ä–∏ —É—Å–ª–æ–≤–Ω—ã—Ö –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–π
- –ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –≥–∏–±–∫–∏—Ö –∏ –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö —Ç–∏–ø–æ–≤

---

## ‚ùì –ö–∞–≤–µ—Ä–∑–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã –∏ –æ—Ç–≤–µ—Ç—ã

### **1. –í —á–µ–º —Ä–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É Mapped Types –∏ Utility Types?**

**–û—Ç–≤–µ—Ç:**
- **Mapped Types** ‚Äî —ç—Ç–æ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Ç–∏–ø–æ–≤ (`[K in keyof T]`)
- **Utility Types** ‚Äî —ç—Ç–æ –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —Ç–∏–ø—ã, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏–µ mapped types (`Partial`, `Pick`, `Omit`)

```ts
// Mapped Type (—Å–∏–Ω—Ç–∞–∫—Å–∏—Å)
type Readonly<T> = {
  readonly [K in keyof T]: T[K];
};

// Utility Type (–≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç mapped type)
type Partial<T> = {
  [K in keyof T]?: T[K];
};
```

---

### **2. –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Conditional Types?**

**–û—Ç–≤–µ—Ç:**
–ö–æ–≥–¥–∞ –Ω—É–∂–Ω–æ —Å–æ–∑–¥–∞—Ç—å —Ç–∏–ø, –∫–æ—Ç–æ—Ä—ã–π –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —É—Å–ª–æ–≤–∏—è:

```ts
// –ü—Ä–∏–º–µ—Ä: —Ç–∏–ø –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ç–æ–≥–æ, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ T –º–∞—Å—Å–∏–≤–æ–º
type Flatten<T> = T extends (infer U)[] ? U : T;

type A = Flatten<string[]>;  // string
type B = Flatten<number>;    // number
```

---

### **3. –ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç `infer`?**

**–û—Ç–≤–µ—Ç:**
`infer` –∏–∑–≤–ª–µ–∫–∞–µ—Ç —Ç–∏–ø –∏–∑ –¥—Ä—É–≥–æ–≥–æ —Ç–∏–ø–∞ –≤–Ω—É—Ç—Ä–∏ —É—Å–ª–æ–≤–Ω–æ–≥–æ —Ç–∏–ø–∞:

```ts
type ExtractReturn<T> = T extends () => infer R ? R : never;

type R = ExtractReturn<() => string>; // string
```

**–í–∞–∂–Ω–æ:** `infer` —Ä–∞–±–æ—Ç–∞–µ—Ç —Ç–æ–ª—å–∫–æ –≤ —É—Å–ª–æ–≤–Ω—ã—Ö —Ç–∏–ø–∞—Ö (`extends`).

---

### **4. –ú–æ–∂–Ω–æ –ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ `infer` –≤ –æ–¥–Ω–æ–º —Ç–∏–ø–µ?**

**–û—Ç–≤–µ—Ç:**
–î–∞, –º–æ–∂–Ω–æ –∏–∑–≤–ª–µ–∫–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ç–∏–ø–æ–≤:

```ts
type ExtractParams<T> = T extends (a: infer A, b: infer B) => any 
  ? [A, B] 
  : never;

type Params = ExtractParams<(a: string, b: number) => void>;
// [string, number]
```

---

### **5. –ß—Ç–æ —Ç–∞–∫–æ–µ distributive conditional types?**

**–û—Ç–≤–µ—Ç:**
–£—Å–ª–æ–≤–Ω—ã–µ —Ç–∏–ø—ã —Ä–∞—Å–ø—Ä–µ–¥–µ–ª—è—é—Ç—Å—è –ø–æ union —Ç–∏–ø–∞–º:

```ts
type ToArray<T> = T extends any ? T[] : never;

type Result = ToArray<string | number>;
// string[] | number[] (–Ω–µ (string | number)[])
```

**–û—Ç–∫–ª—é—á–µ–Ω–∏–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è:**
```ts
type ToArray<T> = [T] extends [any] ? T[] : never;
// –¢–µ–ø–µ—Ä—å: (string | number)[]
```

---

## üìö –ü–æ–ª–µ–∑–Ω—ã–µ –ø—Ä–∞–∫—Ç–∏–∫–∏

- **–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ Mapped Types** –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –≤—Å–µ—Ö —Å–≤–æ–π—Å—Ç–≤ –æ–±—ä–µ–∫—Ç–∞
- **–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ Conditional Types** –¥–ª—è –ª–æ–≥–∏–∫–∏ –Ω–∞ —É—Ä–æ–≤–Ω–µ —Ç–∏–ø–æ–≤
- **–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `infer`** –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Ç–∏–ø–æ–≤ –∏–∑ —Å–ª–æ–∂–Ω—ã—Ö –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–π
- **–ö–æ–º–±–∏–Ω–∏—Ä—É–π—Ç–µ** mapped types, conditional types –∏ `infer` –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö —Ç–∏–ø–æ–≤
- **–¢–µ—Å—Ç–∏—Ä—É–π—Ç–µ —Ç–∏–ø—ã** –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã—Ö –ø—Ä–∏–º–µ—Ä–∞—Ö –ø–µ—Ä–µ–¥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º




